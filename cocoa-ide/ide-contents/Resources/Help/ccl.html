<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="ccl.css" />
<div id="icon">
	<img src="ccl.gif" alt="" height="32" width="32" border="0"></div>
<title>
	Clozure CL Documentation</title>
</head>
<body>
<div class=toc><div class="sidebar">
<ul style="list-style: none">
<li><a href="#about-clozure-cl">
About Clozure CL</a>
<li><a href="#installing-and-running-clozure-cl">
Installing and Running Clozure CL</a>
<li><a href="#building-clozure-cl-from-its-source-code">
Building Clozure CL from its Source Code</a>
<li><a href="#using-clozure-cl">
Using Clozure CL</a>
<li><a href="#top-level-interface">
Top-level Interface</a>
<li><a href="#debugging">
Debugging</a>
<li><a href="#characters-and-external-formats">
Characters and External Formats</a>
<li><a href="#file-system-interface">
File System Interface</a>
<li><a href="#operating-system-interface">
Operating System Interface</a>
<li><a href="#programming-with-sockets">
Programming with Sockets</a>
<li><a href="#programming-with-threads">
Programming with Threads</a>
<li><a href="#the-foreign-function-interface">
The Foreign Function Interface</a>
<li><a href="#running-other-programs-as-subprocesses">
Running Other Programs as Subprocesses</a>
<li><a href="#streams">
Streams</a>
<li><a href="#platform-specific-notes">
Platform-specific notes</a>
<li><a href="#understanding-and-configuring-the-garbage-collector">
Understanding and Configuring the Garbage Collector</a>
<li><a href="#implementation-limits">
Implementation Limits</a>
<li><a href="#implementation-details-of-clozure-cl">
Implementation Details of Clozure CL</a>
<li><a href="#modifying-clozure-cl">
Modifying Clozure CL</a>
<li><a href="#profiling">
Profiling</a>
<li><a href="#clos-metaobject-protocol">
CLOS Metaobject Protocol</a>
<li><a href="#the-objective-c-bridge">
The Objective-C Bridge</a>
<li><a href="#the-clozure-cl-ide">
The Clozure CL IDE</a>
<li><a href="#hemlock-programming">
Hemlock Programming</a>
<li><a href="#questions-and-answers">
Questions and Answers</a>
<li><a href="#glossary-of-terms">
Glossary of Terms</a>
<li><a href="#symbol-index">
Symbol Index</a>
<li><a href="#ccl-exported-symbols">
CCL Exported Symbols</a>
</ul>
</div>
</div><div class=body><a id="about-clozure-cl"></a>
<H2>About Clozure CL</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#introduction-to-clozure-cl">
Introduction to Clozure CL</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="introduction-to-clozure-cl"></a>
<H3>Introduction to Clozure CL</H3>
<div class="section">
<p>Clozure CL is a fast, mature, open source Common Lisp
      implementation that runs on Linux, Mac OS X, FreeBSD, and Windows.
      Clozure CL was forked from Macintosh Common Lisp (MCL) in 1998
      and the development has been entirely separate since.</p>
<p>      When it was forked from MCL in 1998, the new Lisp was named
      OpenMCL. Subsequently, Clozure renamed its Lisp to Clozure CL, partly
      because its ancestor MCL has been released as open
      source. Clozure thought it might be confusing for users if there
      were two independent open-source projects with such similar
      names. The new name also reflects Clozure CL's current status as the
      flagship product of Clozure Associates.</p>
<p>      Furthermore, the new name refers to Clozure CL's ancestry: in its
      early years, MCL was known as Coral Common Lisp, or “CCL”. For
      years the package that contains most of Clozure CL's
      implementation-specific symbols has been named “CCL”, an acronym
      that once stood for the name of the Lisp product. It seems
      fitting that “CCL” once again stands for the name of the
      product.</p>
<p>      Some commands and source files may still refer to “OpenMCL”
      instead of Clozure CL.</p>
<p>      Clozure CL compiles to native code and supports multithreading
      using native OS threads. It includes a foreign-function interface,
      and supports both Lisp code that calls external code, and external
      code that calls Lisp code. Clozure CL can create standalone executables
      on all supported platforms.</p>
<p>      On Mac OS X, Clozure CL supports building GUI applications that
      use OS X's native Cocoa frameworks, and the OS X distributions
      include an IDE written with Cocoa, and distributed with complete
      sources.</p>
<p>      On all supported platforms, Clozure CL can run as a command-line
      process, or as an inferior Emacs process using either SLIME or
      ILISP.</p>
<p>Features of Clozure CL include</p>
<ul><li><p>Very fast compilation speed.</p>
<li><p>A fast, precise, compacting, generational
      garbage collector written in hand-optimized C. The sizes of the
      generations are fully configurable. Typically, a generation can
      be collected in a millisecond on modern
      systems.</p>
<li><p>Fast execution speed, competitive with other
      Common Lisp implementations on most
      benchmarks.</p>
<li><p>Robust and stable. Customers report that their
      CPU-intensive, multi-threaded applications run for extended
      periods on Clozure CL without difficulty.</p>
<li><p>Full native OS threads on all platforms. Threads
      are automatically distributed across multiple cores. The API
      includes support for shared memory, locking, and blocking for OS
      operations such as I/O.</p>
<li><p>Full Unicode support.</p>
<li><p>Full SLIME integration.</p>
<li><p>An IDE on Mac OS X, fully integrated with
      the Macintosh window system and User Interface
      standards.</p>
<li><p>Excellent debugging facilities. The names of all
      local variables are available in a backtrace.</p>
<li><p>A complete, mature foreign function interface,
      including a powerful bridge to Objective-C and Cocoa on Mac OS
      X.</p>
<li><p>Many extensions including: files mapped to
      Common Lisp vectors for fast file I/O; thread-local hash tables
      and streams to eliminate locking overhead; cons hashing support;
      and much more</p>
<li><p>Very efficient use of memory</p>
</ul>
<p>Although it's an open-source project, available free of
      charge under a liberal license, Clozure CL is also a fully-supported
      product of Clozure Associates. Clozure continues to extend,
      improve, and develop Clozure CL in response to customer and user
      needs, and offers full support and development services for
      Clozure CL.</p>
</div>
</div>
<a id="installing-and-running-clozure-cl"></a>
<H2>Installing and Running Clozure CL</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#installing">
Installing</a>
<ul style="list-style: none">
</ul>
<li><a href="#running-clozure-cl">
Running Clozure CL</a>
<ul style="list-style: none">
<li><a href="#the-init-file">
The Init File</a>
<li><a href="#command-line-options">
Command Line Options</a>
<li><a href="#running-clozure-cl-as-a-mac-application">
Running Clozure CL as a Mac Application</a>
</ul>
</ul>
<a id="installing"></a>
<H3>Installing</H3>
<div class="section">
<p>Clozure CL is distributed via the Internet.  Please see <a href="http://ccl.clozure.com/download.html">http://ccl.clozure.com/download.html</a>
 for instructions on how to
download it.</p>
<p>After following the download instructions, you should have a directory
on your system named <CODE>ccl</CODE>.  This directory is called the <a href="#ccl_directory">ccl directory</a>.</p>
<p>Clozure CL is made up of two parts: the <a href="#lisp_kernel">lisp kernel</a>, and a <a href="#heap_image">heap image</a>.  When the lisp kernel starts up, it locates the heap
image, maps it into memory, and starts running the lisp code contained
in the image.  In the ccl directory, you will find pre-built lisp
kernel executables and heap images for your platform.</p>
<p>The names used for the lisp kernel on the various platforms are listed
in the table below.  The heap images have the same basename as the
corresponding lisp kernel, but a <CODE>.image</CODE> suffix.  Thus, the
image name for <CODE>armcl</CODE> would be <CODE>armcl.image</CODE>.</p>
<a id="tab_kernel-names-by-platform"></a>
<table>
<caption>Kernel Names by Platform</caption>
<tr><td>Platform
<td>Kernel
</tr>
<tr><td>Linux x86, x86-64
<td>lx86cl, lx86cl64
</tr>
<tr><td>OS X x86, x86-64
<td>dx86cl, dx86cl64
</tr>
<tr><td>FreeBSD x86, x86-64
<td>fx86cl, fx86cl64
</tr>
<tr><td>Solaris x86, x86-64
<td>sx86cl, sx86cl64
</tr>
<tr><td>Windows x86, x86-64
<td>wx86cl, wx86cl64
</tr>
<tr><td>Linux PowerPC 32-bit, 64-bit
<td>ppccl, ppccl64
</tr>
<tr><td>Linux ARM 32-bit (armv6)
<td>armcl
</tr>
</table>
<p>By default, the lisp kernel will look for a heap image with an
appropriate name in the same directory that the lisp kernel itself is
in.  Thus, it is possible to start Clozure CL simply by running <CODE>./lx86cl64</CODE> (or whatever the appropriate binary is called) directly
from the ccl directory.</p>
<p>   If the lisp kernel binary does not work, you may need to recompile it
on your local system.  See <a href="#building-the-kernel">Building the Kernel</a>.</p>
</div>
<a id="running-clozure-cl"></a>
<H3>Running Clozure CL</H3>
<div class="section">
<p>If you always run Clozure CL from Emacs, it is sufficient to use the full pathname
of the lisp kernel binary directly.  That is, in your Emacs init file, you could write something
like <CODE>(setq inferior-lisp-program "/path/to/ccl/lx86cl64")</CODE> or make the equivalent
changes to <CODE>slime-lisp-implementations</CODE>.</p>
<p>    It can also be handy to run Clozure CL straight from a terminal prompt.
In the <CODE>scripts/</CODE> directory of the ccl directory, there are two
files named <CODE>ccl</CODE> and <CODE>ccl64</CODE>.  Copy these files into
<CODE>/usr/local/bin</CODE> or some other directory that is on your path, and then
edit them so that the value of <CODE>CCL_DEFAULT_DIRECTORY</CODE> is your ccl
directory. You can then start up the lisp by typing <CODE>ccl</CODE> or <CODE>ccl64</CODE>.</p>
<p>    You may wish to install <CODE>scripts/ccl64</CODE> with the name
<CODE>ccl</CODE> if you use the 64-bit lisp more. If you want the 32-bit
lisp to be available as well, you can install <CODE>scripts/ccl</CODE> as
<CODE>ccl32</CODE>.  Note that there is nothing magical about these
scripts. You should feel free to edit them as desired.</p>
<a id="the-init-file"></a>
<H4>The Init File</H4>
<div class="section">
<p>By default, Clozure CL will look for a file named <CODE>ccl-init.lisp</CODE> in your home directory, and load it upon startup.
      On Unix systems, it will also look for <CODE>.ccl-init.lisp</CODE>.</p>
<p>      If you wish, you can compile your init file, and Clozure CL will load
      the compiled version if it is newer than the corresponding
      source file.  In other words, Clozure CL loads your init file with
      <CODE>(load "home:ccl-init")</CODE>.</p>
<p>      Because the init file is loaded the same way as normal Lisp code
      is, you can put anything you want in it.  For example, you can
      change the working directory, and load code that you use
      frequently.</p>
<p>      To suppress the loading of this init-file, invoke Clozure CL with the
      <CODE>--no-init</CODE> (or <CODE>-n</CODE>) option.</p>
</div>
<a id="command-line-options"></a>
<H4>Command Line Options</H4>
<div class="section">
<p>When using Clozure CL from the command line, the following
      options may be used to modify its behavior.  The exact set of
      Clozure CL command-line arguments may vary per platform and
      may change over time.  The definitive list of command line
      options may be retrieved by using the
      <CODE>--help</CODE> option.</p>
<dl><dt><CODE>-h</CODE>, <CODE>--help</CODE></dt>
<dd><p>Provides a definitive (if
	      somewhat terse) summary of the command line options
	      accepted by the Clozure CL implementation and then
	      exits.</p>
</dd>
<dt><CODE>-V</CODE>, <CODE>--version</CODE></dt>
<dd><p>Prints the version of
	      Clozure CL then exits.  The version string is the same value
	      that is returned by <CODE>lisp-implementation-version</CODE>.</p>
</dd>
<dt><CODE>-K</CODE>, <CODE>--terminal-encoding</CODE>
                    <I>character-encoding-name</I></dt>
<dd><p>Specifies the character encoding to use for <CODE>*terminal-io*</CODE> (see <a href="#character-encodings">Character Encodings</a>).
	      Specifically, the <I>character-encoding-name</I> string
	      is uppercased and interned in the <CODE>keyword</CODE>
	      package. If an encoding named by that keyword exists,
	      <CODE>*terminal-character-encoding-name*</CODE> is set to
	      the name of that encoding.  The default is
	      <CODE>:utf-8</CODE>.</p>
</dd>
<dt><CODE>-n</CODE>, <CODE>--no-init</CODE></dt>
<dd><p>If this option is given, the
	      init file is not loaded.  This is useful if Clozure CL is being
	      invoked by a shell script that should not be affected by
	      whatever customizations a user might have in place.</p>
</dd>
<dt><CODE>-e</CODE>, <CODE>--eval</CODE> <I>form</I></dt>
<dd><p>An expression is read (via <CODE>read-from-string</CODE>)
	     from the string <I>form</I> and evaluated. If <I>form</I> contains shell metacharacters, it may be necessary
	     to escape or quote them to prevent the shell from
	     interpreting them.</p>
</dd>
<dt><CODE>-l</CODE>, <CODE>--load</CODE> <I>path</I></dt>
<dd><p>Loads file specified by <I>path</I>.</p>
</dd>
<dt><CODE>-T</CODE>, <CODE>--set-lisp-heap-gc-threshold</CODE> <I>n</I></dt>
<dd><p>Sets the Lisp gc threshold to <I>n</I>
            (see <a href="#gc-page-reclamation-policy">GC Page reclamation policy</a>).</p>
</dd>
<dt><CODE>-Q</CODE>, <CODE>--quiet</CODE></dt>
<dd><p>Suppresses printing of
	      heralds and prompts when the <CODE>--batch</CODE>
	      command line option is specified.</p>
</dd>
<dt><CODE>-R</CODE>, <CODE>--heap-reserve</CODE> <I>n</I></dt>
<dd><p>Reserves <I>n</I> bytes for heap expansion.  The default
             depends on the particular platform in use
             (see <a href="#heap-space-allocation">Heap space allocation</a>).</p>
</dd>
<dt><CODE>-S</CODE>, <CODE>--stack-size</CODE> <I>n</I></dt>
<dd><p>Sets the size of the initial control stack to <I>n</I> (see <a href="#thread-stack-sizes">Thread Stack Sizes</a>).</p>
</dd>
<dt><CODE>-Z</CODE>, <CODE>--thread-stack-size</CODE> <I>n</I></dt>
<dd><p>Sets
	      the size of the first thread's stack to <I>n</I> (see
	      <a href="#thread-stack-sizes">Thread Stack Sizes</a>).</p>
</dd>
<dt><CODE>-b</CODE>, <CODE>--batch</CODE></dt>
<dd><p>Execute in batch
	      mode. End-of-file from <CODE>*standard-input*</CODE>
	      causes Clozure CL to exit, as do attempts to enter a break
	      loop.</p>
</dd>
<dt><CODE>--no-sigtrap</CODE></dt>
<dd><p>An obscure option for running
      under GDB.</p>
</dd>
<dt><CODE>-I</CODE>, <CODE>--image-name</CODE> <I>image-name</I></dt>
<dd><p>Specifies the image name for the kernel to load.
	     Defaults to the kernel name with the suffix <CODE>.image</CODE> appended.</p>
</dd>
</dl>
<p>The <CODE>--load</CODE> and <CODE>--eval</CODE> options can each be provided
    multiple times.  They're executed in the order specified on the
    command line, after the init file (if there is one) is loaded and
    before the toplevel read-eval-print loop is entered.</p>
<p>    Finally, any arguments following the pseudo-argument <CODE>--</CODE> are
    not processed, and are made available to Lisp as the value of
    <a href="#v_unprocessed-command-line-arguments"><CODE>*unprocessed-command-line-arguments*</CODE></a>.</p>
</div>
<a id="running-clozure-cl-as-a-mac-application"></a>
<H4>Running Clozure CL as a Mac Application</H4>
<div class="section">
<p>If you want to run Clozure CL as a double-clickable Macintosh application, you can do that.
A version of Clozure CL is available from the Mac App Store if you would like to obtain it from
there.  Alternatively you can build the IDE yourself: please see <a href="#building-the-ide">Building the IDE</a>.
Currently, it's not possible to use the Mac App Store version of Clozure CL as a command-line
program.</p>
</div>
</div>
</div>
<a id="building-clozure-cl-from-its-source-code"></a>
<H2>Building Clozure CL from its Source Code</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#building-definitions">
Building Definitions</a>
<ul style="list-style: none">
</ul>
<li><a href="#reasons-for-building">
Reasons for Building</a>
<ul style="list-style: none">
</ul>
<li><a href="#kernel-build-prerequisites">
Kernel Build Prerequisites</a>
<ul style="list-style: none">
</ul>
<li><a href="#building-everything">
Building Everything</a>
<ul style="list-style: none">
</ul>
<li><a href="#building-the-kernel">
Building the Kernel</a>
<ul style="list-style: none">
</ul>
<li><a href="#building-the-heap-image">
Building the Heap Image</a>
<ul style="list-style: none">
<li><a href="#compile-lisp-source-code">
Compile Lisp Source Code</a>
<li><a href="#create-a-bootstrapping-image">
Create a Bootstrapping Image</a>
<li><a href="#building-a-full-image-from-a-bootstrapping-image">
Building a full image from a bootstrapping image</a>
</ul>
</ul>
<a id="building-definitions"></a>
<H3>Building Definitions</H3>
<div class="section">
<p>The following terms are used in subsequent sections; it
      may be helpful to refer to these definitions.</p>
<p>A <a href="#fasl_file">fasl file</a> is the file produced
      by <CODE>compile-file</CODE>.  These files store the
      machine code associated with function definitions and the
      external representation of other lisp objects in a compact,
      machine-readable form. Short for
      “<CODE>FAS</CODE>t <CODE>L</CODE>oading”. Clozure CL uses different pathname
      types (extensions) to name fasl files on different platforms; see <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a> for the details.</p>
<p>The <a href="#lisp_kernel">lisp kernel</a> is a C program with a fair amount of
      platform-specific assembly language code.  The lisp kernel
      provides runtime support for lisp code, such as garbage collection,
      memory allocation, exception handling, and so forth.
      When the lisp kernel starts, it maps the heap image into memory and
      transfers control to compiled lisp code that the image contains.</p>
<p>A <a href="#heap_image">heap image</a> is a file that can be quickly mapped into a
      process's address space. Conceptually, it's not too different
      from an executable file or shared library in the OS's native
      format (ELF or Mach-O/dyld format); for historical reasons,
      Clozure CL's own heap images are in their own (fairly simple)
      format. A full heap image contains all of the code and data that
      comprise Clozure CL. The default image file name
      is the name of the lisp kernel with a <CODE>.image</CODE> suffix.  See <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a>.</p>
<p>A bootstrapping image (see <a href="#create-a-bootstrapping-image">Create a Bootstrapping Image</a>)
      is a minimal
      heap image used in the process of building Clozure CL itself.  The
      bootstrapping image contains just enough code to load the rest
      of Clozure CL from fasl files.  The function <CODE>rebuild-ccl</CODE>
      automatically creates a bootstrepping image as part of its work.</p>
<p>Each supported platform (and possibly a few
      as-yet-unsupported ones) has a uniquely named subdirectory of
      <CODE>ccl/lisp-kernel/</CODE>; each such
      kernel build directory
      contains a Makefile and may contain some auxiliary files (linker
      scripts, etc.) that are used to build the lisp kernel on a
      particular platform. The platform-specific name of the kernel
      build directory is described in <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a>.</p>
<a id="tab_platform-specific-filename-conventions"></a>
<table>
<caption>Platform-specific filename conventions</caption>
<tr><td>Platform
<td>kernel
<td>fasl extension
<td>kernel build directory
</tr>
<tr><td>Linux (ppc)
<td>ppccl
<td>.pfsl
<td>linuxppc
</tr>
<tr><td>Linux (ppc64)
<td>ppccl64
<td>.p64fsl
<td>linuxppc64
</tr>
<tr><td>Linux (x8664)
<td>lx86cl64
<td>.lx64fsl
<td>linuxx8664
</tr>
<tr><td>Linux (x8632)
<td>lx86cl
<td>.lx32fsl
<td>linuxx8632
</tr>
<tr><td>Linux (arm32)
<td>armcl
<td>.lafsl
<td>linuxarm
</tr>
<tr><td>OS X (x8664)
<td>dx86cl64
<td>.dx64fsl
<td>darwinx8664
</tr>
<tr><td>OS X (x8632)
<td>dx86cl
<td>.dx32fsl
<td>darwinx8632
</tr>
<tr><td>FreeBSD (x8664)
<td>fx86cl64
<td>.fx64fsl
<td>freebsdx8664
</tr>
<tr><td>FreeBSD (x8632)
<td>fx86cl
<td>.fx32fsl
<td>freebsdx8632
</tr>
<tr><td>Solaris (x8664)
<td>sx86cl64
<td>.sx64fsl
<td>solarisx64
</tr>
<tr><td>Solaris (x8632)
<td>sx86cl
<td>.sx32fsl
<td>solarisx86
</tr>
<tr><td>Windows (x8664)
<td>wx86cl64.exe
<td>.wx64fsl
<td>win64
</tr>
<tr><td>Windows (x8632)
<td>wx86cl.exe
<td>.wx32fsl
<td>win32
</tr>
</table>
</div>
<a id="reasons-for-building"></a>
<H3>Reasons for Building</H3>
<div class="section">
<p>At a given time, there are generally two versions of Clozure CL that
    you might want to use (and therefore might want to build from
    source).</p>
<p>    The first of these is the current release branch.  Fixes for
    serious bugs are sometimes checked into the release branch, and
    you might want to update from Subversion and rebuild in order to
    pick up these fixes.</p>
<p>    You may also be interested in building the development version of Clozure CL, which is
    often called the trunk.  The trunk may contain both interesting new features and
    interesting new bugs.  See <a href="http://trac.clozure.com/ccl/wiki">http://trac.clozure.com/ccl/wiki</a>
 for information
    about how to check out a copy of the trunk.</p>
</div>
<a id="kernel-build-prerequisites"></a>
<H3>Kernel Build Prerequisites</H3>
<div class="section">
<p>In order to build the lisp kernel, you must have installed a C compiler and its
associated tools (such as <CODE>as</CODE> and <CODE>ld</CODE>).  Additionally, the lisp kernel
build process uses <CODE>m4</CODE>;  this program is often not installed by default, so
make sure you have it.  The lisp kernel makefiles generally assume that you are using
GNU make.</p>
<p>    On a recent Mac OS X system, typing <CODE>xcode-select --install</CODE> should download
and install everything needed to build Clozure CL.</p>
</div>
<a id="building-everything"></a>
<H3>Building Everything</H3>
<div class="section">
<p>With all the pre-requisites in place, building Clozure CL is very simple.</p>
<pre class="source-code">$ ccl -n
? (ccl:rebuild-ccl :full t)
</pre>
<p>This peforms the following steps:</p>
<ul><li><p>Deletes all fasl files and other object files in the
	      <CODE>ccl</CODE> directory tree</p>
<li><p>Does <CODE>(compile-ccl t)</CODE> in the running lisp, to
	      generate fasl files from the lisp sources.</p>
<li><p>Does <CODE>(xload-level-0 :force)</CODE> in the
	      running lisp.  This compiles the lisp files in the
	      <CODE>ccl:level-0;</CODE> directory and then creates a special
               bootstrapping image from the compiled fasl files.</p>
<li><p>Runs an external process that runs
	      <CODE>make</CODE> in the current platform's kernel
	      build directory to create a new kernel.  
             This step can only work if the C compiler and related
             tools are installed; see <a href="#kernel-build-prerequisites">Kernel Build Prerequisites</a>.</p>
<li><p>Runs another external process, which causes the newly
	      compiled lisp kernel to load the new bootstrapping image.
	      The bootstrapping image then loads the rest of
	      the fasl files and a new copy of the platform's
	      full heap image is then saved.</p>
</ul>
<p>When all goes well, this all happen without user intervention and
      with some simple progress messages.  If anything goes wrong
      during execution of either of the external processes, the
      process output is displayed as part of a lisp error message.</p>
<p>      <CODE>rebuild-ccl</CODE> is essentially just a short cut for running
      all the individual steps involved in rebuilding the system.  You
      can also execute these steps individually, as described below.</p>
</div>
<a id="building-the-kernel"></a>
<H3>Building the Kernel</H3>
<div class="section">
<p>Rebuilding the lisp kernel is straightfoward. Consult the table <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a> to determine
     the name of the lisp kernel build directory you want.  Then, change to
     that directory and say <CODE>make</CODE>.  Suppose you wanted to build the
     lisp kernel for 64-bit FreeBSD/x86.  We find that the name of the lisp
     kernel build directory is <CODE>freebsdx8664</CODE>, so we do the following: </p>
<pre class="source-code">$ cd ccl/lisp-kernel/freebsdx8664
$ make clean
$ make
</pre>
<p>The most common reason that the build fails is because m4 is not installed.  If you
see <CODE>m4: command not found</CODE>, then you should install m4.</p>
<p>On Mac OS X, make sure that you have installed the command-line developer tools
with <CODE>xcode-select --install</CODE>.  If you get an error message saying that
the file <CODE>sys/signal.h</CODE> cannot be found, this is a sign that you need to do this.
You need to do this even if you have Xcode already installed.</p>
</div>
<a id="building-the-heap-image"></a>
<H3>Building the Heap Image</H3>
<div class="section">
<p>Typically, <CODE>rebuild-ccl</CODE> is used to rebuild all of Clozure CL.
    In special cases, you might want to exercise more control over how
    the heap image is built.  These cases typically arise only when
    developing Clozure CL itself.</p>
<p>   Creating a new Clozure CL heap image consists of the following steps:</p>
<ol><li><p>Using an existing lisp, recompile the updated lisp source code</p>
<li><p>Using an existing lisp, create a new bootstrapping image</p>
<li><p>Start up the lisp kernel and tell it to load the bootstrapping image
            you just created</p>
</ol>
<a id="compile-lisp-source-code"></a>
<H4>Compile Lisp Source Code</H4>
<div class="section">
<p> Calling:</p>
<pre class="source-code">? (ccl:compile-ccl)
</pre>
<p>at the lisp prompt compiles any fasl files that are
        out-of-date with respect to the corresponding lisp sources;
        <CODE>(ccl:compile-ccl t)</CODE> forces recompilation. <CODE>ccl:compile-ccl</CODE> reloads newly-compiled versions of some
        files; <CODE>ccl:xcompile-ccl</CODE> is analogous, but skips this
        reloading step.</p>
<p>        Unless there are bootstrapping considerations involved, it
        usually doesn't matter whether these files are reloaded after
        they're recompiled.</p>
<p>        Calling <CODE>compile-ccl</CODE> or
        <CODE>xcompile-ccl</CODE> in an environment where fasl
        files don't yet exist may produce warnings to that effect
        whenever files are <CODE>require</CODE>d during
        compilation; those warnings can be safely ignored. Depending
        on the maturity of the Clozure CL release, calling
        <CODE>compile-ccl</CODE> or
        <CODE>xcompile-ccl</CODE> may also produce several
        warnings about undefined functions, etc. They should be
        cleaned up at some point.</p>
</div>
<a id="create-a-bootstrapping-image"></a>
<H4>Create a Bootstrapping Image</H4>
<div class="section">
<p>The bootstrapping image isn't provided in Clozure CL
       distributions. It can be built from the source code provided
       in distributions (using a lisp image and kernel provided in
       those distributions) using the procedure described
       below.</p>
<p>        The bootstrapping image is built by invoking a special utility
        inside a running Clozure CL heap image to load files contained in
        the <CODE>ccl/level-0</CODE> directory. The bootstrapping image
        loads several dozen fasl files.  After it's done so, it saves
        a heap image via <CODE>save-application</CODE>. This process is
        called cross-dumping.</p>
<p>        Given a source distribution, a lisp kernel, and a heap image,
        one can produce a bootstrapping image by first invoking Clozure CL
        from the shell:</p>
<pre class="source-code">$ ccl
? (ccl:xload-level-0)
</pre>
<p>This function compiles the lisp sources in the <CODE>ccl/level-0</CODE> directory as needed, and then loads the resulting
        fasl files into a simulated lisp heap contained in data
        structures inside the running lisp. It then writes this
        data to disk as a bootstrapping image and displays the
        pathname of the newly-written image on the terminal.</p>
<p>        <CODE>xload-level-0</CODE> should be called whenever your existing
        boot image is out-of-date with respect to the source files in
        <CODE>ccl:level-0;</CODE>.</p>
</div>
<a id="building-a-full-image-from-a-bootstrapping-image"></a>
<H4>Building a full image from a bootstrapping image</H4>
<div class="section">
<p>To build a full image from a bootstrapping image, just invoke
       the kernel and tell it to load the bootstrapping image (as
       reported by <CODE>xload-level-0</CODE>.  For example, suppose you
       are using 64-bit Mac OS X:</p>
<pre class="source-code">$ cd ccl    # wherever your ccl directory is
$ ./dx86cl64 --image-name x86-boot64.image --no-init
</pre>
<p>Other platoforms use analogous steps: use the appropriate
       platform-specific name for the lisp kernel, and use the name of
       boot image as reported by <CODE>xload-level-0</CODE>.</p>
<p>      This process will load a few dozen fasl files, printing a
      message as each file is loaded. If all of these files
      successfully load, the lisp will print a prompt. You should be
      able to do essentially everything in that environment that you
      can in the environment provided by a full heap image. If
      everything went well, you can save that image using <a href="#f_save-application"><CODE>save-application</CODE></a>:</p>
<pre class="source-code">? (ccl:save-application "new.image")
</pre>
<p>The name <I>new.image</I> can be whatever you want.  You may
      wish to use the default image name for your platform;  see <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a>.</p>
<p>If things go wrong in the early stages of the loading
        sequence, errors are often difficult to debug; until a fair
        amount of code (CLOS, the CL condition system, streams, the
        reader, the read-eval-print loop) is loaded, it's generally
        not possible for the lisp to report an error.  Errors that
        occur during these early stages (“the cold load”) sometimes
        cause the lisp kernel debugger to be invoked; it's
        primitive, but can sometimes help one to get oriented.</p>
</div>
</div>
</div>
<a id="using-clozure-cl"></a>
<H2>Using Clozure CL</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#introduction_in_using-clozure-cl">
Introduction</a>
<ul style="list-style: none">
</ul>
<li><a href="#memory-mapped-files">
Memory-mapped Files</a>
<ul style="list-style: none">
</ul>
<li><a href="#static-variables">
Static Variables</a>
<ul style="list-style: none">
</ul>
<li><a href="#saving-applications">
Saving Applications</a>
<ul style="list-style: none">
</ul>
<li><a href="#concatenating-fasl-files">
Concatenating FASL Files</a>
<ul style="list-style: none">
</ul>
<li><a href="#floating-point-numbers">
Floating Point Numbers</a>
<ul style="list-style: none">
</ul>
<li><a href="#code-coverage">
Code Coverage</a>
<ul style="list-style: none">
<li><a href="#overview_in_code-coverage">
Overview</a>
<li><a href="#limitations">
Limitations</a>
<li><a href="#usage">
Usage</a>
<li><a href="#functions-and-variables">
Functions and Variables</a>
<li><a href="#interpreting-code-coloring">
Interpreting Code Coloring</a>
</ul>
<li><a href="#other-extensions">
Other Extensions</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="introduction_in_using-clozure-cl"></a>
<H3>Introduction</H3>
<div class="section">
<p>The Common Lisp standard allows considerable latitude in the
      details of an implementation, and each particular Common Lisp
      system has some idiosyncrasies. This chapter describes ordinary
      user-level features of Clozure CL, including features that may be
      part of the Common Lisp standard, but which may have quirks or
      details in the Clozure CL implementation that are not described by
      the standard. It also describes extensions to the standard; that
      is, features of Clozure CL that are not part of the Common Lisp
      standard at all.</p>
</div>
<a id="memory-mapped-files"></a>
<H3>Memory-mapped Files</H3>
<div class="section">
<p>In release 1.2 and later, Clozure CL
      supports <a href="#memory-mapped_file">memory-mapped files</a>. On operating systems that support memory-mapped
      files (including Mac OS X, Linux, and FreeBSD), the operating
      system can arrange for a range of virtual memory addresses to
      refer to the contents of an open file. As long as the file remains
      open, programs can read values from the file by reading addresses
      in the mapped range.</p>
<p>Using memory-mapped files may in some cases be more
      efficient than reading the contents of a file into a data
      structure in memory.</p>
<p>      Clozure CL provides the
      functions <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>
      and <a href="#f_map-file-to-octet-vector"><CODE>map-file-to-octet-vector</CODE></a> to support
      memory-mapping. These functions return vectors whose contents are
      the contents of memory-mapped files. Reading an element of such a
      vector returns data from the corresponding position in the
      file.</p>
<p>      Without memory-mapped files, a common idiom for reading the
      contents of files might be something like this:</p>
<pre class="source-code">(let* ((stream (open pathname :direction :input :element-type '(unsigned-byte 8)))
       (vector (make-array (file-size-to-vector-size stream)
                           :element-type '(unsigned-byte 8))))
  (read-sequence vector stream))
    
</pre>
<p>Using a memory-mapped files has a result that is the same in
      that, like the above example, it returns a vector whose contents are
      the same as the contents of the file. It differs in that the above
      example creates a new vector in memory and copies the file's
      contents into it; using a memory-mapped file instead arranges for
      the vector's elements to point to the file's contents on disk
      directly, without copying them into memory first.</p>
<p>      The vectors returned by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>
      and <a href="#f_map-file-to-octet-vector"><CODE>map-file-to-octet-vector</CODE></a> are read-only; any
      attempt to change an element of a vector returned by these
      functions results in a memory-access error. Clozure CL does not
      currently support writing data to memory-mapped files.</p>
<p>      Vectors created by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>
      and <a href="#f_map-file-to-octet-vector"><CODE>map-file-to-octet-vector</CODE></a> are required to
      respect Clozure CL's limit on the total size of an array. That means
      that you cannot use these functions to create a vector longer
      than <CODE>array-total-size-limit</CODE>, even if the filesystem
      supports file sizes that are larger. The value
      of <CODE>array-total-size-limit</CODE> is <CODE>(expt 2 24)</CODE>
      on 32-but platforms; and <CODE>(expt 2 56)</CODE> on 64-bit
      platforms.</p>
<a id="f_map-file-to-ivector"></a>
<div class=definition>
<code>map-file-to-ivector</code> <i>pathname</i> <i>element-type</i> <span class="definition-kind">[Function]</span><p>
      The <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a> function tries to
      open the file at <I>pathname</I> for reading. If
      successful, the function maps the file's contents to a range of
      virtual addresses. If successful, it returns a read-only vector
      whose element-type is given
      by <I>element-type</I>, and whose contents are
      the contents of the memory-mapped file.
    </p>
<a id="description_in_f_map-file-to-ivector"></a>
<dl><dt><I>pathname</I></dt>
<dd><p>The pathname of the file to be memory-mapped.</p>
</dd>
<dt><I>element-type</I></dt>
<dd><p>The element-type of the vector to be
            created. Specified as
            a <a href="#type-specifier">type-specifier</a>
            that names a subtype of either <CODE>signed-byte</CODE>
            or <CODE>unsigned-byte</CODE>.</p>
</dd>
</dl>
<p>The returned vector is
      a <a href="#displaced_array">displaced-array</a>
      whose element-type is <CODE>(UPGRADED-ARRAY-ELEMENT-TYPE
        element-type)</CODE>. The target of the displaced array is a
      vector of type <CODE>(SIMPLE-ARRAY element-type (*))</CODE> whose
      elements are the contents of the memory-mapped file.</p>
<p>Because of alignment issues, the mapped file's contents
      start a few bytes (4 bytes on 32-bit platforms, 8 bytes on
      64-bit platforms) into the vector. The displaced array returned
      by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a> hides this overhead, but
      it's usually more efficient to operate on the underlying simple
      1-dimensional array.  Given a displaced array (like the value
      returned by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>), the function
      <CODE>array-displacement</CODE> returns the underlying array and
      the displacement index in elements.</p>
<p>      Currently, Clozure CL supports only read operations on
      memory-mapped files. If you try to change the contents of an array
      returned by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>, Clozure CL signals
      a memory error.</p>
</div>
<a id="f_unmap-ivector"></a>
<div class=definition>
<code>unmap-ivector</code> <i>displaced-array</i> <span class="definition-kind">[Function]</span><a id="description_in_f_unmap-ivector"></a>
<p>If the argument is a displaced-array returned
      by <a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>, and if it has not yet
      been unmapped by this function,
      then <a href="#f_unmap-ivector"><CODE>unmap-ivector</CODE></a> undoes the memory mapping,
      closes the mapped file, and changes the displaced-array so that its
      target is an empty vector (of length zero).</p>
</div>
<a id="f_map-file-to-octet-vector"></a>
<div class=definition>
<code>map-file-to-octet-vector</code> <i>displaced-array</i> <span class="definition-kind">[Function]</span><a id="description_in_f_map-file-to-octet-vector"></a>
<p>This function is a synonym for <CODE>(map-file-to-ivector
        pathname '(unsigned-byte 8))</CODE> It is provided as a convenience
      for the common case of memory-mapping a file as a vector of
      bytes.</p>
</div>
<a id="f_unmap-octet-vector"></a>
<div class=definition>
<code>unmap-octet-vector</code> <i>displaced-array</i> <span class="definition-kind">[Function]</span><a id="description_in_f_unmap-octet-vector"></a>
<p>This function is a synonym for <a href="#f_unmap-ivector"><CODE>unmap-ivector</CODE></a></p>
</div>
</div>
<a id="static-variables"></a>
<H3>Static Variables</H3>
<div class="section">
<p>Clozure CL supports the definition
      of <a href="#static_variable">static variables</a>, whose values are the same across threads,
      and which may not be dynamically bound. The value of a static
      variable is thus the same across all threads; changing the value
      in one thread changes it for all threads.</p>
<p>Attempting to dynamically rebind a static variable (for
      instance, by using <CODE>LET</CODE>, or using the variable name as
      a parameter in a <CODE>LAMBDA</CODE> form) signals an
      error. Static variables are shared global resources; a dynamic
      binding is private to a single thread.</p>
<p>      Static variables therefore provide a simple way to share
      mutable state across threads. They also provide a simple way to
      introduce race conditions and obscure bugs into your code, since
      every thread reads and writes the same instance of a given static
      variable. You must take care, therefore, in how you change the
      values of static variables, and use normal multithreaded
      programming techniques, such as locks or semaphores, to protect
      against race conditions.</p>
<p>      In Clozure CL, access to a static variable is usually faster than
      access to a special variable that has not been declared
      static.</p>
<a id="m_defstatic"></a>
<div class=definition>
<code>defstatic</code> <i>var</i> <i>value</i> <code>&amp;key</code> <i>docstring</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_defstatic"></a>
<p>Proclaims the
      variable <a href="#special_variable">special</a>,
      assigns the variable the supplied <I>value</I>, and assigns
      the <I>docstring</I> to the
      variable's <CODE>variable</CODE> documentation. Marks the
      variable static, preventing any attempt to dynamically rebind
      it. Any attempt to dynamically rebind <I>var</I>
      signals an error.</p>
</div>
</div>
<a id="saving-applications"></a>
<H3>Saving Applications</H3>
<div class="section">
<p>Clozure CL provides the
      function <a href="#f_save-application"><CODE>save-application</CODE></a>, which creates a file
      containing an archived Lisp memory image.</p>
<p>Clozure CL consists of a small executable called the
      <a href="#lisp_kernel">lisp kernel</a>, which
      implements the very lowest level features of the Lisp system, and
      a <a href="#heap_image">heap image</a>, which
      contains the in-memory representation of most of the Lisp system,
      including functions, data structures, variables, and so on. When
      you start Clozure CL, you are launching the kernel, which then locates
      and reads an image file, restoring the archived image in
      memory. Once the image is fully restored, the Lisp system is
      running.</p>
<p>Using <a href="#f_save-application"><CODE>save-application</CODE></a>, you can create a
      file that contains a modified image, one that includes any changes
      you've made to the running Lisp system. If you later pass your
      image file to the Clozure CL kernel as a command-line parameter, it
      then loads your image file instead of its default one, and Clozure CL
      starts up with your modifications.</p>
<p>      If this scenario seems to you like a convenient way to
      create an application, that's just as intended. You can create an
      application by modifying the running Lisp until it does what you
      want, then use <a href="#f_save-application"><CODE>save-application</CODE></a> to preserve your
      changes and later load them for use.</p>
<p>In fact, you can go further than that. You can replace
      Clozure CL's <a href="#toplevel_function">toplevel function</a> with your own, and then, when the image is
      loaded, the Lisp system immediately performs your tasks rather
      than the default tasks that make it a Lisp development system. If
      you save an image in which you have done this, the resulting Lisp
      system is your tool rather than a Lisp development system.</p>
<p>You can go a step further still. You can
      tell <a href="#f_save-application"><CODE>save-application</CODE></a> to prepend the Lisp kernel
      to the image file. Doing this makes the resulting image into a
      self-contained executable binary. When you run the resulting file,
      the Lisp kernel immediately loads the attached image file and runs
      your saved system. The Lisp system that starts up can have any
      behavior you choose. It can be a Lisp development system, but with
      your customizations; or it can immediately perform some task of
      your design, making it a specialized tool rather than a general
      development system.</p>
<p>      In other words, you can develop any application you like by
      interactively modifying Clozure CL until it does what you want, then
      using <a href="#f_save-application"><CODE>save-application</CODE></a> to preserve your changes
      in an executable image.</p>
<p>On Mac OS X,
      the <a href="#the-application-builder">application builder</a>
      uses <a href="#f_save-application"><CODE>save-application</CODE></a> to create the executable
      portion of the <a href="#application_bundle">application bundle</a>. Double-clicking the application bundle runs
      the executable image created
      by <a href="#f_save-application"><CODE>save-application</CODE></a>.</p>
<p>Also on Mac OS X, Clozure CL supports an object type
      called <CODE>macptr</CODE>, which is the type of pointers into the
      foreign (Mac OS) heap. Examples of
      commonly-user <CODE>macptr</CODE> objects are Cocoa windows and
      other dynamically-allocated Mac OS system objects.</p>
<p>      Because a <CODE>macptr</CODE> object is a pointer into a
      foreign heap that exists for the lifetime of the running Lisp
      process, and because a saved image is used by loading it into a
      brand new Lisp process, saved <CODE>macptr</CODE> objects cannot
      be relied on to point to the same things when reconstituted from a
      saved image. In fact, a restored <CODE>macptr</CODE> object might
      point to anything at all-for example an arbitrary location
      in the middle of a block of code, or a completely nonexistent
      virtual address.</p>
<p>      For that reason, <CODE>save-application</CODE> converts
      all <CODE>macptr</CODE> objects to <CODE>dead-macptr</CODE>
      objects when writing them to an image
      file. A <CODE>dead-macptr</CODE> is functionally identical to
      a <CODE>macptr</CODE>, except that code that operates
      on <CODE>macptr</CODE> objects distinguishes them
      from <CODE>dead-macptr</CODE> objects and can handle them
      appropriately-signaling errors, for example.</p>
<p>      Tthere is one exception to the conversion
      of <CODE>macptr</CODE> to <CODE>dead-macptr</CODE> objects:
      a <CODE>macptr</CODE> object that points to the address 0 is not
      converted, because address 0 can always be relied upon to refer to
      the same thing.</p>
<p>The constant <CODE>+null-ptr+</CODE>
      refers to a <CODE>macptr</CODE> object that points to address 0.</p>
<p>      On all supported platforms, you can
      use <a href="#f_save-application"><CODE>save-application</CODE></a> to create a command-line
      tool that runs very like any other command-line program
      does. Alternatively, if you choose not to prepend the kernel, you
      can save an image and then later run it by passing it as a
      command-line parameter to the <CODE>ccl</CODE>
      or <CODE>ccl64</CODE> script.</p>
<a id="f_save-application"></a>
<div class=definition>
<code>save-application</code> <i>filename</i> <code>&amp;key</code> <i>toplevel-function</i> <i>init-file</i> <i>error-handler</i> <i>application-class</i> <i>clear-clos-caches</i>  (<i>purify</i> <i>t</i>) <i>impurify</i>  (<i>mode</i> <i>#o644</i>) <i>prepend-kernel</i> <i>native</i> <span class="definition-kind">[Function]</span><p>Saves a heap image.</p>
<a id="description_in_f_save-application"></a>
<dl><dt><I>filename</I></dt>
<dd><p>The pathname of the file to be created when Clozure CL
            saves the application.</p>
</dd>
<dt><I>toplevel-function</I></dt>
<dd><p>The function to be executed after startup is
            complete. The toplevel is a function of no arguments that
            performs whatever actions the lisp system should perform
            when launched with this image.</p>
<p>If this parameter is not supplied, Clozure CL uses its
            default toplevel. The default toplevel runs
            the <a href="#repl">read-eval-print loop</a>.</p>
</dd>
<dt><I>init-file</I></dt>
<dd><p>The pathname of a Lisp file to be loaded when the
            image starts up. You can place initialization expressions in
            this file, and use it to customize the behavior of the Lisp
            system when it starts up.</p>
</dd>
<dt><I>error-handler</I></dt>
<dd><p>The error-handling mode for the saved image. The
            supplied value determines what happens when an error is not
            handled by the saved image. Valid values
            are <CODE>:quit</CODE> (Lisp exits with an error
            message); <CODE>:quit-quietly</CODE> (Lisp exits without an
            error message); or <CODE>:listener</CODE> (Lisp enters a
            break loop, enabling you to debug the problem by interacting
            in a listener). If you don't supply this parameter, the
            saved image uses the default error handler
            (<CODE>:listener</CODE>).</p>
</dd>
<dt><I>application-class</I></dt>
<dd><p>The CLOS class that represents the saved Lisp
            application. Normally you don't need to supply this
            parameter; <a href="#f_save-application"><CODE>save-application</CODE></a> uses the
            class <CODE>ccl:lisp-development-system</CODE>. In some
            cases you may choose to create a custom application class;
            in that case, pass the name of the class as the value for
            this parameter.</p>
</dd>
<dt><I>clear-clos-caches</I></dt>
<dd><p>If true, ensures that CLOS caches are emptied before
            saving the image. Normally you don't need to supply this
            parameter, but if for some reason you want to ensure the
            CLOS caches are clear when the image starts up, you can pass
            any true value.</p>
</dd>
<dt><I>purify</I></dt>
<dd><p>
	    When true, calls (in effect) <CODE>purify</CODE> before
	    saving the heap image.  This moves certain objects that
	    are unlikely to become garbage to a special memory area
	    that is not scanned by the GC (since it is expected that
	    the GC wouldn't find anything to collect).
         </p>
</dd>
<dt><I>impurify</I></dt>
<dd><p>
	    If true, calls (in effect) <CODE>impurify</CODE> before
	    saving the heap image.  (If both <CODE>:impurify</CODE>
	    and <CODE>:purify</CODE> are true, first
	    <CODE>impurify</CODE> is done, and then <CODE>purify</CODE>.)</p>
<p>	   <CODE>impurify</CODE> moves objects in certain special memory
	   areas into the regular dynamic heap, where they will be scanned
	   by the GC.
	 </p>
</dd>
<dt><I>mode</I></dt>
<dd><p>
	    A number specifying the mode (permission bits) of the output file.
	  </p>
</dd>
<dt><I>prepend-kernel</I></dt>
<dd><p>Specifies the file to prepend to the saved heap
	  image.  A value of <CODE>t</CODE> means to prepend
	  the lisp kernel binary that the lisp started with.
	  Otherwise, the value of <CODE>:prepend-kernel</CODE>
	  should be a pathname designator for the file to be
	  prepended.</p>
<p>	   If the prepended file is execuatable, its execute
	   mode bits will be copied to the output file.</p>
<p>	   This argument can be used to prepend any kind of file to
	   the saved heap image.  This can be useful in some special
	   cases.
	 </p>
</dd>
<dt><I>native</I></dt>
<dd><p>If true, saves the image as a native (ELF, Mach-O, PE)
          shared library.  (On platforms where this isn't yet supported,
          a warning is issued and the option is ignored.)
         </p>
</dd>
</dl>
</div>
<a id="v_save-exit-functions"></a>
<div class=definition>
<code>*save-exit-functions*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_save-exit-functions"></a>
<p>This variable contains a list of 0-argument functions that will
be called before saving a heap image.  Users may add functions to this list
as needed.</p>
</div>
<a id="v_restore-lisp-functions"></a>
<div class=definition>
<code>*restore-lisp-functions*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_restore-lisp-functions"></a>
<p>This variable contains a list of 0-argument functions
that will be called after restoring a saved heap image.  Users may add
functions to this list as needed.</p>
</div>
<a id="v_lisp-cleanup-functions"></a>
<div class=definition>
<code>*lisp-cleanup-functions*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_lisp-cleanup-functions"></a>
<p>This variable contains a list of 0-argument functions that will be
called before quitting the lisp.</p>
<p>Note that <a href="#f_save-application"><CODE>save-application</CODE></a> quits the lisp, so any functions
on this list will be invoked before saving a heap image.</p>
</div>
<a id="v_lisp-startup-functions"></a>
<div class=definition>
<code>*lisp-startup-functions*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_lisp-startup-functions"></a>
<p>This variable contains a list of 0-argument functions that will be
called after starting the lisp.</p>
</div>
</div>
<a id="concatenating-fasl-files"></a>
<H3>Concatenating FASL Files</H3>
<div class="section">
<p>Multiple fasl files can be concatenated into a single file.
           The single file might be easier to distribute or install, and
           loading it may be slightly faster than loading the individual
           files (since it avoids the overhead of opening and closing each
           file in succession).</p>
<a id="f_fasl-concatenate"></a>
<div class=definition>
<code>fasl-concatenate</code> <i>output-file</i> <i>fasl-files</i> <code>&amp;key</code>  (<i>:if-exists</i> <i>:error</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_fasl-concatenate"></a>
<p>This function reads the fasl files specified by the list <I>fasl-files</I> and combines them into a single fasl file named
       <I>output-file</I>.  The <CODE>:if-exists</CODE> keyword argument is
       interpreted as in the standard function <CODE>open</CODE>.</p>
<p>       Loading the concatenated fasl file has the same effect as
       loading the invidual input fasl files in the specified order.</p>
<p>The <CODE>pathname-type</CODE> of the output file and of each input
        file defaults to the current platform's fasl file type (see <a href="#tab_platform-specific-filename-conventions">Platform-specific filename conventions</a>).
       If any of the input files has a different type an error will
       be signaled, but <a href="#f_fasl-concatenate"><CODE>fasl-concatenate</CODE></a> doesn't otherwise
       try too hard to verify that the input files are real fasl files
       for the current platform.</p>
</div>
</div>
<a id="floating-point-numbers"></a>
<H3>Floating Point Numbers</H3>
<div class="section">
<p>In Clozure CL, the Common Lisp types short-float and single-float are
      implemented as IEEE single precision values; double-float and
      long-float are IEEE double precision values.  On 64-bit
      platforms, single-floats are immediate values (like fixnums and
      characters).</p>
<p>    Floating-point exceptions are generally enabled and detected.  By
    default, threads start up with overflow, division-by-zero, and
    invalid enabled, and the rounding mode is set to nearest. The
    functions <a href="#f_set-fpu-mode"><CODE>set-fpu-mode</CODE></a> and
    <a href="#f_get-fpu-mode"><CODE>get-fpu-mode</CODE></a> provide user control over
    floating-point behavior.</p>
<a id="f_get-fpu-mode"></a>
<div class=definition>
<code>get-fpu-mode</code> <code>&amp;optional</code> <i>mode</i> <span class="definition-kind">[Function]</span><p>Return the state of exception-enable and rounding-mode control
       flags for the current thread.</p>
<a id="description_in_f_get-fpu-mode"></a>
<p>When called without the optional <I>mode</I> argument, this
       function returns a plist of keyword/value pairs which describe
       the floating point exception-enable and rounding-mode flags for
       the current thread.</p>
<p>      If <I>mode</I> is supplied, it should be one of the keywords
      <CODE>:rounding-mode</CODE>, <CODE>:overflow</CODE>, <CODE>:underflow</CODE>,
      <CODE>:division-by-zero</CODE>, <CODE>:invalid</CODE>, or <CODE>:inexact</CODE>.
      The value of corresponding control flag is returned.</p>
<dl><dt>rounding-mode</dt>
<dd><p>One of <CODE>:nearest</CODE>, <CODE>:zero</CODE>,
<CODE>:positive</CODE>, or <CODE>:negative</CODE></p>
</dd>
<dt>overflow, underflow, division-by-zero, invalid, inexact</dt>
<dd><p>
	      If <CODE>t</CODE>, the floating-point exception is signaled.
	      If <CODE>nil</CODE>, it is masked.
	    </p>
</dd>
</dl>
</div>
<a id="f_set-fpu-mode"></a>
<div class=definition>
<code>set-fpu-mode</code> <code>&amp;key</code> <i>rounding-mode</i> <i>overflow</i> <i>underflow</i> <i>division-by-zero</i> <i>invalid</i> <i>inexact</i> <span class="definition-kind">[Function]</span><p>Set the state of exception-enable and rounding-mode control
	flags for the current thread.</p>
<a id="arguments-and-values_in_f_set-fpu-mode"></a>
<dl><dt><I>rounding-mode</I></dt>
<dd><p>
	      If supplied, must be one of :nearest, :zero, :positive, or
	      :negative.
	    </p>
</dd>
<dt><I>overflow</I>, <I>underflow</I>, <I>division-by-zero</I>, <I>invalid</I>, <I>inexact</I></dt>
<dd><p>NIL to mask the exception, T to signal it.</p>
</dd>
</dl>
<a id="description_in_f_set-fpu-mode"></a>
<p>
	Sets the current thread's exception-enable and rounding-mode
	control flags to the indicated values for arguments that are
	supplied, and preserves the values assoicated with those
	that aren't supplied.
      </p>
</div>
</div>
<a id="code-coverage"></a>
<H3>Code Coverage</H3>
<div class="section">
<a id="overview_in_code-coverage"></a>
<H4>Overview</H4>
<div class="section">
<p>
  In Clozure CL 1.4 and later, code coverage provides information
  about which paths through generated code have been executed and
  which haven't. For each source form, it can report one of three
  possible outcomes:
</p>
<ul><li><p>
      Not covered: this form was never entered.
    </p>
<li><p>
      Partly covered: This form was entered, and some parts were
      executed and some weren't.
    </p>
<li><p>
      Fully covered: Every bit of code generated from this form was
      executed.
    </p>
</ul>
</div>
<a id="limitations"></a>
<H4>Limitations</H4>
<div class="section">
<p>
  While the information gathered for coverage of generated code is
  complete and precise, the mapping back to source forms is of
  necessity heuristic, and depends a great deal on the behavior of
  macros and the path of the source forms through compiler
  transforms. Source information is not recorded for variables, which
  further limits the source mapping. In practice, there is often
  enough information scattered about a partially covered function to
  figure out which logical path through the code was taken and which
  wasn't. If that doesn't work, you can try disassembling to see which
  parts of the compiled code were not executed: in the disassembled
  code there will be references to #&lt;CODE-NOTE [xxx] ...&gt; where xxx
  is NIL if the code that follows was never executed and non-NIL if it
  was.</p>
<p>  Sometimes the situation can be improved by modifying macros to try
  to preserve more of the input forms, rather than destructuring and
  rebuilding them.
</p>
<p>
  Because the code coverage information is associated with compiled
  functions, code coverage information is not available for load-time toplevel
  expressions.  You can work around this by creating a function and calling
  it. I.e. instead of
  <pre class="source-code">(progn
  (do-this)
  (setq that ...) ...))
</pre>
do: <pre class="source-code">(defun init-this-and-that ()
  (do-this)
  (setq that ...)  ...)
(init-this-and-that)
</pre>
<p></p>
<p>Then you can see the coverage information in the definition of
<CODE>init-this-and-that</CODE>.
</p>
</p>
</div>
<a id="usage"></a>
<H4>Usage</H4>
<div class="section">
<p>In order to gather code coverage information, you first have to
  recompile all your code to include code coverage
  instrumentation. Compiling files will generate code coverage
  instrumentation if <CODE>ccl:*compile-code-coverage*</CODE>
  is true:  <pre class="source-code">
(setq ccl:*compile-code-coverage* t) 
(recompile-all-your-files)
</pre>
</p>
<p>The compilation process will be many times slower than normal, and
  the fasl files will be many times bigger.</p>
<p>  When you execute functions loaded from instrumented fasl files, they
  will record coverage information every time they are executed. 
  You can examine that information by calling <CODE>ccl:report-coverage</CODE>
  or <CODE>ccl:coverage-statistics</CODE>.</p>
<p>While recording coverage, you can collect incremental
   coverage deltas between any two points in time.  You might do this
   while running a test suite, to record the coverage for each test,
   for example: <pre class="source-code">
(ccl:reset-incremental-coverage)
(loop with coverage = (make-hash-table)
      for test in (tests-to-run)
      do (run-test test)
      do (setf (gethash test coverage) (ccl:get-incremental-coverage))
      finally (return coverage))
</pre>
creates a hash table mapping a test to a representation of all coverage recorded while running the
   test.  This hash table can then be passed to <CODE>ccl:report-coverage</CODE>, <CODE>ccl:incremental-coverage-svn-matches</CODE>
   or <CODE>ccl:incremental-coverage-source-matches</CODE>.
</p>
</div>
<a id="functions-and-variables"></a>
<H4>Functions and Variables</H4>
<div class="section">
<p>
  The following functions can be used to manage the coverage data:
</p>
<a id="f_report-coverage"></a>
<div class=definition>
<code>report-coverage</code> <i>output-file</i> <code>&amp;key</code>  (<i>tags</i> <i>nil</i>)  (<i>external-format</i> <i>:default</i>)  (<i>statistics</i> <i>t</i>)  (<i>html</i> <i>t</i>) <span class="definition-kind">[Function]</span><p>Generate a code coverage report</p>
<a id="arguments-and-values_in_f_report-coverage"></a>
<dl><dt><I>output-file</I></dt>
<dd><p>
          Pathname for the output index file.
	</p>
</dd>
<dt><I>html</I></dt>
<dd><p>
	  If non-nil (the default), this will generate an HTML report, consisting of
	  an index file in <I>output-file</I> and, in the same directory,
          one html file for each instrumented source file that has been loaded in the
          current session.
	</p>
</dd>
<dt><I>tags</I></dt>
<dd><p>
	  If non-nil, this should be a hash table mapping arbitrary keys (tags) to incremental coverage deltas.  The
          HTML report will show a list of tags, and allow selection of an arbitrary subset of them to show the
          coloring and statistics for coverage by that subset.
	</p>
</dd>
<dt><I>external-format</I></dt>
<dd><p>
	  Controls the external format of the html files.
	</p>
</dd>
<dt><I>statistics</I></dt>
<dd><p>If non-nil (the default), a comma-separated file is 
	  generated with the summary of statistics. You can specify a
	  filename for the statistics argument, otherwise
	  <CODE>statistics.csv</CODE> is created in the directory of <I>output-file</I>.
          See documentation of coverage-statistics below for a
	  description of the values in the statistics file.</p>
</dd>
</dl>
<a id="example_in_f_report-coverage"></a>
<p>
      If you've loaded <CODE>foo.lx64fsl</CODE> and
      <CODE>bar.lx64fsl</CODE>, and have run some tests, you could
      do
    <pre class="source-code">(report-coverage "/my/dir/coverage/report.html")
</pre>

    and this would generate <CODE>report.html</CODE>,
    <CODE>foo_lisp.html</CODE> and
    <CODE>bar_lisp.html</CODE>, and
    <CODE>statistics.csv</CODE> all in
    <CODE>/my/dir/coverage/</CODE>.
    </p>
</div>
<a id="f_reset-coverage"></a>
<div class=definition>
<code>reset-coverage</code> <span class="definition-kind">[Function]</span><p>Resets all coverage data back to the “Not Executed” state</p>
<a id="description_in_f_reset-coverage"></a>
<p>Resets all coverage data back to the “Not Executed” state</p>
</div>
<a id="f_clear-coverage"></a>
<div class=definition>
<code>clear-coverage</code> <span class="definition-kind">[Function]</span><p>Forget about all instrumented files that have been loaded.</p>
<a id="description_in_f_clear-coverage"></a>
<p>Gets rid of the information about which instrumented
      files have been loaded, so <CODE>ccl:report-coverage</CODE> will not
      report any files, and <CODE>ccl:save-coverage-in-file</CODE> will not
      save any info, until more instrumented files are loaded.</p>
</div>
<a id="f_save-coverage-in-file"></a>
<div class=definition>
<code>save-coverage-in-file</code> <i>pathname</i> <span class="definition-kind">[Function]</span><p>
      Save all coverage into to a file so you can restore it later.</p>
<a id="description_in_f_save-coverage-in-file"></a>
<p>
      Saves all coverage info in a file, so you can restore the
      coverage state later. This allows you to combine multiple runs
      or continue in a later session. Equivalent to
      <CODE>(ccl:write-coverage-to-file (ccl:get-coverage) pathname)</CODE>.
    </p>
</div>
<a id="f_restore-coverage-from-file"></a>
<div class=definition>
<code>restore-coverage-from-file</code> <i>pathname</i> <span class="definition-kind">[Function]</span><p>
      Load coverage state from a file.
    </p>
<a id="description_in_f_restore-coverage-from-file"></a>
<p>
      Restores the coverage data previously saved with
      ccl:save-coverage-in-file, for the set of instrumented fasls
      that were loaded both at save and restore time. I.e. coverage
      info is only restored for files that have been loaded in this
      session. For example if in a previous session you had loaded
      <CODE>"foo.lx86fsl"</CODE> and then saved the coverage info, in this session
      you must load the same <CODE>"foo.lx86fsl"</CODE> before calling
      <CODE>restore-coverage-from-file</CODE> in order to retrieve the stored
      coverage info for "foo".  Equivalent to <CODE>(ccl:restore-coverage
      (ccl:read-coverage-from-file pathname))</CODE>.
    </p>
</div>
<a id="f_get-coverage"></a>
<div class=definition>
<code>get-coverage</code> <span class="definition-kind">[Function]</span><p>
      Returns a snapshot of the current coverage data.
    </p>
<a id="description_in_f_get-coverage"></a>
<p>
      Returns a snapshot of the current coverage data. A snapshot is a
      copy of the current coverage state. It can be saved in a file
      with <CODE>ccl:write-coverage-to-file</CODE>, reinstated back as the current
      state with <CODE>ccl:restore-coverage</CODE>, or combined with other
      snapshots with <CODE>ccl:combine-coverage</CODE>.
    </p>
</div>
<a id="f_restore-coverage"></a>
<div class=definition>
<code>restore-coverage</code> <i>snapshot</i> <span class="definition-kind">[Function]</span><p>
      Reinstalls a coverage snapshot as the current coverage state.
    </p>
<a id="description_in_f_restore-coverage"></a>
<p>
      Reinstalls a coverage snapshot as the current coverage state.
    </p>
</div>
<a id="f_combine-coverage"></a>
<div class=definition>
<code>combine-coverage</code> <i>snapshots</i> <span class="definition-kind">[Function]</span><p>
      Combines multiple coverage snapshots into one.
    </p>
<a id="description_in_f_combine-coverage"></a>
<p>
      Takes a list of coverage snapshots and returns a new coverage snapshot
      representing a union of all the coverage data.
    </p>
</div>
<a id="f_write-coverage-to-file"></a>
<div class=definition>
<code>write-coverage-to-file</code> <i>snapshot</i> <i>pathname</i> <span class="definition-kind">[Function]</span><p>
      Save a coverage snapshot in a file.
    </p>
<a id="description_in_f_write-coverage-to-file"></a>
<p>
      Saves the coverage snapshot in a file. The snapshot can be
      loaded back with <CODE>ccl:read-coverage-from-file</CODE> or loaded and
      restored with <CODE>ccl:restore-coverage-from-file</CODE>. Note that the file
      created is actually a lisp source file and can be compiled for
      faster loading.
    </p>
</div>
<a id="f_read-coverage-from-file"></a>
<div class=definition>
<code>read-coverage-from-file</code> <i>pathname</i> <span class="definition-kind">[Function]</span><p>
      Return the coverage snapshot saved in a file.
    </p>
<a id="description_in_f_read-coverage-from-file"></a>
<p>
      Returns the snapshot saved in pathname. Doesn't affect the
      current coverage state. pathname can be the file previously
      created with <CODE>ccl:write-coverage-to-file</CODE> or
      <CODE>ccl:save-coverage-in-file</CODE>, or it can be the name of the fasl
      created from compiling such a file.
    </p>
</div>
<a id="f_coverage-statistics"></a>
<div class=definition>
<code>coverage-statistics</code> <span class="definition-kind">[Function]</span><p>
      Returns a sequence of <CODE>ccl:coverage-statistics</CODE> objects, one per source file.
    </p>
<a id="description_in_f_coverage-statistics"></a>
<p>
      Returns a sequence of <CODE>ccl:coverage-statistics</CODE> objects, one for each
      source file, containing the same information as that written to
      the statistics file by <a href="#f_report-coverage"><CODE>report-coverage</CODE></a>. The following
      accessors are defined for <CODE>ccl:coverage-statistics</CODE> objects:
      <dl><dt><CODE>coverage-source-file</CODE></dt>
<dd><p>
	    the name of the source file corresponding to this information
	  </p>
</dd>
<dt><CODE>coverage-expressions-total</CODE></dt>
<dd><p>
	    the total number of expressions
	  </p>
</dd>
<dt><CODE>coverage-expressions-entered</CODE></dt>
<dd><p>
	    the number of source expressions that have been entered
	    (i.e. at least partially covered)
	  </p>
</dd>
<dt><CODE>coverage-expressions-covered</CODE></dt>
<dd><p>
	    the number of source expressions that were fully covered
	  </p>
</dd>
<dt><CODE>coverage-unreached-branches</CODE></dt>
<dd><p>
	    the number of conditionals with one branch taken and one not taken
	  </p>
</dd>
<dt><CODE>coverage-code-forms-total</CODE></dt>
<dd><p>
	    the total number of code forms. A code form is an
	    expression in the final stage of compilation, after all
	    macroexpansion and compiler transforms and simplification
	  </p>
</dd>
<dt><CODE>coverage-code-forms-covered</CODE></dt>
<dd><p>
	    the number of code forms that have been entered
	  </p>
</dd>
<dt><CODE>coverage-functions-total</CODE></dt>
<dd><p>
	    the total number of functions
	  </p>
</dd>
<dt><CODE>coverage-functions-fully-covered</CODE></dt>
<dd><p>
	    the number of functions that were fully covered
	  </p>
</dd>
<dt><CODE>coverage-functions-partly-covered</CODE></dt>
<dd><p>
	    the number of functions that were partly covered
	  </p>
</dd>
<dt><CODE>coverage-functions-not-entered</CODE></dt>
<dd><p>
	    the number of functions never entered
	  </p>
</dd>
</dl>
</p>
</div>
<a id="f_reset-incremental-coverage"></a>
<div class=definition>
<code>reset-incremental-coverage</code> <span class="definition-kind">[Function]</span><p>
      Reset incremental coverage.
    </p>
<a id="description_in_f_reset-incremental-coverage"></a>
<p>
      Marks a starting point for recording incremental coverage.
      Note that calling
      this function does not affect regular coverage data (whereas calling
      <CODE>ccl:reset-coverage</CODE> resets incremental coverage as well).
    </p>
</div>
<a id="f_get-incremental-coverage"></a>
<div class=definition>
<code>get-incremental-coverage</code> <code>&amp;key</code>  (<i>reset</i> <i>t</i>) <span class="definition-kind">[Function]</span><p>
      Returns the delta of coverage since the last incremental reset.
    </p>
<a id="description_in_f_get-incremental-coverage"></a>
<p>
      Returns the delta of coverage since the last reset of incremental coverage.
     If <CODE>reset</CODE> is true (the default), it also resets incremental coverage
     now, so that the next call to <CODE>get-incremental-coverage</CODE> will return
     the delta from this point.</p>
<p>      Incremental coverage deltas are represented differently than the full coverage snapshots
      returned by functions such as <CODE>ccl:get-coverage</CODE>.  Incremental
      coverage uses an abbreviated format
      and is missing some of the information in a full snapshot, and therefore cannot be passed to
      functions documented to accept a <I>snapshot</I>, only to functions
      specifically documented to accept incremental coverage deltas.
     </p>
</div>
<a id="f_incremental-coverage-source-matches"></a>
<div class=definition>
<code>incremental-coverage-source-matches</code> <i>collection</i> <i>sources</i> <span class="definition-kind">[Function]</span><p>
      Find incremental coverage deltas intersecting source regions.
    </p>
<a id="arguments-and-values_in_f_incremental-coverage-source-matches"></a>
<dl><dt><I>collection</I></dt>
<dd><p>
          A hash table mapping arbitrary keys to incremental coverage deltas, or a sequence of
          incremental coverage deltas.
         </p>
</dd>
<dt><I>sources</I></dt>
<dd><p>
          A list of pathnames and/or source-notes, the latter representing a range within a file.
         </p>
</dd>
</dl>
<a id="description_in_f_incremental-coverage-source-matches"></a>
<p>
     Given a hash table <CODE>collection</CODE> whose values are incremental coverage
     deltas, return a list of all keys corresponding to those deltas that intersect any region
     in <CODE>sources</CODE>.</p>
<p>     For example if the deltas represent tests, then the returned value is a list of all tests
     that cover some part of the source regions.</p>
<p>      <CODE>collection</CODE> can also be a sequence of deltas, in which case a subsequence
      of matching deltas is returned.  In particular you can test whether any particular delta
      intersects the sources by passing it in as a single-element list.
     </p>
</div>
<a id="f_incremental-coverage-svn-matches"></a>
<div class=definition>
<code>incremental-coverage-svn-matches</code> <i>collection</i> <code>&amp;key</code>  (<i>directory</i> <i>(current-directory))</i>  (<i>revision</i> <i>:base</i>) <span class="definition-kind">[Function]</span><p>
      Find incremental coverage deltas matching changes from a particular subversion revision.
    </p>
<a id="arguments-and-values_in_f_incremental-coverage-svn-matches"></a>
<dl><dt><I>collection</I></dt>
<dd><p>
          A hash table mapping arbitrary keys to incremental coverage deltas, or a sequence of
          incremental coverage deltas.
         </p>
</dd>
<dt><I>directory</I></dt>
<dd><p>
          The pathname of a subversion working directory.
         </p>
</dd>
<dt><I>revision</I></dt>
<dd><p>
          The revision to compare to the working directory, an integer or another
          value whose printed representation is suitable for passing as the
          <CODE>--revision</CODE> argument
          to <CODE>svn</CODE>.
         </p>
</dd>
</dl>
<a id="description_in_f_incremental-coverage-svn-matches"></a>
<p>
     Given a hash table <CODE>collection</CODE> whose values are incremental coverage
     deltas, return a list of all keys corresponding to those deltas that intersect any changed
     source in <CODE>directory</CODE> since revision <CODE>revision</CODE> in subversion.</p>
<p>     For example if the deltas represent tests, then the returned value is a list of all tests
     that might be affected by the changes.</p>
<p>      <CODE>collection</CODE> can also be a sequence of deltas, in which case a subsequence
      of matching deltas is returned.  In particular you can test whether any particular delta
      is affected by the changes by passing it in as a single-element list.
     </p>
</div>
<a id="v_compile-code-coverage"></a>
<div class=definition>
<code>*compile-code-coverage*</code> <span class="definition-kind">[Variable]</span><p>
      When true, instrument functions being compiled to collect code coverage information.
    </p>
<a id="description_in_v_compile-code-coverage"></a>
<p>
      This variable controls whether functions are instrumented for
      code coverage. Files compiled while this variable is true will
      contain code coverage instrumentation.
    </p>
</div>
<a id="m_without-compiling-code-coverage"></a>
<div class=definition>
<code>without-compiling-code-coverage</code> <span class="definition-kind">[Macro]</span><p>
      Don't record code coverage for forms within the body.
    </p>
<a id="description_in_m_without-compiling-code-coverage"></a>
<p>
      This macro arranges so that body doesn't record internal details
      of code coverage. It will be considered totally covered if it's
      entered at all. The Common Lisp macros <CODE>ASSERT</CODE> and <CODE>CHECK-TYPE</CODE> use
      this macro.
    </p>
</div>
</div>
<a id="interpreting-code-coloring"></a>
<H4>Interpreting Code Coloring</H4>
<div class="section">
<p><p></p>
<p> The output of ccl:report-coverage consists of formatted source code, with coverage indicated by
 coloring.  Four colors are used: dark green for forms that compiled to code in which every single
 instruction was executed, light green for forms that have been entered but weren't totally covered, red
 for forms that were never entered, and the page background color for toplevel forms that weren't
 instrumented.</p>
</p>
<p><p>
 The source coloring is applied from outside in.  So for example if you have</p>
<p>  </p>
<pre class="source-code">
(outer-form ... (inner-form ...) ...)
  
</pre>
<p></p>
<p> first the whole outer form is painted with whatever color expresses the outer form coverage, and then the
 inner form color is replaced with whatever color expresses the inner form coverage.  One consequence of
 this approach is that every part of the outer form that is not specifically inside some executable inner
 form will have the outer form's coverage color. If the syntax of outer form involves some non-executable
 forms, or forms that do not have coverage info of their own for whatever reason, then they will just
 inherit the color of the outer form, because they don't get repainted with a color of their own.
</p>
</p>
<p>
 One case in which this approach can be confusing is in the case of symbols.  As noted in the Limitations
 section, coverage information is not recorded for variables; hence the coloring of a variable does not
 convey information about whether the variable was evaluated or not -- that information is not available,
 and the variable just inherits the color of the form that contains it.
</p>
</div>
</div>
<a id="other-extensions"></a>
<H3>Other Extensions</H3>
<div class="section">
<a id="m_unwind-protect"></a>
<div class=definition>
<code>unwind-protect</code> <i>protected-form</i> <i>{cleanup-form}*</i> <span class="definition-kind">[Macro]</span><p>
      Ensure cleanup-forms are executed.
    </p>
<a id="summary_in_m_unwind-protect"></a>
<p>
      In Clozure CL, the cleanup forms are always executed as if they were
      wrapped with <a href="#m_without-interrupts"><CODE>without-interrupts</CODE></a>.
      To allow interrupts, use
      <a href="#m_with-interrupts-enabled"><CODE>with-interrupts-enabled</CODE></a>.
    </p>
</div>
</div>
</div>
<a id="top-level-interface"></a>
<H2>Top-level Interface</H2>
<div class="section">
<ul style="list-style: none">
</ul>
<a id="v_quit-on-eof"></a>
<div class=definition>
<code>*quit-on-eof*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_quit-on-eof"></a>
<p>When true, exit the top-level immediately upon
receipt of an EOF.  If <a href="#v_quit-on-eof"><CODE>*quit-on-eof*</CODE></a> is <CODE>nil</CODE> (which
is the default), ignore the EOF.</p>
<p>Note, though, that an internally-defined number of consecutive EOFs
will exit lisp anyway.</p>
</div>
<a id="tc_pwd"></a>
<div class=definition>
<code>:pwd</code> <span class="definition-kind">[Toplevel Command]</span><a id="description_in_tc_pwd"></a>
<p>Print the pathname of the current directory.</p>
</div>
<a id="tc_cd"></a>
<div class=definition>
<code>:cd</code> <i>dir</i> <span class="definition-kind">[Toplevel Command]</span><a id="description_in_tc_cd"></a>
<p>Change to the directory specified by <I>dir</I>, which may be a
namestring or a pathname object.</p>
</div>
<a id="tc_proc"></a>
<div class=definition>
<code>:proc</code> <code>&amp;optional</code> <i>proc</i> <span class="definition-kind">[Toplevel Command]</span><a id="description_in_tc_proc"></a>
<p>Show information about the process <I>proc</I>, or all
processes if <I>proc</I> is not specified.</p>
</div>
<a id="tc_kill"></a>
<div class=definition>
<code>:kill</code> <i>proc</i> <span class="definition-kind">[Toplevel Command]</span><a id="description_in_tc_kill"></a>
<p>Kill the process whose name or ID matches <I>proc</I>.</p>
</div>
</div>
<a id="debugging"></a>
<H2>Debugging</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#break-loops">
Break Loops</a>
<ul style="list-style: none">
</ul>
<li><a href="#trace">
Trace</a>
<ul style="list-style: none">
</ul>
<li><a href="#advising">
Advising</a>
<ul style="list-style: none">
</ul>
<li><a href="#watched-objects">
Watched Objects</a>
<ul style="list-style: none">
<li><a href="#notes_in_watched-objects">
Notes</a>
<li><a href="#examples_in_watched-objects">
Examples</a>
</ul>
<li><a href="#memory">
Memory</a>
<ul style="list-style: none">
</ul>
<li><a href="#disassemble">
Disassemble</a>
<ul style="list-style: none">
</ul>
<li><a href="#source-notes">
Source Notes</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="break-loops"></a>
<H3>Break Loops</H3>
<div class="section">
<a id="v_break-on-warnings"></a>
<div class=definition>
<code>*break-on-warnings*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_break-on-warnings"></a>
<p>When true, <CODE>warn</CODE> will enter a break loop.</p>
<p>This variable was removed from ANSI CL.  The rationale was that the
same effect may be acheived with <CODE>(setq *break-on-signals* 'warning)</CODE>.</p>
</div>
<a id="v_break-on-errors"></a>
<div class=definition>
<code>*break-on-errors*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_break-on-errors"></a>
<p>When true (the default), lisp will enter a break loop when an
error is signaled.</p>
</div>
<a id="v_show-restarts-on-break"></a>
<div class=definition>
<code>*show-restarts-on-break*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_show-restarts-on-break"></a>
<p>When true, automatically print the available restarts before entering a break loop.</p>
</div>
</div>
<a id="trace"></a>
<H3>Trace</H3>
<div class="section">
<p>Clozure CL's tracing facility is invoked by an extended version
      of the Common Lisp <CODE>trace</CODE> macro.  Extensions allow tracing
      of methods, as well as finer control over tracing actions.</p>
<a id="m_trace"></a>
<div class=definition>
<code>trace</code> <i>{</i> <i>keyword</i> <i>global-value</i> <i>}*</i> <i>{</i> <i>spec</i> <i>|</i>  (<i></i> <i>spec</i> <i>{</i> <i>keyword</i> <i>local-value</i> <i>}*)}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_trace"></a>
<p>The <CODE>trace</CODE> macro encapsulates the functions named by
        <I>spec</I>s, causing trace actions to take place on entry
        and exit from each function.  The default actions print a
        message on function entry and exit. <I>Keyword</I>/<I>value</I> options can be used to specify changes in the default
        behavior.</p>
<p>        Invoking <CODE>(trace)</CODE> without arguments returns a list of
        functions being traced.</p>
<p>        A <I>spec</I> is either a symbol that is the name of a
        function, or an expression of the form <CODE>(setf <I>symbol</I>)</CODE>, or a specific method of a generic function in the
        form <CODE>(:method <I>gf-name</I> {<I>qualifier</I>}* ({<I>specializer</I>}*))</CODE>,
        where a <I>specializer</I> can be the name of a class or an
        <CODE>EQL</CODE> specializer.</p>
<p>        A <I>spec</I> can also be a string naming a package, or
        equivalently a list <CODE>(:package <I>package-name</I>)</CODE>,
        in order to request that all functions in the package to be
        traced.</p>
<p>        By default, whenever a traced function is entered or exited, a
        short message is printed on <CODE>*trace-output*</CODE> showing
        the arguments on entry and values on exit.  Options specified
        as key/value pairs can be used to modify this behavior.
        Options preceding the function <I>spec</I>s apply to all the
        functions being traced.  Options specified along with a
        <I>spec</I> apply to that spec only and override any global
        options. The following options are supported:</p>
<dl><dt><CODE>:methods {T | nil}</CODE></dt>
<dd><p>If true, and if applied to a <I>spec</I> naming a generic
	   function, arranges to trace all the methods of the generic
	   function in addition to the generic function itself.</p>
</dd>
<dt><CODE>:inside <I>outside-spec</I> | ({<I>outside-spec</I>}*)</CODE></dt>
<dd><p>Inhibits all trace actions unless the current
	        invocation of the function being traced is inside one
	        of the <I>outside-spec</I>'s, i.e. unless a function
	        named by one of the <I>outside-spec</I>'s is
	        currently on the stack.  <I>outside-spec</I> can
	        name a function, a method, or a package, as above.</p>
</dd>
<dt><CODE>:if <I>form</I></CODE>, <CODE>:condition <I>form</I></CODE></dt>
<dd><p> Evaluates <I>form</I> whenever the function being traced
	        is about to be entered, and inhibits all trace actions
	        if <I>form</I> returns nil. The form may reference
	        the lexical variable <CODE>ccl::args</CODE>, which is a list
	        of the arguments in this call. <CODE>:condition</CODE> is
	        just a synonym for <CODE>:if</CODE>, though if both are
	        specified, both must return non-nil.
	      </p>
</dd>
<dt><CODE>:before-if <I>form</I></CODE></dt>
<dd><p> Evaluates <I>form</I> whenever the function being traced
	        is about to be entered, and inhibits the entry trace
	        actions if <I>form</I> returns nil.  The form may
	        reference the lexical variable <CODE>ccl::args</CODE>, which
	        is a list of the arguments in this call. If both
	        <CODE>:if</CODE> and <CODE>:before-if</CODE> are specified, both
	        must return non-nil in order for the before entry
	        actions to happen.</p>
</dd>
<dt><CODE>:after-if <I>form</I></CODE></dt>
<dd><p> Evaluates <I>form</I> whenever the function being traced
	        has just exited, and inhibits the exit trace actions
	        if <I>form</I> returns nil.  The form may reference
	        the lexical variable <CODE>ccl::vals</CODE>, which is a list
	        of values returned by this call. If both <CODE>:if</CODE>
	        and <CODE>:after-if</CODE> are specified, both must return
	        non-nil in order for the after exit actions to happen.</p>
</dd>
<dt><CODE>:print-before <I>form</I></CODE></dt>
<dd><p> Evaluates <I>form</I> whenever the function being traced
	        is about to be entered, and prints the result before
	        printing the standard entry message.  The form may
	        reference the lexical variable <CODE>ccl::args</CODE>, which
	        is a list of the arguments in this call.  To see
	        multiple forms, use <CODE>values</CODE>:
	        <CODE>:print-before (values (one-thing) (another-thing))</CODE>.</p>
</dd>
<dt><CODE>:print-after <I>form</I></CODE></dt>
<dd><p> Evaluates <I>form</I> whenever the function being
	        traced has just exited, and prints the result after
	        printing the standard exit message.  The form may
	        reference the lexical variable <CODE>ccl::vals</CODE>, which
	        is a list of values returned by this call. To see
	        multiple forms, use <CODE>values</CODE>:
	        <CODE>:print-after (values (one-thing) (another-thing))</CODE>.</p>
</dd>
<dt><CODE>:print <I>form</I></CODE></dt>
<dd><p>Equivalent to <CODE>:print-before <I>form</I> :print-after <I>form</I></CODE>.</p>
</dd>
<dt><CODE>:eval-before <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        traced is about to be entered.  The form may reference
	        the lexical variable <CODE>ccl::args</CODE>, which is a list
	        of the arguments in this call.</p>
</dd>
<dt><CODE>:eval-after <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        has just exited.  The form may reference the lexical
	        variable <CODE>ccl::vals</CODE>, which is a list of values
	        returned by this call.
	      </p>
</dd>
<dt><CODE>:eval <I>form</I></CODE></dt>
<dd><p>Equivalent to <CODE>:eval-before <I>form</I> :eval-after <I>form</I></CODE>.</p>
</dd>
<dt><CODE>:break-before <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        traced is about to be entered, and if the result is
	        non-nil, enters a debugger break loop.  The form may
	        reference the lexical variable <CODE>ccl::args</CODE>, which
	        is a list of the arguments in this call.</p>
</dd>
<dt><CODE>:break-after <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        traced has just exited, and if the result is non-nil,
	        enters a debugger break loop. The form may reference
	        the lexical variable <CODE>ccl::vals</CODE>, which is a list
	        of values returned by this call.</p>
</dd>
<dt><CODE>:break <I>form</I></CODE></dt>
<dd><p>Equivalent to <CODE>:break-before <I>form</I> :break-after <I>form</I></CODE>.</p>
</dd>
<dt><CODE>:backtrace-before <I>form</I></CODE>, <CODE>:backtrace <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        traced is about to be entered.  The form may reference
	        the lexical variable <CODE>ccl::args</CODE>, which is a list
	        of the arguments in this call. The value returned by
	        <I>form</I> is intepreted as follows:</p>
<dl><dt><CODE>nil</CODE></dt>
<dd><p>does nothing</p>
</dd>
<dt><CODE>:detailed</CODE></dt>
<dd><p>prints a
	              detailed backtrace to <CODE>*trace-output*</CODE>.</p>
</dd>
<dt><CODE>(:detailed <I>integer</I>)</CODE></dt>
<dd><p>prints the top <I>integer</I>
	              frames of detailed backtrace to <CODE>*trace-output*</CODE>.</p>
</dd>
<dt><I>integer</I></dt>
<dd><p>prints top
	              <I>integer</I> frames of a terse backtrace to
	              <CODE>*trace-output*</CODE>.</p>
</dd>
<dt>anything else</dt>
<dd><p>prints a terse
		 backtrace to <CODE>*trace-output*</CODE>.</p>
</dd>
</dl>
<p>Note that unlike with the other options,
	        <CODE>:backtrace</CODE> is equivalent to
	        <CODE>:backtrace-before</CODE> only, not both before and
	        after, since it's usually not helpful to print the
	        same backtrace both before and after the function
	        call.</p>
</dd>
<dt><CODE>:backtrace-after <I>form</I></CODE></dt>
<dd><p>Evaluates <I>form</I> whenever the function being
	        traced has just exited.  The form may reference the
	        lexical variable <CODE>ccl::vals</CODE>, which is a list of
	        values returned by this call. The value returned by
	        <I>form</I> is intepreted as follows:</p>
<dl><dt><CODE>nil</CODE></dt>
<dd><p>does nothing</p>
</dd>
<dt><CODE>:detailed</CODE></dt>
<dd><p>prints a detailed
	              backtrace to <CODE>*trace-output*</CODE>.</p>
</dd>
<dt><CODE>(:detailed <I>integer</I>)</CODE></dt>
<dd><p>prints the top <I>integer</I>
	              frames of detailed backtrace to <CODE>*trace-output*</CODE>.</p>
</dd>
<dt><I>integer</I></dt>
<dd><p>prints top <I>integer</I> frames of a terse backtrace to
	              <CODE>*trace-output*</CODE>.</p>
</dd>
<dt>anything else</dt>
<dd><p>prints a terse backtrace
            to <CODE>*trace-output*</CODE>.</p>
</dd>
</dl>
</dd>
<dt><CODE>:before</CODE><I>action</I></dt>
<dd><p>specifies the action to be taken just before the traced
           function is entered.  <I>action</I> is one of:</p>
<dl><dt><CODE>:print</CODE></dt>
<dd><p>The default, prints a short indented message showing the
             function name and the invocation arguments</p>
</dd>
<dt><CODE>:break</CODE></dt>
<dd><p>Equivalent to
            <CODE>:before :print :break-before t</CODE></p>
</dd>
<dt><CODE>:backtrace</CODE></dt>
<dd><p>Equivalent to
            <CODE>:before :print :backtrace-before t</CODE></p>
</dd>
<dt><I>function</I></dt>
<dd><p> Any other value is
                  interpreted as a function to call on entry instead
                  of printing the standard entry message.  It is
                  called with its first argument being the name of the
                  function being traced, the remaining arguments being
                  all the arguments to the function being traced, and
                  <a href="#v_trace-level"><CODE>*trace-level*</CODE></a> bound to the current
                  nesting level of trace actions. </p>
</dd>
</dl>
</dd>
<dt><CODE>:after</CODE><I>action</I></dt>
<dd><p>specifies the action to be taken just after the
          traced function exits.  <I>action</I> is one of:</p>
<dl><dt><CODE>:print</CODE></dt>
<dd><p>The default, prints a short indented message showing the
	              function name and the returned values </p>
</dd>
<dt><CODE>:break</CODE></dt>
<dd><p>Equivalent to
            <CODE>:after :print :break-after t</CODE></p>
</dd>
<dt><CODE>:backtrace</CODE></dt>
<dd><p>Equivalent to
            <CODE>:after :print :backtrace-after t</CODE></p>
</dd>
<dt><I>function</I></dt>
<dd><p>Any other value is
	              interpreted as a function to call on exit
	              instead of printing the standard exit message.
	              It is called with its first argument being the
	              name of the function being traced, the remaining
	              arguments being all the values returned by the
	              function being traced, and ccl:*trace-level*
	              bound to the current nesting level of trace
	              actions.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<a id="v_trace-level"></a>
<div class=definition>
<code>ccl:*trace-level*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_trace-level"></a>
<p>Variable bound to the current nesting level during
        execution of before and after trace actions.  The default
        printing actions use it to determine the amount of
        indentation.</p>
</div>
<a id="v_trace-max-indent"></a>
<div class=definition>
<code>ccl:*trace-max-indent*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_trace-max-indent"></a>
<p>The default before and after print actions will not indent by
        more than the value of <a href="#v_trace-max-indent"><CODE>*trace-max-indent*</CODE></a>
        regardless of the current trace level.</p>
</div>
<a id="f_trace-function"></a>
<div class=definition>
<code>ccl:trace-function</code> <i>spec</i> <code>&amp;key</code> <i>{</i> <i>keyword</i> <i>value</i> <i>}*</i> <span class="definition-kind">[Function]</span><a id="description_in_f_trace-function"></a>
<p>This is a functional version of the TRACE macro.
      <I>spec</I> and <I>keyword</I>s are as for TRACE, except
      that all arguments are evaluated. </p>
</div>
<a id="v_trace-print-level"></a>
<div class=definition>
<code>ccl:*trace-print-level*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_trace-print-level"></a>
<p>The default print actions bind <CODE>*print-level*</CODE>
      to this value while printing. Note that this rebinding is only
      in effect during the default entry and exit messages.  It does
      not apply to printing of <CODE>:print-before/:print-after</CODE> forms
      or any explicit printing done by user code.</p>
</div>
<a id="v_trace-print-length"></a>
<div class=definition>
<code>ccl:*trace-print-length*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_trace-print-length"></a>
<p>The default print actions bind <CODE>*print-length*</CODE>
      to this value while printing. Note that this rebinding is only
      in effect during the default entry and exit messages.  It does
      not apply to printing of <CODE>:print-before/:print-after</CODE> forms
      or any explicit printing done by user code.</p>
</div>
<a id="v_trace-bar-frequency"></a>
<div class=definition>
<code>ccl:*trace-bar-frequency*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_trace-bar-frequency"></a>
<p>By default, this is nil. If non-nil it should be a
    integer, and the default entry and exit messages will print a |
    instead of space every this many levels of indentation.</p>
</div>
</div>
<a id="advising"></a>
<H3>Advising</H3>
<div class="section">
<p>
    The <CODE>advise</CODE> macro can be thought of as a more
    general version of <CODE>trace</CODE>. It allows code that
    you specify to run before, after, or around a given function, for
    the purpose of changing the behavior of the function. Each piece
    of added code is called a piece of advice. Each piece of advice
    has a unique name, so that you can have multiple pieces of advice
    on the same function, including multiple
    <CODE>:before</CODE>, <CODE>:after</CODE>, and
    <CODE>:around</CODE> pieces of advice.</p>
<p>    The <CODE>:name</CODE> and <CODE>:when</CODE>
    keywords serve to identify the piece of advice.  A later call to
    <CODE>advise</CODE> with the same values of
    <CODE>:name</CODE> and <CODE>:when</CODE> will replace
    the existing piece of advice; a call with different values will not.
  </p>
<a id="m_advise"></a>
<div class=definition>
<code>advise</code> <i>spec</i> <i>form</i> <code>&amp;key</code> <i>when</i> <i>name</i> <span class="definition-kind">[Macro]</span><p>
	Add a piece of advice to the function or method specified by
	<I>spec</I> according to
	<I>form</I>.
      </p>
<a id="arguments-and-values_in_m_advise"></a>
<dl><dt><I>spec</I></dt>
<dd><p>
	      A specification of the function on which to put the
	      advice.  This is either a symbol that is the name of a
	      function or generic function, or an expression of the
	      form (setf <I>symbol</I>), or a
	      specific method of a generic function in the form
	      (:method symbol {qualifiers} (specializer {specializer})).
	    </p>
</dd>
<dt><I>form</I></dt>
<dd><p>
	      A form to execute before, after, or around the advised
	      function. The form can refer to the variable arglist
	      that is bound to the arguments with which the advised
	      function was called. You can exit from form with
	      (return).
	    </p>
</dd>
<dt><I>name</I></dt>
<dd><p>
	      A name that identifies the piece of advice.
	    </p>
</dd>
<dt><I>when</I></dt>
<dd><p>
	      An argument that specifies when the piece of advice is
	      run. There are three allowable values. The default is
	      <CODE>:before</CODE>, which specifies that form is
	      executed before the advised function is called. Other
	      possible values are <CODE>:after</CODE>, which
	      specifies that form is executed after the advised
	      function is called, and <CODE>:around</CODE>,
	      which specifies that form is executed around the call to
	      the advised function. Use <CODE>(:do-it)</CODE>
	      within form to indicate invocation of the original
	      definition.
	    </p>
</dd>
</dl>
<a id="examples_in_m_advise"></a>
<p>
	The function <CODE>foo</CODE>, already defined, does
	something with a list of numbers. The following code uses a
	piece of advice to make foo return zero if any of its
	arguments is not a number. Using :around advice, you can do
	the following:
	<pre class="source-code">
(advise foo (if (some #'(lambda (n) (not (numberp n))) arglist)
	      0
	      (:do-it))
	:when :around :name :zero-if-not-nums)
	
</pre>
</p>
<p>
	To do the same thing using a :before piece of advice:
	<pre class="source-code">
(advise foo (if (some #'(lambda (n) (not (numberp n))) arglist)
	      (return 0))
	:when :before :name :zero-if-not-nums)
	
</pre>
</p>
</div>
<a id="m_unadvise"></a>
<div class=definition>
<code>unadvise</code> <i>spec</i> <code>&amp;key</code> <i>when</i> <i>name</i> <span class="definition-kind">[Macro]</span><p>
	Remove the piece or pieces of advice matching <I>spec</I>,
	<I>when</I>, and <I>name</I>.
      </p>
<a id="description_in_m_unadvise"></a>
<p>
	The unadvise macro removes the piece or pieces of advice
	matching <CODE>spec</CODE>, <CODE>when</CODE>,
	and <CODE>name</CODE>. When the value of
	<CODE>spec</CODE> is t and the values of <CODE>when</CODE>
	and <CODE>name</CODE> are nil, unadvise
	removes every piece of advice; when <CODE>spec</CODE> is
	t, the argument <CODE>when</CODE> is nil, and
	<CODE>name</CODE> is non-nil, unadvise removes all
	pieces of advice with the given name.
      </p>
<a id="arguments-and-values_in_m_unadvise"></a>
<p>
	The arguments have the same meaning as in
	<a href="#m_advise"><CODE>advise</CODE></a>.
      </p>
</div>
<a id="m_advisedp"></a>
<div class=definition>
<code>advisedp</code> <i>spec</i> <code>&amp;key</code> <i>when</i> <i>name</i> <span class="definition-kind">[Macro]</span><p>
	Return a list of the pieces of advice matching <I>spec</I>,
	<I>when</I>, and <I>name</I>.
      </p>
<a id="description_in_m_advisedp"></a>
<p>
	The advisedp macro returns a list of existing pieces of advice
	that match <CODE>spec</CODE>, <CODE>when</CODE>,
	and <CODE>name</CODE>. When the value of
	<CODE>spec</CODE> is t and the values of
	<CODE>when</CODE> and <CODE>name</CODE> are nil,
	advisedp returns all existing pieces of advice.
      </p>
<a id="arguments-and-values_in_m_advisedp"></a>
<p>
	The arguments have the same meaning as in
	<a href="#m_advise"><CODE>advise</CODE></a>.
</p>
</div>
</div>
<a id="watched-objects"></a>
<H3>Watched Objects</H3>
<div class="section">
<p>
    As of release 1.4, Clozure CL provides a way for lisp objects to
    be watched so that a condition will be signaled when a thread
    attempts to write to the watched object. For a certain class of
    bugs (someone is changing this value, but I don't know who), this
    can be extremely helpful.
  </p>
<a id="f_watch"></a>
<div class=definition>
<code>watch</code> <code>&amp;optional</code> <i>object</i> <span class="definition-kind">[Function]</span><p>
	Monitor a lisp object for writes.
      </p>
<a id="arguments-and-values_in_f_watch"></a>
<dl><dt><I>object</I></dt>
<dd><p>
	      Any memory-allocated lisp object.
	    </p>
</dd>
</dl>
<a id="description_in_f_watch"></a>
<p>The WATCH function arranges for the specified object to be
	monitored for writes. This is accomplished by copying the
	object to its own set of virtual memory pages, which are then
	write-protected. This protection is enforced by the computer's
	memory-management hardware; the write-protection does not slow
	down reads at all.</p>
<p>	When any write to the object is attempted, a
	WRITE-TO-WATCHED-OBJECT condition will be signaled.</p>
<p>	When called with no arguments, WATCH returns a freshly-consed
	list of the objects currently being watched.</p>
<p>	WATCH returns NIL if the object cannot be watched (typically
	because the object is in a static or pure memory area).
      </p>
<a id="dwim"></a>
<p>
      WATCH operates at a fairly low level; it is not possible to
      avoid the details of the internal representation of objects.
      Nevertheless, as a convenience, WATCHing a standard-instance,
      a hash-table, or a multi-dimensional or non-simple CL array
      will watch the underlying slot-vector, hash-table-vector, or
      data-vector, respectively.
      </p>
<a id="discussion_in_f_watch"></a>
<p>
      WATCH can monitor any memory-allocated lisp object.</p>
<p>      In Clozure CL, a memory-allocated object is either a cons cell
      or a uvector.</p>
<p>      WATCH operates on cons cells, not lists. In order to watch a
      chain of cons cells, each cons cell must be watched
      individually. Because each watched cons cell takes up its own
      own virtual memory page (4 Kbytes), it's only feasible to watch
      relatively short lists.</p>
<p>      If a memory-allocated object isn't a cons cell, then it is a
      vector-like object called a uvector. A uvector is a
      memory-allocated lisp object whose first word is a header that
      describes the object's type and the number of elements that it
      contains.</p>
<p>      So, a hash table is a uvector, as is a string, a standard
      instance, a double-float, a CL array or vector, and so forth.</p>
<p>      Some CL objects, like strings and other simple vectors, map in a
      straightforward way onto the uvector representation. It is easy
      to understand what happens in such cases. The uvector index
      corresponds directly to the vector index:
    </p>
<pre class="source-code">
? (defvar *s* "xxxxx")
*S*
? (watch *s*)
"xxxxx"
? (setf (char *s* 3) #\o)
&gt; Error: Write to watched uvector "xxxxx" at index 3
&gt;        Faulting instruction: (movl (% eax) (@ -5 (% r15) (% rcx)))
&gt; While executing: SET-CHAR, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
</pre>
<p>
      In the case of more complicated objects (e.g., a hash-table, a
      standard-instance, a package, etc.), the elements of the uvector
      are like slots in a structure. It's necessary to know which one
      of those "slots" contains the data that will be changed when the
      object is written to.</p>
<p>      As mentioned above, watch knows about arrays, hash-tables, and
      standard-instances, and will automatically watch the appropriate
      data-containing element.</p>
<p>      An example might make this clearer.
    </p>
<pre class="source-code">
? (defclass foo ()
    (slot-a slot-b slot-c))
#&lt;STANDARD-CLASS FOO&gt;
? (defvar *a-foo* (make-instance 'foo))
*A-FOO*
? (watch *a-foo*)
#&lt;SLOT-VECTOR #xDB00D&gt;
;;; Note that WATCH has watched the internal slot-vector object
? (setf (slot-value *a-foo* 'slot-a) 'foo)
&gt; Error: Write to watched uvector #&lt;SLOT-VECTOR #xDB00D&gt; at index 1
&gt;        Faulting instruction: (movq (% rsi) (@ -5 (% r8) (% rdi)))
&gt; While executing: %MAYBE-STD-SETF-SLOT-VALUE-USING-CLASS, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
</pre>
<p>
      Looking at a backtrace would presumably show what object and
      slot name were written.</p>
<p>      Note that even though the write was to slot-a, the uvector index
      was 1 (not 0). This is because the first element of a
      slot-vector is a pointer to the instance that owns the slots. We
      can retrieve that to look at the object that was modified:
    </p>
<pre class="source-code">
1 &gt; (uvref (write-to-watched-object-object *break-condition*) 0)
#&lt;FOO #x30004113502D&gt;
1 &gt; (describe *)
#&lt;FOO #x30004113502D&gt;
Class: #&lt;STANDARD-CLASS FOO&gt;
Wrapper: #&lt;CLASS-WRAPPER FOO #x300041135EBD&gt;
Instance slots
SLOT-A: #&lt;Unbound&gt;
SLOT-B: #&lt;Unbound&gt;
SLOT-C: #&lt;Unbound&gt;
1 &gt;
</pre>
</div>
<a id="f_unwatch"></a>
<div class=definition>
<code>unwatch</code> <i>object</i> <span class="definition-kind">[Function]</span><p>
	Stop monitoring a lisp object for writes.
      </p>
<a id="description_in_f_unwatch"></a>
<p>The UNWATCH function ensures that the specified
    object is in normal, non-monitored memory. If the object is not
    currently being watched, UNWATCH does nothing and returns
    NIL. Otherwise, the newly unwatched object is returned.
  </p>
</div>
<a id="c_write-to-watched-object"></a>
<div class=definition>
<code>write-to-watched-object</code> <span class="definition-kind">[Condition]</span><p>
	Condition signaled when a write to a watched object is attempted.
      </p>
<a id="discussion_in_c_write-to-watched-object"></a>
<p>
      This condition is signaled when a watched object is written
      to. There are three slots of interest:
    </p>
<dl><dt>object</dt>
<dd><p>
	    The actual object that was the destination of the write.
	  </p>
</dd>
<dt>offset</dt>
<dd><p>
	    The byte offset from the tagged object pointer to the
	    address of the write.
	  </p>
</dd>
<dt>instruction</dt>
<dd><p>
	    The disassembled machine instruction that attempted the write.
	  </p>
</dd>
</dl>
<a id="restarts"></a>
<p>
      A few restarts are provided: one will skip over the faulting
      write instruction and proceed; another offers to unwatch the
      object and continue.</p>
<p>      There is also an emulate restart. In some common cases, the
      faulting write instruction can be emulated, enabling the write
      to be performed without having to unwatch the object (and
      therefore let other threads potentially write to it). If the
      faulting instruction isn't recognized, the emulate restart will
      not be offered.
    </p>
</div>
<a id="notes_in_watched-objects"></a>
<H4>Notes</H4>
<div class="section">
<p>
  Although some care has been taken to minimize potential problems
  arising from watching and unwatching objects from multiple
  threads, there may well be subtle race conditions present that
  could cause bad behavior.</p>
<p>  For example, suppose that a thread attempts to write to a watched
  object. This causes the operating system to generate an
  exception. The lisp kernel figures out what the exception is, and
  calls back into lisp to signal the write-to-watched-object
  condition and perhaps handle the error.</p>
<p>  Now, as soon lisp code starts running again (for the callback),
  it's possible that some other thread could unwatch the very
  watched object that caused the exception, perhaps before we even
  have a chance to signal the condition, much less respond to it.</p>
<p>  Having the object unwatched out from underneath a handler may at
  least confuse it, if not cause deeper trouble. Use caution with
  unwatch.
</p>
</div>
<a id="examples_in_watched-objects"></a>
<H4>Examples</H4>
<div class="section">
<p>
  Here are a couple more examples in addition to the above examples
  of watching a string and a standard-instance.
</p>
<a id="fancy-arrays"></a>
<H5>Fancy arrays</H5>
<div class="section">
<pre class="source-code">
?  (defvar *f* (make-array '(2 3) :element-type 'double-float))
*F*
? (watch *f*)
#(0.0D0 0.0D0 0.0D0 0.0D0 0.0D0 0.0D0)
;;; Note that the above vector is the underlying data-vector for the array
? (setf (aref *f* 1 2) pi)
&gt; Error: Write to watched uvector #&lt;VECTOR 6 type DOUBLE-FLOAT, simple&gt; at index 5
&gt;        Faulting instruction: (movq (% rax) (@ -5 (% r8) (% rdi)))
&gt; While executing: ASET, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
1 &gt; 
  
</pre>
<p>
    In this case, uvector index in the report is the row-major index
    of the element that was written to.
  </p>
</div>
<a id="hash-tables"></a>
<H5>Hash tables</H5>
<div class="section">
<p>
    Hash tables are surprisingly complicated. The representation of a
    hash table includes an element called a hash-table-vector. The
    keys and values of the elements are stored pairwise in this
    vector.</p>
<p>    One problem with trying to monitor hash tables for writes is that
    the underlying hash-table-vector is replaced with an entirely new
    one when the hash table is rehashed. A previously-watched
    hash-table-vector will not be the used by the hash table after
    rehashing, and writes to the new vector will not be caught.
  </p>
<pre class="source-code">
? (defvar *h* (make-hash-table))
*H*
? (setf (gethash 'noise *h*) 'feep)
FEEP
? (watch *h*)
#&lt;HASH-TABLE-VECTOR #xDD00D&gt;
;;; underlying hash-table-vector
? (setf (gethash 'noise *h*) 'ding)
&gt; Error: Write to watched uvector #&lt;HASH-TABLE-VECTOR #xDD00D&gt; at index 35
&gt;        Faulting instruction: (lock)
&gt;          (cmpxchgq (% rsi) (@ (% r8) (% rdx)))
&gt; While executing: %STORE-NODE-CONDITIONAL, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
;;; see what value is being replaced...
1 &gt; (uvref (write-to-watched-object-object *break-condition*) 35)
FEEP
;;; backtrace shows useful context
1 &gt; :b
*(1A109F8) : 0 (%STORE-NODE-CONDITIONAL ???) NIL
 (1A10A50) : 1 (LOCK-FREE-PUTHASH NOISE #&lt;HASH-TABLE :TEST EQL size 1/60 #x30004117D47D&gt; DING) 653
 (1A10AC8) : 2 (CALL-CHECK-REGS PUTHASH NOISE #&lt;HASH-TABLE :TEST EQL size 1/60 #x30004117D47D&gt; DING) 229
 (1A10B00) : 3 (TOPLEVEL-EVAL (SETF (GETHASH # *H*) 'DING) NIL) 709
 ...
  
</pre>
</div>
<a id="lists"></a>
<H5>Lists</H5>
<div class="section">
<p>
    As previously mentioned, WATCH only watches individual cons cells.
  </p>
<pre class="source-code">
? (defun watch-list (list)
    (maplist #'watch list))
WATCH-LIST
? (defvar *l* (list 1 2 3))
*L*
? (watch-list *l*)
((1 2 3) (2 3) (3))
? (setf (nth 2 *l*) 'foo)
&gt; Error: Write to the CAR of watched cons cell (3)
&gt;        Faulting instruction: (movq (% rsi) (@ 5 (% rdi)))
&gt; While executing: %SETNTH, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.h
</pre>
</div>
</div>
</div>
<a id="memory"></a>
<H3>Memory</H3>
<div class="section">
<a id="f_heap-utilization"></a>
<div class=definition>
<code>heap-utilization</code> <code>&amp;key</code>  (<i>stream</i> <i>*debug-io*</i>)  (<i>gc-first</i> <i>t</i>) <i>area</i> <i>unit</i>  (<i>sort</i> <i>:size</i>) <i>classes</i> <i>start</i> <i>threshold</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_heap-utilization"></a>
<p>This function walks the lisp heap, collects information about the
objects stored on the heap, and prints a report of the results to the
stream speficied by the keyword argument <CODE>:stream</CODE>. It shows the
number of objects of each type, the sum of their logical sizes (the
size of the data part of the object) and the sum of their physical
sizes (the total size as computed by <a href="#f_object-direct-size"><CODE>object-direct-size</CODE></a>).</p>
<p>If <CODE>:gc-first</CODE> is true (the default), <a href="#f_heap-utilization"><CODE>heap-utilization</CODE></a>
does a full gc before scanning the heap.</p>
<p>If <CODE>:classes</CODE> is true, objects are classified by class rather
than just basic type.</p>
<p>The keyword argument <CODE>:area</CODE> can be used to restrict the walk to
one memory area or a list of areas. Some possible values
are <CODE>:dynamic</CODE>, <CODE>:static</CODE>, <CODE>:managed-static</CODE>, and
<CODE>:readonly</CODE>. By default, all areas (including stacks) are examined.</p>
<p>The keword argument <CODE>:sort</CODE> can be one of <CODE>:count</CODE>,
<CODE>:logical-size</CODE>, or <CODE>:physical-size</CODE> to sort output by count
or size.</p>
<p>By default, sizes are shown in bytes.  The keyword argument
<CODE>:unit</CODE> can be <CODE>:kb</CODE>, <CODE>:mb</CODE>, or <CODE>:gb</CODE>
to show sizes in those units.</p>
<p>If <CODE>:start</CODE> is non-nil, it should be an object returned by
<CODE>ccl::get-allocation-sentinel</CODE>; only objects at higher address are
scanned (roughly, only objects allocated after it).</p>
<p>If threshold is non-nil, it should be a number between 0 and 1. All
types whose share of the heap is less than threshold will be lumped
together in an “All Others” line rather than being listed
individually.</p>
</div>
<a id="f_object-direct-size"></a>
<div class=definition>
<code>object-direct-size</code> <i>thing</i> <span class="definition-kind">[Function]</span><a id="description_in_f_object-direct-size"></a>
<p>This function returns the size of <I>thing</I> in bytes, including
any headers and alignment overhead.  It does not descend into an object's
components.</p>
</div>
<a id="f_._address-of"></a>
<div class=definition>
<code>%address-of</code> <span class="definition-kind">[Function]</span><a id="description_in_f_._address-of"></a>
<p>This function returns the address of <I>thing</I> as an integer.
If <I>thing</I> is a fixnum, <I>thing</I> is simply returned.</p>
<p>Note that there are types other than fixnums that are represented as
immediate values rather than heap-allocated objects.  On various platforms,
these might include characters and single-flosts, and possibly other values.
The <a href="#f_._address-of"><CODE>%address-of</CODE></a> function will return fairly useless values
for such objects.</p>
<p>The value returned by <a href="#f_._address-of"><CODE>%address-of</CODE></a> is only useful for debugging,
since the GC may run at any time and may move objects around in memory,
thereby changing their addresses.</p>
</div>
</div>
<a id="disassemble"></a>
<H3>Disassemble</H3>
<div class="section">
<a id="v_disassemble-verbose"></a>
<div class=definition>
<code>*disassemble-verbose*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_disassemble-verbose"></a>
<p>When true, the output of <CODE>disassemble</CODE> may include
  platform-dependent additional information.  For instance, on the x86
  ports, the output will include the x86 opcode bytes.</p>
<p>  The default value is <CODE>nil</CODE>.</p>
</div>
</div>
<a id="source-notes"></a>
<H3>Source Notes</H3>
<div class="section">
<p>Source locations are recorded in source-note objects, which have
accessors <a href="#f_source-note-filename"><CODE>source-note-filename</CODE></a>, <a href="#f_source-note-start-pos"><CODE>source-note-start-pos</CODE></a>,
<a href="#f_source-note-end-pos"><CODE>source-note-end-pos</CODE></a>, and <a href="#f_source-note-text"><CODE>source-note-text</CODE></a>.</p>
<p>The start and end positions are file positions and not character positions.
The text will be <CODE>nil</CODE> unless source recording was on at read time.  If
the original source file is still available, <a href="#f_ensure-source-note-text"><CODE>ensure-source-note-text</CODE></a>
will force the missing source text to be read from the file.</p>
<p>Source notes are associated with definitons (via
<CODE>record-source-file</CODE>) and also stored in function objects
(including anonymous and local functions).  The former can be retrieved via
<CODE>find-definition-sources</CODE>, and the latter via
<a href="#f_function-source-note"><CODE>function-source-note</CODE></a>.</p>
<p>Source recording is governed by the variable
<a href="#v_save-source-locations"><CODE>*save-source-locations*</CODE></a>.</p>
<p>PC to source mapping is controlled by <a href="#v_record-pc-mapping"><CODE>*record-pc-mapping*</CODE></a>.</p>
<a id="v_record-source-file"></a>
<div class=definition>
<code>*record-source-file*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_record-source-file"></a>
<p>When true, record source file information for defintions.</p>
</div>
<a id="v_save-source-locations"></a>
<div class=definition>
<code>*save-source-locations*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_save-source-locations"></a>
<p>This variable governs how source location information is recorded.</p>
<dl><dt><CODE>nil</CODE></dt>
<dd><p>Do not record source location information.
Filename information for definitions will still be saved if
<a href="#v_record-source-file"><CODE>*record-source-file*</CODE></a> is true.</p>
</dd>
<dt><CODE>t</CODE></dt>
<dd><p>Store source location information, including
the original source text, for function objects and definitions.</p>
</dd>
<dt><CODE>:no-text</CODE></dt>
<dd><p>Store source location information, but
do not store a copy of the original source text.  This is an optimization
useful for compiling files that are not expected to change.</p>
</dd>
</dl>
</div>
<a id="v_record-pc-mapping"></a>
<div class=definition>
<code>*record-pc-mapping*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_record-pc-mapping"></a>
<p>When true, record PC to source mapping (but only if <a href="#v_save-source-locations"><CODE>*save-source-locations*</CODE></a> is also true).</p>
</div>
<a id="f_function-source-note"></a>
<div class=definition>
<code>function-source-note</code> <i>f</i> <span class="definition-kind">[Function]</span><a id="description_in_f_function-source-note"></a>
<p>Return the source-note object for the function <I>f</I>.</p>
</div>
<a id="f_source-note-filename"></a>
<div class=definition>
<code>source-note-filename</code> <i>source</i> <span class="definition-kind">[Function]</span><a id="description_in_f_source-note-filename"></a>
<p>Return the filename for <I>source</I>.</p>
</div>
<a id="f_source-note-start-pos"></a>
<div class=definition>
<code>source-note-start-pos</code> <i>source-note</i> <span class="definition-kind">[Function]</span><a id="description_in_f_source-note-start-pos"></a>
<p>Return the starting file position (not character position) for the thing
described by <I>source-note</I>.</p>
</div>
<a id="f_source-note-end-pos"></a>
<div class=definition>
<code>source-note-end-pos</code> <i>source-note</i> <span class="definition-kind">[Function]</span><a id="description_in_f_source-note-end-pos"></a>
<p>Return the ending file position (not character position) for the thing
described by <I>source-note</I>.</p>
</div>
<a id="f_source-note-text"></a>
<div class=definition>
<code>source-note-text</code> <i>source-note</i> <code>&amp;optional</code> <i>start</i> <i>end</i> <span class="definition-kind">[Function]</span><a id="description_in_f_source-note-text"></a>
<p>Return the saved source text delimited by <I>start</I> and <I>end</I>.</p>
</div>
<a id="f_ensure-source-note-text"></a>
<div class=definition>
<code>ensure-source-note-text</code> <i>source-note</i> <code>&amp;key</code> <i>if-does-not-exist</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ensure-source-note-text"></a>
<p>Read the source text from the original file if it is not already
present in <I>source-note</I>.</p>
</div>
</div>
</div>
<a id="characters-and-external-formats"></a>
<H2>Characters and External Formats</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#characters">
Characters</a>
<ul style="list-style: none">
</ul>
<li><a href="#external-formats">
External Formats</a>
<ul style="list-style: none">
</ul>
<li><a href="#line-termination-keywords">
Line Termination Keywords</a>
<ul style="list-style: none">
</ul>
<li><a href="#character-encodings">
Character Encodings</a>
<ul style="list-style: none">
<li><a href="#encoding-problems">
Encoding Problems</a>
<li><a href="#byte-order-marks">
Byte Order Marks</a>
<li><a href="#selected-character-encodings">
Selected Character Encodings</a>
<li><a href="#encoding-and-decoding-strings">
Encoding and Decoding Strings</a>
</ul>
</ul>
<p>All characters and strings in Clozure CL fully support Unicode by
    using UTF-32. There is only one <CODE>character</CODE> type and one
    <CODE>string</CODE> type in Clozure CL.  There has been a lot of discussion
    about this decision which can be found by searching the
    openmcl-devel archives at <a href="http://clozure.com/pipermail/openmcl-devel/">http://clozure.com/pipermail/openmcl-devel/</a>
.  Suffice it to say
    that we decided that the simplicity and speed advantages of only
    supporting UTF-32 outweigh the space disadvantage.</p>
<a id="characters"></a>
<H3>Characters</H3>
<div class="section">
<p>There is one <CODE>character</CODE> type in Clozure CL.
    All <CODE>character</CODE>s are <CODE>base-char</CODE>s.  <CODE>char-code-limit</CODE> is now <CODE>#x110000</CODE>, which means that all
    Unicode characters can be directly represented.  As of Unicode
    5.0, only about 100,000 of 1,114,112 possible <CODE>char-code</CODE>s
    are actually defined. The function <CODE>code-char</CODE> knows that
    certain ranges of code values (notably <CODE>#xd800</CODE>-<CODE>#xddff</CODE>) will never be valid character codes and will return <CODE>nil</CODE> for arguments in that range, but may return a non-<CODE>nil</CODE>
    value (an undefined/non-standard <CODE>character</CODE> object) for
    other unassigned code values.</p>
<p>    Clozure CL supports character names of the form <CODE>u+xxxx</CODE>-where
    <CODE>x</CODE> is a sequence of one or more hex digits.  The value of
    the hex digits denotes the code of the character.  The <CODE>+</CODE>
    character is optional, so <CODE>#\u+0020</CODE>, <CODE>#\U0020</CODE>, and
    <CODE>#\U+20</CODE> all refer to the <CODE>#\Space</CODE> character.</p>
<p>    Characters with codes in the range <CODE>#xa0</CODE>-<CODE>#x7ff</CODE> also
    have symbolic names These are the names from the Unicode standard
    with spaces replaced by underscores.  So <CODE>#\Greek_Capital_Letter_Epsilon</CODE> can be used to refer to the
    character whose <CODE>char-code</CODE> is <CODE>#x395</CODE>.  To see the
    complete list of supported character names, look just below the
    definition for <CODE>ccl::register-character-name</CODE> in <CODE>ccl:level-1;l1-reader.lisp</CODE>.</p>
</div>
<a id="external-formats"></a>
<H3>External Formats</H3>
<div class="section">
<p>The standard functions <CODE>open</CODE>, <CODE>load</CODE>, and
    <CODE>compile-file</CODE> all accept an <CODE>:external-format</CODE> keyword
    argument.  The value of <CODE>:external-format</CODE> can be
    <CODE>:default</CODE> (the default value), a line termination
    keyword (see <a href="#line-termination-keywords">Line Termination Keywords</a>), a character
    encoding keyword (see <a href="#character-encodings">Character Encodings</a>), an
    external-format object created using <a href="#f_make-external-format"><CODE>make-external-format</CODE></a>, or a plist with the keys <CODE>:domain</CODE>,
    <CODE>:character-encoding</CODE> and <CODE>:line-termination</CODE>.  If
    <I>argument</I> is a plist, the result of <CODE>(apply
    #'make-external-format <I>argument</I>)</CODE> will be used.</p>
<p>If <CODE>:default</CODE> is specified, then the value of <a href="#v_default-external-format"><CODE>*default-external-format*</CODE></a> is used.  If no line-termination is
    specified, then the value of <a href="#v_default-line-termination"><CODE>*default-line-termination*</CODE></a>
    is used, which defaults to <CODE>:unix</CODE>.  If no character encoding
    is specified, then <CODE>*default-file-character-encoding*</CODE> is
    used for file streams and <CODE>*default-socket-character-encoding*</CODE> is used for socket streams.
    The default, default character encoding is <CODE>nil</CODE> which is a
    synonym for <CODE>:iso-8859-1</CODE>.</p>
<p>    Note that the set of keywords used to denote <CODE>character-encoding</CODE>s
    and the set of keywords used to denote line-termination
    conventions is disjoint: a keyword denotes at most a character
    encoding or a line termination convention, but never both.</p>
<p>    EXTERNAL-FORMATs are objects (structures) with two read-only
    fields that can be accessed via the functions: <CODE>external-format-line-termination</CODE> and <CODE>external-format-character-encoding</CODE>.</p>
<a id="v_default-external-format"></a>
<div class=definition>
<code>ccl:*default-external-format*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_default-external-format"></a>
<p>The value of this variable is used
	        when <CODE>:external-format</CODE> is unspecified or specified
	        as <CODE>:default</CODE>. It can meaningfully be given any value
	        that can be used as an external-format (except for the
	        value <CODE>:default</CODE>.)</p>
<p>	        The initial value of this variable in Clozure CL is
	        <CODE>:unix</CODE>, which is equivalent to
	        <CODE>(:line-termination :unix)</CODE>, among other
	        things.</p>
</div>
<a id="v_default-line-termination"></a>
<div class=definition>
<code>ccl:*default-line-termination*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_default-line-termination"></a>
<p>The value of this variable is used when an
                external-format doesn't specify a line-termination
                convention (or specifies it as <CODE>:default</CODE>.) It can
                meaningfully be given any value that can be used as a
                line termination keyword
                (see <a href="#line-termination-keywords">Line Termination Keywords</a>).</p>
<p>	        The initial value of this variable
	        in Clozure CL is <CODE>:unix</CODE>.</p>
</div>
<a id="f_make-external-format"></a>
<div class=definition>
<code>make-external-format</code> <code>&amp;key</code> <i>domain</i> <i>character-encoding</i> <i>line-termination</i> <span class="definition-kind">[Function]</span><p>Either creates a new external format object, or
	return an existing one with the same specified slot
	values.</p>
<a id="arguments-and-values_in_f_make-external-format"></a>
<dl><dt><I>domain</I></dt>
<dd><p>This is used
	      to indicate where the external format is to be used.
	      Its value can be almost anything.  It defaults to <CODE>NIL</CODE>.  There are two domains that have a pre-defined
	      meaning in Clozure CL: <CODE>:file</CODE> indicates encoding for a
	      file in the file system and <CODE>:socket</CODE> indicates i/o
	      to/from a socket.  The value of <I>domain</I> affects
	      the default values for <I>character-encoding</I> and
	      <I>line-termination</I>.</p>
</dd>
<dt><I>character-encoding</I></dt>
<dd><p>A
	      keyword that specifies the character encoding for the
	      external format. <a href="#character-encodings">Character Encodings</a>.
	      Defaults to <CODE>:default</CODE> which means if <I>domain</I> is <CODE>:file</CODE> use the value of the variable
	      <CODE>*default-file-character-encoding*</CODE> and if
	      <I>domain</I> is <CODE>:socket</CODE>, use the value of the
	      variable <CODE>*default-socket-character-encoding*</CODE>.
	      The initial value of both of these variables is <CODE>NIL</CODE>, which means the <CODE>:iso-8859-1</CODE> encoding.</p>
</dd>
<dt><I>line-termination</I></dt>
<dd><p>A
	      keyword that indicates a line termination keyword
	      <a href="#line-termination-keywords">Line Termination Keywords</a>.  Defaults to
	      <CODE>:default</CODE> which means use the value of the
	      variable <a href="#v_default-line-termination"><CODE>*default-line-termination*</CODE></a>.</p>
</dd>
<dt><I>external-format</I></dt>
<dd><p>An
		     external-format object as described above.</p>
</dd>
</dl>
<a id="description_in_f_make-external-format"></a>
<p>Despite the function's name, it doesn't necessarily
	create a new, unique <CODE>external-format</CODE> object: two calls to
	<a href="#f_make-external-format"><CODE>make-external-format</CODE></a> with the same arguments made in the same
	dynamic environment return the same (eq) object.</p>
</div>
</div>
<a id="line-termination-keywords"></a>
<H3>Line Termination Keywords</H3>
<div class="section">
<p>Line termination keywords indicate which characters are
  used to indicate the end of a line.  On input, the external line
  termination characters are replaced by <CODE>#\Newline</CODE> and on
  output, <CODE>#\Newline</CODE>s are converted to the external line
  termination characters.</p>
<a id="tab_line-termination-keywords"></a>
<table>
<caption>Line Termination Keywords</caption>
<tr><td>keyword
<td>character(s)
</tr>
<tr><td><CODE>:unix</CODE>
<td><CODE>#\Linefeed</CODE>
</tr>
<tr><td><CODE>:macos</CODE>
<td><CODE>#\Return</CODE>
</tr>
<tr><td><CODE>:cr</CODE>
<td><CODE>#\Return</CODE>
</tr>
<tr><td><CODE>:crlf</CODE>
<td><CODE>#\Return #\Linefeed</CODE>
</tr>
<tr><td><CODE>:cp/m</CODE>
<td><CODE>#\Return #\Linefeed</CODE>
</tr>
<tr><td><CODE>:msdos</CODE>
<td><CODE>#\Return #\Linefeed</CODE>
</tr>
<tr><td><CODE>:dos</CODE>
<td><CODE>#\Return #\Linefeed</CODE>
</tr>
<tr><td><CODE>:windows</CODE>
<td><CODE>#\Return #\Linefeed</CODE>
</tr>
<tr><td><CODE>:inferred</CODE>
<td>see below
</tr>
<tr><td><CODE>:unicode</CODE>
<td><CODE>#\Line_Separator</CODE>
</tr>
</table>
<p><CODE>:inferred</CODE> means that a stream's line-termination
  convention is determined by looking at the contents of a file.  It
  is only useful for <CODE>file-stream</CODE>s that're open for
  <CODE>:input</CODE> or <CODE>:io</CODE>.  The first buffer full of data is
  examined, and if a <CODE>#\Return</CODE> character occurs before any
  <CODE>#\Linefeed</CODE> character, then the line termination type is set
  to <CODE>:windows</CODE> if that <CODE>#\Return</CODE> character is immediately
  followed by a <CODE>#\Linefeed</CODE> character and to <CODE>:macos</CODE>
  otherwise.  If a <CODE>#\Return</CODE> character isn't found in the
  buffer or if <CODE>#\Return</CODE> is preceded by <CODE>#\Linefeed</CODE>, the
  file's line terminationt type is set to <CODE>:unix</CODE>.</p>
</div>
<a id="character-encodings"></a>
<H3>Character Encodings</H3>
<div class="section">
<p>Internally, all characters and strings in Clozure CL are in
    UTF-32.  Externally, files or socket streams may encode characters
    in a wide variety of ways.  The International Organization for
    Standardization, widely known as ISO, defines many of these
    character encodings.  Clozure CL implements some of these encodings as
    detailed below.  These encodings are part of the specification of
    external formats (see <a href="#external-formats">External Formats</a>).  When reading
    from a stream, characters are converted from the specified
    external character encoding to UTF-32.  When writing to a stream,
    characters are converted from UTF-32 to the specified character
    encoding.</p>
<p>    Internally, <CODE>character-encoding</CODE>s are objects (structures)
    that are named by character encoding keywords (<CODE>:iso-8859-1</CODE>,
    <CODE>:utf-8</CODE>, etc.).  The structures contain attributes of the encoding
    and functions used to encode/decode external data, but unless
    you are trying to define or debug an encoding, there is little reason
    to know much about the <CODE>character-encoding</CODE> objects and it is
    usually preferable to refer to a character encoding by its name.</p>
<p>The set of character encodings supported by Clozure CL can be
      retrieved by calling <a href="#f_describe-character-encodings"><CODE>describe-character-encodings</CODE></a>.</p>
<a id="f_describe-character-encodings"></a>
<div class=definition>
<code>describe-character-encodings</code> <span class="definition-kind">[Function]</span><a id="description_in_f_describe-character-encodings"></a>
<p>Writes descriptions of all defined character encodings
	  to <CODE>*terminal-io*</CODE>.  These descriptions
	  include the names of the encoding’s aliases and a doc string
	  which briefly describes each encoding’s properties and
	  intended use.</p>
</div>
<a id="encoding-problems"></a>
<H4>Encoding Problems</H4>
<div class="section">
<p>When a character cannot be encoded or decoded according to a
      specified external format, the character in question will be replaced with
      an encoding-specific replacement character.  This will be
      <CODE>#\Replacement_Character</CODE> if the destination external format includes
      such a character; otherwise the replacement character will be <CODE>#\Sub</CODE>.</p>
<p>The presence of a replacement character
      typically indicates that something got lost in
      translation: either data was not encoded properly or there was a
      bug in the decoding process.</p>
</div>
<a id="byte-order-marks"></a>
<H4>Byte Order Marks</H4>
<div class="section">
<p>The endianness of a character encoding is sometimes
      explicit, and sometimes not.  For example,
      <CODE>:utf-16be</CODE> indicates big-endian, but
      <CODE>:utf-16</CODE> does not specify endianness.  A byte
      order mark is a special character that may appear at the
      beginning of a stream of encoded characters to specify the
      endianness of a multi-byte character encoding.  (It may also be
      used with UTF-8 character encodings, where it is simply used to
      indicate that the encoding is UTF-8.)</p>
<p>      Clozure CL writes a byte order mark as the first character
      of a file or socket stream when the endianness of the character
      encoding is not explicit.  Clozure CL also expects a byte order
      mark on input from streams where the endianness is not
      explicit. If a byte order mark is missing from input data, that
      data is assumed to be in big-endian order.</p>
<p>      A byte order mark from a UTF-8 encoded input stream is not
      treated specially and just appears as a normal character from
      the input stream.  It is probably a good idea to skip over this
      character.</p>
</div>
<a id="selected-character-encodings"></a>
<H4>Selected Character Encodings</H4>
<div class="section">
<p>A few commonly-used encodings are described here.  For the
     complete list, call <a href="#f_describe-character-encodings"><CODE>describe-character-encodings</CODE></a>. Most
     encodings have aliases, e.g. the encoding named
     <CODE>:iso-8859-1</CODE> can also be referred to by the
     names <CODE>:latin1</CODE> and <CODE>:ibm819</CODE>,
     among others.  Where possible, the keywordized name of an
     encoding is equivalent to the preferred MIME charset name (and
     the aliases are all registered IANA charset names.)</p>
<dl><dt><CODE>:utf-8</CODE></dt>
<dd><p>An 8-bit, variable-length character encoding in
       which characters with CHAR-CODEs in the range #x00-#x7f can be
       encoded in a single octet; characters with larger code values
       can be encoded in 2 to 4 bytes.</p>
<p>       Clozure CL uses this encoding for <CODE>*terminal-io*</CODE> and for all streams whose
       EXTERNAL-FORMAT isn't explicitly specified.  The default for
       <CODE>*terminal-io*</CODE> can be set via the
       <CODE>-K</CODE> command-line argument (see <a href="#command-line-options">Command Line Options</a>).</p>
</dd>
<dt><CODE>:iso-8859-1</CODE></dt>
<dd><p>An 8-bit, fixed-width character encoding in
       which all character codes map to their Unicode
       equivalents. Intended to support most characters used in most
       Western European languages.</p>
<p>       ISO-8859-1 just covers the first 256 Unicode code
       points, where the first 128 code points are equivalent to
       US-ASCII.  That should be pretty much equivalent to what
       earliers versions of Clozure CL did that only supported 8-bit characters,
       but it may not be optimal for users working in a particular
       locale.</p>
<p>       Aliases: <CODE>:iso_8859-1, :latin1, :l1,
       :ibm819, :cp819, :csisolatin1</CODE></p>
</dd>
<dt><CODE>:us-ascii</CODE></dt>
<dd><p>An 7-bit, fixed-width character encoding in
       which all character codes map to their Unicode
       equivalents. </p>
<p>       Aliases: <CODE>:csascii, :cp637, :ibm637, :us,
       :iso646-us, :ascii, :iso-ir-6</CODE></p>
</dd>
<dt><CODE>:utf-16</CODE></dt>
<dd><p>A 16-bit, variable-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit word and characters with larger codes can be
       encoded in a pair of 16-bit words.  The endianness of the
       encoded data is indicated by the endianness of a
       byte-order-mark character (#u+feff) prepended to the data; in
       the absence of such a character on input, the data is assumed
       to be in big-endian order. Output is written in native
       byte-order with a leading byte-order mark.</p>
</dd>
</dl>
</div>
<a id="encoding-and-decoding-strings"></a>
<H4>Encoding and Decoding Strings</H4>
<div class="section">
<p>Clozure CL provides functions to encode and decode strings to
           and from vectors of type (simple-array (unsigned-byte 8)).</p>
<a id="f_count-characters-in-octet-vector"></a>
<div class=definition>
<code>count-characters-in-octet-vector</code> <i>vector</i> <code>&amp;key</code> <i>start</i> <i>end</i> <i>external-format</i> <span class="definition-kind">[Function]</span><a id="description_in_f_count-characters-in-octet-vector"></a>
<p>Returns the number of characters that would be
    produced by decoding <I>vector</I> (or the subsequence thereof
    delimited by <I>start</I> and <I>end</I>) according to <I>external-format</I>.</p>
</div>
<a id="f_decode-string-from-octets"></a>
<div class=definition>
<code>decode-string-from-octets</code> <i>vector</i> <code>&amp;key</code> <i>start</i> <i>end</i> <i>external-format</i> <i>string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_decode-string-from-octets"></a>
<p>Decodes the octets in <I>vector</I> (or the
    subsequence of it delimited by <I>start</I> and <I>end</I>) into
    a string according to <I>external-format</I>.</p>
<p>    If <I>string</I> is supplied, output will be written into it.  It
    must be large enough to hold the decoded characters.  If <I>string</I> is not supplied, a new string will be allocated to hold
    the decoded characters.</p>
<p>    Returns, as multiple values, the decoded string and the position
    in <I>vector</I> where the decoding ended.</p>
<p>    Sequences of octets in <I>vector</I> that cannot be decoded into
    characters according to <I>external-format</I> will be decoded as
    <CODE>#\Replacement_Character</CODE>.</p>
</div>
<a id="f_encode-string-to-octets"></a>
<div class=definition>
<code>encode-string-to-octets</code> <i>string</i> <code>&amp;key</code> <i>start</i> <i>end</i> <i>external-format</i> <i>use-byte-order-mark</i> <i>vector</i> <i>vector-offset</i> <span class="definition-kind">[Function]</span><a id="description_in_f_encode-string-to-octets"></a>
<p>Encodes <I>string</I> (or the substring of it delimited by
           <I>start</I> and <I>end</I>) into <I>vector</I> according to
           <I>external-format</I>.
           It returns, as multiple values, the vector of octets
           containing the encoded data and an integer that specifies
           the offset into the vector where the encoded data ends.</p>
<p>	   When <I>use-byte-order-mark</I> is true, a byte-order mark
           will be included in the encoded data.</p>
<p>	  If <I>vector</I> is supplied, output will be written to it.
          It must be of type <CODE>(simple-array (unsigned-byte 8))</CODE>
          and be large enough to hold the encoded data.  If it is not
          supplied, the function will allocate a new vector to hold
          the output.</p>
<p>	  If <I>vector-offset</I> is supplied, data will be written
          into the output vector starting at that offset.</p>
<p>	  Characters in <I>string</I> that cannot be encoded into
          <I>external-format</I> will be replaced with an
          encoding-dependent replacement character
          (either <CODE>#\Replacement_Character</CODE> or <CODE>#\Sub)</CODE> before
          being encoded and written into the output vector.</p>
</div>
<a id="f_string-size-in-octets"></a>
<div class=definition>
<code>string-size-in-octets</code> <i>string</i> <code>&amp;key</code> <i>start</i> <i>end</i> <i>external-format</i> <i>use-byte-order-mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_string-size-in-octets"></a>
<p>Returns the number of octets required to encode <I>string</I> (or the substring delimited by <CODE>:start</CODE> and
           <CODE>:end</CODE>) according to <CODE>:external-format</CODE>.</p>
<p>	   When <I>use-byte-order-mark</I> is true, the returned size
           will include the space needed for a byte-order marker.</p>
</div>
</div>
</div>
</div>
<a id="file-system-interface"></a>
<H2>File System Interface</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#pathnames">
Pathnames</a>
<ul style="list-style: none">
<li><a href="#pathname-expansion">
Pathname Expansion</a>
<li><a href="#predefined-logical-hosts">
Predefined Logical Hosts</a>
<li><a href="#pathname-namestrings">
Pathname Namestrings</a>
</ul>
</ul>
<a id="pathnames"></a>
<H3>Pathnames</H3>
<div class="section">
<a id="pathname-expansion"></a>
<H4>Pathname Expansion</H4>
<div class="section">
<p>Leading tilde (~) characters in physical pathname namestrings
        are expanded in the way that most shells do: “<CODE>~user/...</CODE>” can be used to refer to an absolute pathname
        rooted at the home directory of the user named “user”, and
        “<CODE>~/...</CODE>” can be used to refer to an absolute pathname
        rooted at the home directory of the current user.</p>
</div>
<a id="predefined-logical-hosts"></a>
<H4>Predefined Logical Hosts</H4>
<div class="section">
<p>Clozure CL sets up logical pathname translations for two logical
      hosts: <CODE>ccl</CODE> and <CODE>home</CODE>.</p>
<p>      The <CODE>ccl</CODE> logical host is meant to refer to the <CODE>ccl</CODE> directory.  It is used for a variety of purposes by Clozure CL
      including: locating Clozure CL source code, <CODE>require</CODE> and <CODE>provide</CODE>, accessing foreign function information, and the Clozure CL
      build process.  It is set to the value of the environment
      variable <CODE>CCL_DEFAULT_DIRECTORY</CODE>, if that variable
      exists.  Otherwise, it is set to the directory containing the
      heap image file.</p>
<p>      The <CODE>home</CODE> logical host refers to the user's home directory.</p>
</div>
<a id="pathname-namestrings"></a>
<H4>Pathname Namestrings</H4>
<div class="section">
<p>The syntax of namestrings is implementation-defined in Common Lisp.
	Portable programs cannot assume much of anything about
	them.  (See section 19.1.1 of the Common Lisp standard for
	more information.)</p>
<p>	When translating a namestring into a pathname object, most
	implementations seem to follow the convention that a dot
	character in the namestring separates the <CODE>pathname-name</CODE>
	and the <CODE>pathname-type</CODE>.  When there is more than one dot
	in involved, or when dots appear at the beginning or end of
	the namestrings, what to do is less clear: does “<CODE>.emacs</CODE>” describe a pathname whose name is <CODE>nil</CODE> and
	whose type is <CODE>emacs</CODE> or something else?  Similarly,
	given “<CODE>a.b.c</CODE>”, the question is which parts are parsed
	as the pathname name, and which are parsed as the pathname
	type?</p>
<p>	When generating a namestring from a pathname object (as
	happens, for example, when printing a pathname), Clozure CL tries
	to avoid some potential ambiguity by escaping characters that
	might otherwise be used to separate pathname components.  The
	character used to quote or escape the separators is a backlash
	on Unix systems, and a <CODE>#\&gt;</CODE> character on Windows.  So,
	for example, “<CODE>a\\.b.c</CODE>” has name “a.b” and type “c”,
	whereas “a.b\\.c” has name “a” and type “b.c”.</p>
<p>	To get a native namestring suitable for passing to an
	operating system command, use the function <a href="#f_native-translated-namestring"><CODE>native-translated-namestring</CODE></a>.</p>
<a id="f_native-translated-namestring"></a>
<div class=definition>
<code>native-translated-namestring</code> <i>pathname-designator</i> <span class="definition-kind">[Function]</span><a id="description_in_f_native-translated-namestring"></a>
<p>This function returns a namestring that represents a
	  pathname using the native conventions of the operating
	  system.  Any quoting or escaping of special characters will
	  be removed.</p>
<p>	  For example, suppose that <I>p</I> is a pathname made
	  by <CODE>(make-pathname :name "a.b" :type "c")</CODE>.
	  Then, <CODE>(native-translated-namestring p)</CODE> evaluates
	  to "a.b.c".  By contrast, <CODE>(namestring p)</CODE> evaluates
	  to "a\\.b.c".</p>
</div>
<p>Lisp strings are not interchangable with C strings.  Clozure CL
provides a reasonably straightforward way to translate a lisp native
namestring into a C-style string suitable for passing to a foreign
function.</p>
<a id="m_with-filename-cstrs"></a>
<div class=definition>
<code>with-filename-cstrs</code>  (<i></i> <i>{(var</i> <i>value)}*</i> <i></i>) <i>{form}*</i> <span class="definition-kind">[Macro]</span><p>Suitably encode strings to be used as filenames for foreign code.</p>
<a id="description_in_m_with-filename-cstrs"></a>
<p>Executes <I>forms</I> in an environemt in which each
	  <I>var</I> is bound to a stack-allocated foreign
	  pointer which refers to a C-style string suitable for passing
	  to foreign code which expects a filename argument.</p>
<p>          For example, one might use this macro in the following way:</p>
<pre class="source-code">(with-filename-cstrs ((s (native-translated-namestring pathname)))
  (#_unlink s))
</pre>
<p>Various operating systems have different conventions
	  for how they expect native pathname strings to be encoded.
	  Darwin expects then to be decomposed UTF-8.  The Unicode
	  variants to Windows file-handling functions expect UTF-16.
	  Other systems just treat them as opaque byte sequences.
	  This macro ensures that the correct encoding is used,
	  whatever the host operating system.</p>
</div>
<p>On non-Darwin and non-Windows systems, <a href="#m_with-filename-cstrs"><CODE>with-filename-cstrs</CODE></a>
calls <a href="#f_pathname-encoding-name"><CODE>pathname-encoding-name</CODE></a> to determine the encoding to use.</p>
<a id="f_pathname-encoding-name"></a>
<div class=definition>
<code>pathname-encoding-name</code> <span class="definition-kind">[Function]</span><a id="description_in_f_pathname-encoding-name"></a>
<p>Returns the name of the encoding to be used in
<a href="#m_with-filename-cstrs"><CODE>with-filename-cstrs</CODE></a>.  The default is <CODE>nil</CODE>, which means
to use :iso-8859-1.  It may be changed with <CODE>setf</CODE>.</p>
</div>
</div>
</div>
<a id="f_directory"></a>
<div class=definition>
<code>directory</code> <i>pathspec</i> <code>&amp;key</code>  (<i>directories</i> <i>t</i>)  (<i>files</i> <i>t</i>)  (<i>all</i> <i>t</i>)  (<i>directory-pathnames</i> <i>t</i>)  (<i>include-emacs-lockfiles</i> <i>nil</i>) <i>test</i>  (<i>follow-links</i> <i>t</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_directory"></a>
<p>Clozure CL extends the standard function <a href="#f_directory"><CODE>directory</CODE></a> with a number of
keyword arguments:</p>
<dl><dt><CODE>:files</CODE></dt>
<dd><p>If true, includes
                                 regular (non-directory) files in the
                                 output.  Defaults to <CODE>t</CODE>.</p>
</dd>
<dt><CODE>:directories</CODE></dt>
<dd><p>If true, includes directories
                                       in the output.  Defaults to
                                       <CODE>t</CODE>.</p>
</dd>
<dt><CODE>:all</CODE></dt>
<dd><p>If true, includes files and directories
        whose names start with a dot character in the output.  (But
        note that entries named “<CODE>.</CODE>” or “<CODE>..</CODE>” are never
        included.) Defaults to <CODE>t</CODE>.</p>
</dd>
<dt><CODE>:follow-links</CODE></dt>
<dd><p>If true, includes the
        truenames of symbolic or hard links in the output; if false,
        includes the link filenames without attempting to resolve
        them. Defaults to <CODE>t</CODE>.</p>
<p>        Note that legacy HFS alias files are treated as plain files.</p>
</dd>
<dt><CODE>:test</CODE></dt>
<dd><p>A function of one argument (a
        pathname) which should return true if the pathname should be
        included in the output.</p>
</dd>
<dt><CODE>:include-emacs-lockfiles</CODE></dt>
<dd><p>If true, include
        emacs-style lockfiles (symbolic links of the form <CODE>.#something</CODE>) in the output. Defaults to <CODE>nil</CODE>.</p>
</dd>
</dl>
</div>
</div>
<a id="operating-system-interface"></a>
<H2>Operating System Interface</H2>
<div class="section">
<ul style="list-style: none">
</ul>
<a id="f_getenv"></a>
<div class=definition>
<code>getenv</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_getenv"></a>
<p>This function looks up the value of the environment variable
     denoted by the string <I>name</I> and returns its value as a
     string.  If there is no such envionment variable, then <CODE>nil</CODE>
     is returned.</p>
</div>
<a id="f_setenv"></a>
<div class=definition>
<code>setenv</code> <i>name</i> <i>value</i> <span class="definition-kind">[Function]</span><a id="description_in_f_setenv"></a>
<p>This function sets the operating system environment variable
     denoted by the string <I>name</I> to the string <I>value</I>.
     If the environment variable is successfully set, 0 is returned.
     Otherwise, a platform-specific integer error code is returned.</p>
</div>
<a id="f_unsetenv"></a>
<div class=definition>
<code>unsetenv</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_unsetenv"></a>
<p>This function deletes the operating system environment variable
     denoted by the string <I>name</I>.</p>
</div>
<a id="f_wait-for-signal"></a>
<div class=definition>
<code>wait-for-signal</code> <i>sig</i> <i>duration</i> <span class="definition-kind">[Function]</span><a id="description_in_f_wait-for-signal"></a>
<p>Wait for the signal with signal number <I>sig</I> to be received,
     or until <I>duration</I> seconds have elapsed.  If <I>duration</I> is <CODE>nil</CODE>, wait for an indeterminate very long
     time (many years).</p>
<p>     If <I>sig</I> is outside the range of valid signals, or reserved
     by Clozure CL for its own use, an error is signaled.  An error is
     always signaled on Windows systems.</p>
</div>
<a id="f_quit"></a>
<div class=definition>
<code>quit</code> <code>&amp;optional</code>  (<i>exit</i> <i>0</i>) <code>&amp;key</code> <i>error-handler</i> <span class="definition-kind">[Function]</span><a id="description_in_f_quit"></a>
<p>Cleanly exit from lisp.  If <I>exit</I> is a value of type
     <CODE>(signed-byte 32)</CODE>, that value will be passed to the C
     library function <CODE>_exit()</CODE> as the status code.  A value of
     <CODE>nil</CODE> is treated as a zero.</p>
<p>     Alternatively, <I>exit</I> may be a function of no arguments.
     This function will be called instead of <CODE>_exit()</CODE> to exit
     the lisp.</p>
<p>     If the <CODE>:error-handler</CODE> keyword argument is supplied, it
     must be a function of one argument, the condition, that will be
     called if an error occurs when preparing to quit.  The
     error-handler function should exit the lisp.</p>
</div>
<a id="v_command-line-argument-list"></a>
<div class=definition>
<code>*command-line-argument-list*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_command-line-argument-list"></a>
<p>A list of strings decoded from the argument vector passed to the lisp
process (as <CODE>argv[]</CODE>) by the operating system.  The foreign C strings are
assumed to be UTF-8 encoded.</p>
</div>
<a id="v_unprocessed-command-line-arguments"></a>
<div class=definition>
<code>*unprocessed-command-line-arguments*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_unprocessed-command-line-arguments"></a>
<p>A list of strings that denotes the command-line arguments that
remain after the lisp has processed and removed arguments that it
interprets itself.</p>
</div>
</div>
<a id="programming-with-sockets"></a>
<H2>Programming with Sockets</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#overview_in_programming-with-sockets">
Overview</a>
<ul style="list-style: none">
</ul>
<li><a href="#sockets-dictionary">
Sockets Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="overview_in_programming-with-sockets"></a>
<H3>Overview</H3>
<div class="section">
<p>Clozure CL supports the socket abstraction for
      interprocess communication. A socket represents a connection to
      another process, typically (but not necessarily) a TCP/IP
      network connection to a client or server running on some other
      machine on the network.</p>
<p>IPv6 is supported by the :internet6 address family.
      Applications should use the <a href="#f_resolve-address"><CODE>resolve-address</CODE></a>
      function to translate host and port specifications to socket
      addresses.  While host and port numbers can still be dealt with
      separately, it is preferable to use <a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instances to specify socket
      endpoints for unified parsing of string representations and
      printing.</p>
<p>All symbols mentioned in this chapter are exported from
      the CCL package. As of version 0.13, these symbols are
      additionally exported from the OPENMCL-SOCKET package.</p>
<p>Clozure CL supports three types of sockets: TCP sockets, UDP
      sockets, and Unix-domain sockets.  This should be enough for all
      but the most esoteric network situations.  All sockets are
      created by <a href="#f_make-socket"><CODE>make-socket</CODE></a>.  The type of socket
      depends on the arguments to it, as follows:</p>
<dl><dt>tcp-stream</dt>
<dd><p>A buffered bi-directional stream over a TCP/IP connection.
	    tcp-stream is a subclass of stream, and you can read and write to it
	    using all the usual stream functions. Created by (make-socket
	    :address-family :internet :type :stream :connect :active ...) or by
	    (accept-connection ...).</p>
</dd>
<dt>file-socket-stream</dt>
<dd><p>A buffered bi-directional stream over a "UNIX domain"
	    connection. file-socket-stream is a subclass of stream, and you can
	    read and write to it using all the usual stream functions. Created
	    by (make-socket :address-family :file :type :stream :connect :active
	    ...) or by (accept-connection ...),</p>
</dd>
<dt>listener-socket</dt>
<dd><p>A passive socket used to listen for incoming TCP/IP
	    connections on a particular port. A listener-socket is not a stream.
	    It doesn't support I/O. It can only be used to create new
	    tcp-streams by accept-connection. Created by (make-socket :type
	    :stream :connect :passive ...)</p>
</dd>
<dt>file-listener-socket</dt>
<dd><p>A passive socket used to listen for incoming UNIX domain
	    connections named by a file in the local filesystem. A
	    listener-socket is not a stream. It doesn't support I/O. It can
	    only be used to create new file-socket-streams by accept-connection.
	    Created by (make-socket :address-family :file :type :stream :connect
	    :passive ...)</p>
</dd>
<dt>udp-socket</dt>
<dd><p>A socket representing a packet-based UDP/IP connection. A
	    udp-socket supports I/O but it is not a stream. Instead, you must
	    use the special functions send-to and receive-from to read and write
	    to it. Created by (make-socket :type :datagram ...)</p>
</dd>
</dl>
</div>
<a id="sockets-dictionary"></a>
<H3>Sockets Dictionary</H3>
<div class="section">
<a id="f_make-socket"></a>
<div class=definition>
<code>make-socket</code> <code>&amp;key</code> <i>address-family</i> <i>type</i> <i>connect</i> <i>eol</i> <i>format</i> <i>remote-address</i> <i>remote-host</i> <i>remote-port</i> <i>local-address</i> <i>local-host</i> <i>local-port</i> <i>local-filename</i> <i>remote-filename</i> <i>keepalive</i> <i>reuse-address</i> <i>nodelay</i> <i>broadcast</i> <i>linger</i> <i>backlog</i> <i>input-timeout</i> <i>output-timeout</i> <i>connect-timeout</i> <i>auto-close</i> <i>deadline</i> <span class="definition-kind">[Function]</span><p>Make a socket.</p>
<a id="arguments-and-values_in_f_make-socket"></a>
<dl><dt><I>address-family</I></dt>
<dd><p>The address/protocol family of this
		socket. Currently, :internet (the default), meaning
		IPv4, :internet6, meaning IPv6, and :file, referring
		to UNIX domain addresses, are supported.</p>
</dd>
<dt><I>type</I></dt>
<dd><p>One of :stream (the default) to request a
		connection-oriented socket, or :datagram to request a
		connectionless socket. The default is :stream.</p>
</dd>
<dt><I>connect</I></dt>
<dd><p>This argument is only relevant to sockets of type
		:stream. One of :active (the default) to request a :passive
		to request a file or TCP listener socket.</p>
</dd>
<dt><I>eol</I></dt>
<dd><p>This argument is currently ignored (it is accepted for
		compatibility with Franz Allegro).</p>
</dd>
<dt><I>format</I></dt>
<dd><p>One of :text (the default), :binary, or :bivalent.
		This argument is ignored for :stream sockets for now, as
		:stream sockets are currently always bivalent (i.e. they
		support both character and byte I/O). For :datagram sockets,
		this argument is ignored (the format of a datagram socket
		is always :binary).
		</p>
</dd>
<dt><I>remote</I></dt>
<dd><p>For TCP streams, it specifies the socket address
		to connect to, specified as socket-address instance.
		Ignored for listener sockets. For UDP sockets, it can
		be used to specify a default address for subsequent calls
		to send-to or receive-from.</p>
</dd>
<dt><I>remote-host</I></dt>
<dd><p>For TCP streams, it specifies the host to
		connect to (in any format acceptable to resolve-address).
		Ignored for listener sockets. For UDP sockets, it can be
		used to specify a default host for subsequent calls to
		send-to or receive-from.</p>
</dd>
<dt><I>remote-port</I></dt>
<dd><p>For TCP streams, it specifies the port to
		connect to (in any format acceptable to resolve-address).
		Ignored for listener sockets. For UDP sockets, it can be
		used to specify a default port for subsequent calls to for
		subsequent calls to send-to or receive-from.</p>
</dd>
<dt><I>remote-filename</I></dt>
<dd><p>For file-socket streams, it specifies the
		name of a file in the local filesystem (e.g., NOT mounted
		via NFS, AFP, SMB, ...) which names and controls access to a
		UNIX-domain socket.</p>
</dd>
<dt><I>local-address</I></dt>
<dd><p>Allows you to specify a local address for a
		listener or UDP socket, for the case where you want to
		restrict connections to those coming to a specific local
		address for security reasons.</p>
</dd>
<dt><I>local-host</I></dt>
<dd><p>Allows you to specify a local host address for a
		listener or UDP socket, for the case where you want to
		restrict connections to those coming to a specific local
		address for security reasons.</p>
</dd>
<dt><I>local-port</I></dt>
<dd><p>Specify a local port for a socket. Most useful for
		listener sockets, where it is the port on which the socket
		will listen for connections.</p>
</dd>
<dt><I>local-filename</I></dt>
<dd><p>For file-listener-sockets, specifies the name
		of a file in the local filesystem which is used to name a
		UNIX-domain socket. The actual filesystem file should not
		previously exist when the file-listener-socket is created;
		its parent directory should exist and be writable by the
		caller. The file used to name the socket will be deleted
		when the file-listener-socket is closed.</p>
</dd>
<dt><I>keepalive</I></dt>
<dd><p>If true, enables the periodic transmission of
		"keepalive" messages.</p>
</dd>
<dt><I>reuse-address</I></dt>
<dd><p>If true, allows the reuse of local ports in listener
		sockets, overriding some TCP/IP protocol specifications. You
		will need this if you are debugging a server..</p>
</dd>
<dt><I>nodelay</I></dt>
<dd><p>If true, disables Nagle's algorithm, which tries
		to minimize TCP packet fragmentation by introducing
		transmission delays in the absence of replies. Try setting
		this if you are using a protocol which involves sending a
		steady stream of data with no replies and are seeing
		significant degradations in throughput.</p>
</dd>
<dt><I>broadcast</I></dt>
<dd><p>If true, requests permission to broadcast datagrams on
		a UDP socket.</p>
</dd>
<dt><I>linger</I></dt>
<dd><p>If specified and non-nil, should be the number of
		seconds the OS is allowed to wait for data to be pushed
		through when a close is done. Only relevant for TCP sockets.</p>
</dd>
<dt><I>backlog</I></dt>
<dd><p>For a listener socket, specifies the number of
		connections which can be pending but not accepted. The
		default is 5, which is also the maximum on some operating
		systems.</p>
</dd>
<dt><I>input-timeout</I></dt>
<dd><p>The number of seconds before an input operation
		times out.  Must be a real number between zero and one
		million.  If an input operation takes longer than the
		specified number of seconds, an
		<CODE>input-timeout</CODE> error is signalled.
		(see <a href="#stream-timeouts-and-deadlines">Stream Timeouts and Deadlines</a>)</p>
</dd>
<dt><I>output-timeout</I></dt>
<dd><p>The number of seconds before an output operation
		times out.  Must be a real number between zero and one
		million.  If an output operation takes longer than the
		specified number of seconds, an
		<CODE>output-timeout</CODE> error is signalled.
		(see <a href="#stream-timeouts-and-deadlines">Stream Timeouts and Deadlines</a>)</p>
</dd>
<dt><I>connect-timeout</I></dt>
<dd><p>The number of seconds before a connection
		attempt times out. [TODO: what are acceptable values?]
		If a connection attempt takes longer than the
		specified number of seconds, a
		<CODE>socket-error</CODE> is signalled.  This
		can be useful if the specified interval is shorter
		than the interval that the OS's socket layer imposes,
		which is sometimes a minute or two.</p>
</dd>
<dt><I>auto-close</I></dt>
<dd><p>When non-nil, any resulting socket stream will
		be closed when the GC can prove that the stream is
		unreferenced.  This is done via CCL's termination
		mechanism [TODO add xref].</p>
</dd>
<dt><I>deadline</I></dt>
<dd><p>Specifies an absolute time in
		internal-time-units.  If an I/O operation on the
		stream does not complete before the deadline then a
		<CODE>COMMUNICATION-DEADLINE-EXPIRED</CODE>
		error is signalled.  A deadline takes precedence over
		any input/output timeouts that may be set.  (see <a href="#stream-timeouts-and-deadlines">Stream Timeouts and Deadlines</a>)</p>
</dd>
</dl>
<a id="description_in_f_make-socket"></a>
<p>Creates and returns a new socket.  For :passive
	  sockets, the :local-address, :local-port or :local-filename
	  arguments are required, depending on the type of the socket.
	  For :active sockets, either the :remote-address, the
	  :remote-host and :remote-port, or the :remote-filename
	  arguments must be present, depending on the socket
	  type.</p>
</div>
<a id="f_accept-connection"></a>
<div class=definition>
<code>accept-connection</code>  (<i>socket</i> <i>listener-socket</i>) <i>code</i> <code>&amp;key</code>  (<i>wait</i> <i>t</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_accept-connection"></a>
<p>Extracts the first connection on the queue of pending
	  connections for <I>socket</I>, accepts it (i.e. completes
	  the connection startup protocol), and returns a new
	  tcp-stream or file-socket-stream representing the newly
	  established connection. The tcp stream inherits any
	  properties of the listener socket that are relevant
	  (e.g. <CODE>:keepalive</CODE>, <CODE>:nodelay</CODE>, and so forth.) The
	  original listener socket continues to be open listening for
	  more connections, so you can call accept-connection on it
	  again.</p>
<p>If <CODE>:wait</CODE> is <CODE>t</CODE>, and there are no connections
             waiting to be accepted, the function wait until one
             arrives.  Otherwise, <a href="#f_accept-connection"><CODE>accept-connection</CODE></a> will
             return <CODE>nil</CODE> immediately.</p>
</div>
<a id="f_resolve-address"></a>
<div class=definition>
<code>resolve-address</code> <code>&amp;key</code> <i>host</i> <i>port</i> <i>socket-type</i> <i>connect</i> <i>address-family</i> <i>numeric-host-p</i> <i>numeric-service-p</i> <i>singlep</i> <i>errorp</i> <span class="definition-kind">[Function]</span><p>Converts a host and/or port specification to one or more <a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instances.
	  This function uses the getaddrinfo() system function
	  underneath which knows how to translate all standard address
	  and port formats and appropriately orders adresses for hosts
	  with multiple addresses.  It returns the best matching
	  translation or, if the <CODE>:singlep</CODE> is false, all
	  matching translations for the given parameter
	  combination.</p>
<a id="arguments-and-values_in_f_resolve-address"></a>
<dl><dt><I>host</I></dt>
<dd><p>Specification of the host, as a string.  This
		can be either a host name such as
		“clozure.com” or any of the literal address
		forms accepted by getaddrinfo().</p>
</dd>
<dt><I>port</I></dt>
<dd><p>Specification of the port.  This
		can be either a service name such as
		“http” or a port number.</p>
</dd>
<dt><I>socket-type</I></dt>
<dd><p>Service type for port lookups, can be either
		:stream for TCP services or :datagram for UDP.
		Defaults to :stream.</p>
</dd>
<dt><I>connect</I></dt>
<dd><p>Specifies how the returned <a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instances will be used.
		If :active is passed, which is the default, the host
		address will default to the address of the loopback
		interface of the local host if not specified.  When
		:passive is used, the host address will default to the
		wildcard address for the given address family.  This
		parameter has no effect if the :host parameter is
		used.</p>
</dd>
<dt><I>address-family</I></dt>
<dd><p>Specifies the address family that should be
		returned, can be specified as either :internet or
		:internet6.  If it is specified, only addresses of
		that family are returned.</p>
</dd>
<dt><I>numeric-host-p</I></dt>
<dd><p>If this argument is true, no host name lookups
		will be performed for the host address.  A numeric
		address literal must be passed in this case.</p>
</dd>
<dt><I>numeric-port-p</I></dt>
<dd><p>If this argument is true, no service name
		lookups will be performed for the port address.  A
		numeric port number must be passed in this
		case.</p>
</dd>
<dt><I>singlep</I></dt>
<dd><p>If this argument is set to a true value, which
		is the default, only the first matching address is
		returned.  If it is passed as NIL, all matching
		addresses are returned as a list.</p>
</dd>
<dt><I>errorp</I></dt>
<dd><p>If this argument is set to a true value, which
		is the default, an error is signalled if the given
		host and/or port combination did not yield any
		matches.  If it is passed as NIL, the function returns
		NIL if no addresses matched the supplied
		arguments.</p>
</dd>
</dl>
</div>
<a id="f_dotted-to-ipaddr"></a>
<div class=definition>
<code>dotted-to-ipaddr</code> <i>dotted</i> <code>&amp;key</code>  (<i>errorp</i> <i>t</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_dotted-to-ipaddr"></a>
<p>Converts <I>dotted</I>, which should be a dotted quad string such
as “192.168.0.1”, into a integer representation.  If <CODE>:errorp</CODE> is true,
an error is signaled if <I>dotted</I> is invalid.  Otherwise, <CODE>nil</CODE> is
returned.</p>
</div>
<a id="f_ipaddr-to-dotted"></a>
<div class=definition>
<code>ipaddr-to-dotted</code> <i>ipaddr</i> <code>&amp;key</code> <i>values</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ipaddr-to-dotted"></a>
<p>This function converts <I>ipaddr</I>, an integer representing
an IPv4 host, into a dotted quad string.  If <CODE>:values</CODE> is true,
instead of a dotted quad string, it returns the four octets of the
address as multiple values.</p>
</div>
<a id="f_ipaddr-to-hostname"></a>
<div class=definition>
<code>ipaddr-to-hostname</code> <i>ipaddr</i> <code>&amp;key</code> <i>ignore-cache</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ipaddr-to-hostname"></a>
<p>Converts <I>ipaddr</I>, a 32-bit unsigend integer, into
a host name string.  The keyword argument <CODE>:ignore-cache</CODE> is
ignored (it is accepted for compatibility with Franz Allegro CL).</p>
</div>
<a id="f_lookup-hostname"></a>
<div class=definition>
<code>lookup-hostname</code> <i>host-spec</i> <span class="definition-kind">[Function]</span><a id="description_in_f_lookup-hostname"></a>
<p>Converts <I>host-spec</I> into a 32-bit unsigned IPv4
	address.  IPv6-enabled applications should use the <a href="#f_resolve-address"><CODE>resolve-address</CODE></a> function instead.</p>
<p>Acceptable formats for <I>host-spec</I> include a host name
string such as “www.clozure.com”, a dotted address string such as “192.168.0.1”,
or a 32-bit unsigned IPv4 address such as 3232235521.</p>
</div>
<a id="f_lookup-port"></a>
<div class=definition>
<code>lookup-port</code> <i>port</i> <i>protocol</i> <span class="definition-kind">[Function]</span><a id="description_in_f_lookup-port"></a>
<p>Finds the numeric port number for the specified <I>port</I> and
<I>protocol</I>.<I>port</I> can be a string such as “http”, a symbol such as
<CODE>:http</CODE>, or a port number.  Note that strings are case-sensitive.
Symbol names are converted to lower-case before lookup.  Protocol must
be one of “tcp” or “udp”.</p>
</div>
<a id="f_receive-from"></a>
<div class=definition>
<code>receive-from</code>  (<i>socket</i> <i>udp-socket</i>) <i>size</i> <i>code</i> <code>&amp;key</code> <i>buffer</i> <i>extract</i> <i>offset</i> <i>want-socket-address-p</i> <span class="definition-kind">[Function]</span><p>Reads a UDP packet from <I>socket</I>. If no packets are
available, waits for a packet to arrive.</p>
<p>If :want-socket-address-p is <CODE>nil</CODE>, which is the
default, four values are returned:</p>
<ol><li><p>The buffer with the data</p>
<li><p>The number of bytes read</p>
<li><p>The 32-bit unsigned IPv4 address or the 16 byte
	      IPv6 addresss of the sender of the data</p>
<li><p>The port number of the sender of the data</p>
</ol>
<p>If :want-socket-address-p is true, three values are
          returned:</p>
<ol><li><p>The buffer with the data</p>
<li><p>The number of bytes read</p>
<li><p>The <a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instance of
	      the sender of the data.</p>
</ol>
<a id="arguments-and-values_in_f_receive-from"></a>
<dl><dt><I>socket</I></dt>
<dd><p>The socket to read from</p>
</dd>
<dt><I>size</I></dt>
<dd><p>Maximum number of bytes to read. If the packet is
		larger than this, any extra bytes are discarded.</p>
</dd>
<dt><I>buffer</I></dt>
<dd><p>If specified, must be an octet vector
		which will be used to read in the data. If not specified, a
		new buffer will be created (of type determined by
		socket-format).</p>
</dd>
<dt><I>extract</I></dt>
<dd><p>If true, the subsequence of the buffer corresponding
		only to the data read in is extracted and returned as the
		first value. If false (the default) the original buffer is
		returned even if it is only partially filled.</p>
</dd>
<dt><I>offset</I></dt>
<dd><p>Specifies the start offset into the buffer at which
		data is to be stored. The default is 0.</p>
</dd>
<dt><I>want-socket-address-p</I></dt>
<dd><p>Indicates that the address of the sender of the
		data should be returned as a <a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instance rather than as
		separate host and port values.</p>
</dd>
</dl>
</div>
<a id="f_send-to"></a>
<div class=definition>
<code>send-to</code>  (<i>socket</i> <i>udp-socket</i>) <i>buffer</i> <i>size</i> <i>code</i> <code>&amp;key</code> <i>remote</i> <i>remote-host</i> <i>remote-port</i> <i>offset</i> <span class="definition-kind">[Function]</span><p>This function sends a UDP packet over <I>socket</I>.</p>
<a id="arguments-and-values_in_f_send-to"></a>
<dl><dt><I>socket</I></dt>
<dd><p>The socket to write to</p>
</dd>
<dt><I>buffer</I></dt>
<dd><p>A vector containing the data to send. It must be
		an octet vector.</p>
</dd>
<dt><I>size</I></dt>
<dd><p>Number of octets to send</p>
</dd>
<dt><I>remote</I></dt>
<dd><p>The remote address to send the packet to, as a
		<a href="#c_socket-address"><CODE>ccl::socket-address</CODE></a> instance. The
		default is the remote address specified in the call to
		make-socket.</p>
</dd>
<dt><I>remote-host</I></dt>
<dd><p>The host to send the packet to, in any format
		acceptable to lookup-hostname. The default is the remote
		host specified in the call to make-socket.</p>
</dd>
<dt><I>remote-port</I></dt>
<dd><p>The port to send the packet to, in any format
		acceptable to lookup-port. The default is the remote port
		specified in the call to make-socket.</p>
</dd>
<dt><I>offset</I></dt>
<dd><p>The offset in the buffer where the packet data starts</p>
</dd>
</dl>
</div>
<a id="f_shutdown"></a>
<div class=definition>
<code>shutdown</code> <i>socket</i> <code>&amp;key</code> <i>direction</i> <span class="definition-kind">[Function]</span><a id="description_in_f_shutdown"></a>
<p>Shuts down part of a bidirectional connection represented by
        <I>socket</I>. Typcially <I>socket</I> will be a tcp-stream.
        One situation where this can be useful is when you need to
        read responses after sending an end-of-file signal.  The
        keyword argument <CODE>:direction</CODE> may be either
        <CODE>:input</CODE> (to disallow further input) or
        <CODE>:output</CODE> (to disallow further output).</p>
</div>
<a id="f_socket-os-fd"></a>
<div class=definition>
<code>socket-os-fd</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-os-fd"></a>
<p>Returns the native OS's representation of <I>socket</I>, or <CODE>nil</CODE> if the socket is closed. On Unix,
	  this will be a file descriptor. Note that it is rather
	  dangerous to mess around with tcp-stream file descriptors,
	  as there is all sorts of buffering and asynchronous I/O
	  going on above the OS level. listener-socket and udp-socket
	  file descriptors are safer to mess with directly as there is
	  less magic going on.</p>
</div>
<a id="f_remote-host"></a>
<div class=definition>
<code>remote-host</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_remote-host"></a>
<p>Returns the 32-bit unsigned IPv4 address of the remote host,
	  or <CODE>nil</CODE> if <I>socket</I> is not connected.</p>
</div>
<a id="f_remote-port"></a>
<div class=definition>
<code>remote-port</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_remote-port"></a>
<p>Returns the remote port number of <I>socket</I>, or NIL if
<I>socket</I> is not connected.</p>
</div>
<a id="f_local-host"></a>
<div class=definition>
<code>local-host</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_local-host"></a>
<p>Returns 32-bit unsigned IPv4 address or the 16 byte
	  IPv6 address of the local host for <I>socket</I>.</p>
</div>
<a id="f_local-port"></a>
<div class=definition>
<code>local-port</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_local-port"></a>
<p>This function returns the local port number of <I>socket</I>.</p>
</div>
<a id="f_socket-address-family"></a>
<div class=definition>
<code>socket-address-family</code> <i>thing</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-address-family"></a>
<p>Returns :internet, :internet6 or :file, as appropriate for
<I>thing</I>, which should be a socket or socket-address.</p>
</div>
<a id="f_socket-address-host"></a>
<div class=definition>
<code>socket-address-host</code> <i>socket-address</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-address-host"></a>
<p>Returns the host portion of the given <I>socket-address</I>.
       For :internet addresses, this is a 32-bit integer.  For
	  :internet6 addresses, a vector of 16 bytes returned.  For
	  :file addresses, it is the file name string.</p>
</div>
<a id="f_socket-address-port"></a>
<div class=definition>
<code>socket-address-port</code> <i>socket-address</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-address-port"></a>
<p>This function returns the port number of the given <I>socket-address</I>.  This function is available only for
        <CODE>:internet</CODE> and <CODE>:internet6</CODE> socket addresses.</p>
</div>
<a id="f_socket-connect"></a>
<div class=definition>
<code>socket-connect</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-connect"></a>
<p>This function examines <I>socket</I> and returns
<CODE>:active</CODE> for a tcp-stream, <CODE>:passive</CODE> for listener-socket,
and <CODE>nil</CODE> for a udp-socket.</p>
</div>
<a id="f_socket-format"></a>
<div class=definition>
<code>socket-format</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-format"></a>
<p>Returns the format of <I>socket</I> as specified by
	the :format argument to make-socket.</p>
</div>
<a id="f_socket-type"></a>
<div class=definition>
<code>socket-type</code> <i>socket</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-type"></a>
<p>This function returns :stream if <I>socket</I> is a
       tcp-stream or listener-socket.  If the socket is a udp-socket,
<a href="#f_socket-type"><CODE>socket-type</CODE></a> will return :datagram.</p>
</div>
<a id="c_socket-address"></a>
<div class=definition>
<code>socket-address</code> <span class="definition-kind">[Class]</span><a id="description_in_c_socket-address"></a>
<p>This class is a representation of a socket endpoint address.
          Instances of this class are used to encapsulate the host and
          port of an IP socket endpoint or the filename of a file
          socket.  They can be created by applications from a possibly
          symbolic address representation by the <a href="#f_resolve-address"><CODE>resolve-address</CODE></a> function.</p>
</div>
<a id="c_socket-error"></a>
<div class=definition>
<code>socket-error</code> <span class="definition-kind">[Class]</span><a id="description_in_c_socket-error"></a>
<p>The class of OS errors signaled by socket functions (a subclass
of <CODE>simple-error</CODE>.</p>
</div>
<a id="f_socket-error-code"></a>
<div class=definition>
<code>socket-error-code</code> <i>socket-error</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-error-code"></a>
<p>Returns the OS error code contained in <I>socket-error</I>.</p>
</div>
<a id="f_socket-error-identifier"></a>
<div class=definition>
<code>socket-error-identifier</code> <i>socket-error</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-error-identifier"></a>
<p>Returns a symbol representing the socket error code contained
       in <I>socket-error</I>.  It will be one of
       <CODE>:address-in-use</CODE>, <CODE>:connection-aborted</CODE>,
       <CODE>:no-buffer-space</CODE>, <CODE>:connection-timed-out</CODE>,
       <CODE>:connection-refused</CODE>, <CODE>:host-unreachable</CODE>,
       <CODE>:host-down</CODE>, <CODE>:network-down</CODE>,
       <CODE>:address-not-available</CODE>, <CODE>:network-reset</CODE>,
       <CODE>:connection-reset</CODE>, <CODE>:shutdown</CODE>,
       <CODE>:access-denied</CODE>, or <CODE>:unknown</CODE>.</p>
</div>
<a id="f_socket-error-situation"></a>
<div class=definition>
<code>socket-error-situation</code> <i>socket-error</i> <span class="definition-kind">[Function]</span><a id="description_in_f_socket-error-situation"></a>
<p>Returns a string describing the context where the error <I>socket-error</I> happened. On Linux, this is the name of the system call
which returned the error.</p>
</div>
<a id="m_close"></a>
<div class=definition>
<code>close</code>  (<i>socket</i> <i>socket</i>) <i>code</i> <code>&amp;key</code> <i>abort</i> <span class="definition-kind">[Method]</span><a id="description_in_m_close"></a>
<p>Close <I>socket</I>, releasing the operating system resources
associated with it.  Normally, any pending buffered I/O will be
finished up before closing, but if <CODE>:abort</CODE> is <CODE>t</CODE>, any
pending I/O will be aborted.  Note that for listener and udp sockets,
there is never any buffered I/O to clean up, so the value of
<CODE>:abort</CODE> is effectively ignored.</p>
</div>
<a id="m_with-open-socket"></a>
<div class=definition>
<code>with-open-socket</code>  (<i>var</i> <i>.</i> <i>make-socket-args</i>) <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-open-socket"></a>
<p>Executes <I>body</I> with <I>var</I> bound to the result of
       applying <a href="#f_make-socket"><CODE>make-socket</CODE></a> to <I>make-socket-args</I>. The socket gets closed on exit.</p>
</div>
</div>
</div>
<a id="programming-with-threads"></a>
<H2>Programming with Threads</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#threads-overview">
Threads Overview</a>
<ul style="list-style: none">
</ul>
<li><a href="#intentionally-missing-functionality">
(Intentionally) Missing Functionality</a>
<ul style="list-style: none">
</ul>
<li><a href="#implementation-decisions-and-open-questions">
Implementation Decisions and Open Questions</a>
<ul style="list-style: none">
<li><a href="#thread-stack-sizes">
Thread Stack Sizes</a>
<li><a href="#as-of-august-2003">
 As of August 2003:</a>
</ul>
<li><a href="#porting-code-from-the-old-thread-model">
Porting Code from the Old Thread Model</a>
<ul style="list-style: none">
</ul>
<li><a href="#background-terminal-input">
Background Terminal Input</a>
<ul style="list-style: none">
<li><a href="#overview_in_background-terminal-input">
Overview</a>
<li><a href="#an-example">
An example</a>
<li><a href="#a-more-elaborate-example.">
A more elaborate example.</a>
<li><a href="#summary_in_background-terminal-input">
Summary</a>
</ul>
<li><a href="#the-threads-which-clozure-cl-uses-for-its-own-purposes">
The Threads which Clozure CL Uses for Its Own Purposes</a>
<ul style="list-style: none">
</ul>
<li><a href="#threads-dictionary">
Threads Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="threads-overview"></a>
<H3>Threads Overview</H3>
<div class="section">
<p>Clozure CL provides facilities which enable multiple threads
      of execution (<EMPH>threads</EMPH>, sometimes called
      <EMPH>lightweight processes</EMPH> or just
      <EMPH>processes</EMPH>, though the latter term shouldn't
      be confused with the OS's notion of a process) within a lisp
      session. This document describes those facilities and issues
      related to multithreaded programming in Clozure CL.</p>
<p>      Wherever possible, I'll try to use the term "thread" to
      denote a lisp thread, even though many of the functions in the
      API have the word "process" in their name. A
      <EMPH>lisp-process</EMPH> is a lisp object (of type
      CCL:PROCESS) which is used to control and communicate with an
      underlying <EMPH>native thread</EMPH>. Sometimes, the
      distinction between these two (quite different) objects can be
      blurred; other times, it's important to maintain.</p>
<p>      Lisp threads share the same address space, but maintain
      their own execution context (stacks and registers) and their own
      dynamic binding context.</p>
<p>      Traditionally, Clozure CL's threads have been
      <EMPH>cooperatively scheduled</EMPH>: through a
      combination of compiler and runtime support, the currently
      executing lisp thread arranged to be interrupted at certain
      discrete points in its execution (typically on entry to a
      function and at the beginning of any looping construct). This
      interrupt occurred several dozen times per second; in response,
      a handler function might observe that the current thread had
      used up its time slice and another function (<EMPH>the lisp
        scheduler</EMPH>) would be called to find some other thread
      that was in a runnable state, suspend execution of the current
      thread, and resume execution of the newly executed thread.  The
      process of switching contexts between the outgoing and incoming
      threads happened in some mixture of Lisp and assembly language
      code; as far as the OS was concerned, there was one native
      thread running in the Lisp image and its stack pointer and other
      registers just happened to change from time to time.</p>
<p>      Under Clozure CL's cooperative scheduling model, it was
      possible (via the use of the CCL:WITHOUT-INTERRUPTS construct)
      to defer handling of the periodic interrupt that invoked the
      lisp scheduler; it was not uncommon to use WITHOUT-INTERRUPTS to
      gain safe, exclusive access to global data structures. In some
      code (including much of Clozure CL itself) this idiom was very
      common: it was (justifiably) believed to be an efficient way of
      inhibiting the execution of other threads for a short period of
      time.</p>
<p>      The timer interrupt that drove the cooperative scheduler
      was only able to (pseudo-)preempt lisp code: if any thread
      called a blocking OS I/O function, no other thread could be
      scheduled until that thread resumed execution of lisp code. Lisp
      library functions were generally attuned to this constraint, and
      did a complicated mixture of polling and "timed blocking" in an
      attempt to work around it. Needless to say, this code is
      complicated and less efficient than it might be; it meant that
      the lisp was a little busier than it should have been when it
      was "doing nothing" (waiting for I/O to be possible.)</p>
<p>      For a variety of reasons - better utilization of CPU
      resources on single and multiprocessor systems and better
      integration with the OS in general - threads in Clozure CL 0.14 and
      later are <EMPH>preemptively scheduled. </EMPH>In this
      model, lisp threads are native threads and all scheduling
      decisions involving them are made by the OS kernel. (Those
      decisions might involve scheduling multiple lisp threads
      simultaneously on multiple processors on SMP systems.) This
      change has a number of subtle effects:</p>
<ul><li><p>it is possible for two (or more) lisp threads to be
	      executing simultaneously, possibly trying to access and/or
	      modify the same data structures. Such access really should
	      have been coordinated through the use of synchronization
	      objects regardless of the scheduling modeling effect;
	      preemptively scheduled threads increase the chance of things
	      going wrong at the wrong time and do not offer
	      lightweight alternatives to the use of those synchronization
	      objects.</p>
<li><p>even on a single-processor system, a context switch
	      can happen on any instruction boundary. Since (in general)
	      other threads might allocate memory, this means that a GC can
	      effectively take place at any instruction boundary. That's
	      mostly an issue for the compiler and runtime system to be
	      aware of, but it means that certain practices(such as trying
	      to pass the address of a lisp object to foreign code)that
	      were always discouraged are now discouraged
	      ... vehemently.</p>
<li><p>there is no simple and efficient way to "inhibit the
	      scheduler"or otherwise gain exclusive access to the entire
	      CPU.</p>
<li><p>There are a variety of simple and efficient ways
	      to synchronize access to particular data
	      structures.</p>
</ul>
<p>As a broad generalization: code that's been aggressively
      tuned to the constraints of the cooperative scheduler may need
      to be redesigned to work well with the preemptive scheduler (and
      code written to run under Clozure CL's interface to the native
      scheduler may be less portable to other CL implementations, many
      of which offer a cooperative scheduler and an API similar to
      Clozure CL (&lt; 0.14) 's.) At the same time, there's a large
      overlap in functionality in the two scheduling models, and it'll
      hopefully be possible to write interesting and useful MP code
      that's largely independent of the underlying scheduling
      details.</p>
<p>      The keyword :OPENMCL-NATIVE-THREADS is on *FEATURES* in
      0.14 and later and can be used for conditionalization where
      required.</p>
</div>
<a id="intentionally-missing-functionality"></a>
<H3>(Intentionally) Missing Functionality</H3>
<div class="section">
<p>Much of the functionality described above is similar to
      that provided by Clozure CL's cooperative scheduler, some other
      parts of which make no sense in a native threads
      implementation.</p>
<ul><li><p>PROCESS-RUN-REASONS and PROCESS-ARREST-REASONS were
	      SETFable process attributes; each was just a list of
	      arbitrary tokens. A thread was eligible for scheduling
	      (roughly equivalent to being "enabled") if its arrest-reasons
	      list was empty and its run-reasons list was not. I don't
	      think that it's appropriate to encourage a programming style
	      in which otherwise runnable threads are enabled and disabled
	      on a regular basis (it's preferable for threads to wait for
	      some sort of synchronization event to occur if they can't
	      occupy their time productively.)</p>
<li><p>There were a number of primitives for maintaining
	      process queues;that's now the OS's job.</p>
<li><p>Cooperative threads were based on coroutining
	      primitives associated with objects of type
	      STACK-GROUP. STACK-GROUPs no longerexist.</p>
</ul>
</div>
<a id="implementation-decisions-and-open-questions"></a>
<H3>Implementation Decisions and Open Questions</H3>
<div class="section">
<a id="thread-stack-sizes"></a>
<H4>Thread Stack Sizes</H4>
<div class="section">
<p>When you use MAKE-PROCESS to create a thread, you can
        specify a stack size. Clozure CL does not impose a limit on the stack
        size you choose, but there is some evidence that choosing a
        stack size larger than the operating system's limit can cause
        excessive paging activity, at least on some operating
        systems.</p>
<p>        The maximum stack size is operating-system-dependent. You
        can use shell commands to determine what it is on your
        platform. In bash, use "ulimit -s -H" to find the limit; in
        tcsh, use "limit -h s".</p>
<p>        This issue does not affect programs that create threads
        using the default stack size, which you can do either by
        specifying no value for the :stack-size argument to
        MAKE-PROCESS, or by specifying the value
        CCL::*default-control-stack-size*.</p>
<p>        If your program creates threads with a specified stack size,
        and that size is larger than the OS-specified limit, you may want
        to consider reducing the stack size in order to avoid possible
        excessive paging activity.</p>
</div>
<a id="as-of-august-2003"></a>
<H4> As of August 2003:</H4>
<div class="section">
<ul><li><p>It's not clear that exposing
	        PROCESS-SUSPEND/PROCESS-RESUME is a good idea: it's not clear
	        that they offer ways to win, and it's clear that they offer
	        ways to lose.</p>
<li><p>It has traditionally been possible to reset and enable
	        a process that's "exhausted" . (As used here, the
	        term "exhausted" means that the process's initial function
	        has run and returned and the underlying native thread has
	        been deallocated.) One of the principal uses of PROCESS-RESET
	        is to "recycle" threads; enabling an exhausted process
	        involves creating a new native thread (and stacks and
	        synchronization objects and ...),and this is the sort of
	        overhead that such a recycling scheme is seeking to avoid. It
	        might be worth trying to tighten things up and declare that
	        it's an error to apply PROCESS-ENABLE to an exhausted thread
	        (and to make PROCESS-ENABLE detect this error.)</p>
<li><p>When native threads that aren't created by Clozure CL
	        first call into lisp, a "foreign process" is created, and
	        that process is given its own set of initial bindings and set
	        up to look mostly like a process that had been created by
	        MAKE-PROCESS. The life cycle of a foreign process is
	        certainly different from that of a lisp-created one: it
	        doesn't make sense to reset/preset/enable a foreign process,
	        and attempts to perform these operations should be
	        detected and treated as errors.</p>
</ul>
</div>
</div>
<a id="porting-code-from-the-old-thread-model"></a>
<H3>Porting Code from the Old Thread Model</H3>
<div class="section">
<p>Older versions of Clozure CL used what are often called
      "user-mode threads", a less versatile threading model which does
      not require specific support from the operating system.  This
      section discusses how to port code which was written for that
      mode.</p>
<p>      It's hard to give step-by-step instructions; there are certainly
      a few things that one should look at carefully:</p>
<ul><li><p>It's wise to be suspicious of most uses
	      of WITHOUT-INTERRUPTS; there may be exceptions, but
	      WITHOUT-INTERRUPTS is often used as shorthand for
	      WITH-APPROPRIATE-LOCKING. Determining what type of locking
	      is appropriate and writing the code to implement it is
	      likely to be straightforward and simple most of the
	      time.</p>
<li><p>I've only seen one case where a process's "run reasons"
	      were used to communicate information as well as to control
	      execution; I don't think that this is a common idiom, but may
	      be mistaken about that.
	    </p>
<li><p>It's certainly possible that programs written
	      for cooperatively scheduled lisps that have run reliably for
	      a long time have done so by accident: resource-contention
	      issues tend to be timing-sensitive, and decoupling thread
	      scheduling from lisp program execution affects timing. I know
	      that there is or was code in both Clozure CL and commercial MCL
	      that was written under the explicit assumption that certain
	      sequences of open-coded operations were uninterruptable; it's
	      certainly possible that the same assumptions have been made
	      (explicitly or otherwise) by application developers.</p>
</ul>
</div>
<a id="background-terminal-input"></a>
<H3>Background Terminal Input</H3>
<div class="section">
<a id="overview_in_background-terminal-input"></a>
<H4>Overview</H4>
<div class="section">
<p>
	    Unless and until Clozure CL provides alternatives (via window
	    streams, telnet streams, or some other mechanism) all lisp
	    processes share a common *TERMINAL-IO* stream (and therefore
	    share *DEBUG-IO*, *QUERY-IO*, and other standard and
	    internal interactive streams.)</p>
<p>	    It's anticipated that most lisp processes other than
	    the "Initial" process run mostly in the background. If a
	    background process writes to the output side of
	    *TERMINAL-IO*, that may be a little messy and a little
	    confusing to the user, but it shouldn't really be
	    catastrophic. All I/O to Clozure CL's buffered streams goes
	    thru a locking mechanism that prevents the worst kinds of
	    resource-contention problems.</p>
<p>	    Although the problems associated with terminal output
	    from multiple processes may be mostly cosmetic, the question
	    of which process receives input from the terminal is likely
	    to be a great deal more important. The stream locking
	    mechanisms can make a confusing situation even worse:
	    competing processes may "steal" terminal input from each
	    other unless locks are held longer than they otherwise need
	    to be, and locks can be held longer than they need to be (as
	    when a process is merely waiting for input to become
	    available on an underlying file descriptor).</p>
<p>	    Even if background processes rarely need to
	    intentionally read input from the terminal, they may still
	    need to do so in response to errors or other unanticipated
	    situations. There are tradeoffs involved in any solution to
	    this problem. The protocol described below allows background
	    processes which follow it to reliably prompt for and receive
	    terminal input. Background processes which attempt to
	    receive terminal input without following this protocol will
	    likely hang indefinitely while attempting to do so. That's
	    certainly a harsh tradeoff, but since attempts to read
	    terminal input without following this protocol only worked
	    some of the time anyway, it doesn't seem to be an
	    unreasonable one.</p>
<p>	    In the solution described here (and introduced in
	    Clozure CL 0.9), the internal stream used to provide terminal
	    input is always locked by some process (the "owning"
	    process.) The initial process (the process that typically
	    runs the read-eval-print loop) owns that stream when it's
	    first created. By using the macro WITH-TERMINAL-INPUT,
	    background processes can temporarily obtain ownership of the
	    terminal and relinquish ownership to the previous owner when
	    they're done with it.</p>
<p>	    In Clozure CL, BREAK, ERROR, CERROR, Y-OR-N-P,
	    YES-OR-NO-P, and CCL:GET-STRING- FROM-USER are all defined
	    in terms of WITH-TERMINAL-INPUT, as are the :TTY
	    user-interfaces to STEP and INSPECT.</p>
</div>
<a id="an-example"></a>
<H4>An example</H4>
<div class="section">
<pre class="source-code"><p>
? Welcome to Clozure CL Version (Beta: linux) 0.9!
?</p>
<p>? (process-run-function "sleeper" #'(lambda () (sleep 5) (break "broken")))
#&lt;PROCESS sleeper(1) [Enabled] #x3063B33E&gt;</p>
<p>?
;;
;; Process sleeper(1) needs access to terminal input.
;;
      </p>
</pre>
<p>This example was run under ILISP; ILISP often gets confused if one
	    tries to enter input and "point" doesn't follow a prompt.
	    Entering a "simple" expression at this point gets it back in
	    synch; that's otherwise not relevant to this example.</p>
<pre class="source-code">
()
NIL
? (:y 1)
;;
;; process sleeper(1) now controls terminal input
;;
&gt; Break in process sleeper(1): broken
&gt; While executing: #&lt;Anonymous Function #x3063B276&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt; :b
(30C38E30) : 0 "Anonymous Function #x3063B276" 52
(30C38E40) : 1 "Anonymous Function #x304984A6" 376
(30C38E90) : 2 "RUN-PROCESS-INITIAL-FORM" 340
(30C38EE0) : 3 "%RUN-STACK-GROUP-FUNCTION" 768
1 &gt; :pop
;;
;; control of terminal input restored to process Initial(0)
;;
?
      
</pre>
</div>
<a id="a-more-elaborate-example."></a>
<H4>A more elaborate example.</H4>
<div class="section">
<p>If a background process ("A") needs access to the terminal
	    input stream and that stream is owned by another background process
	    ("B"), process "A" announces that fact, then waits until
	    the initial process regains control.</p>
<pre class="source-code"><p>
? Welcome to Clozure CL Version (Beta: linux) 0.9!
?</p>
<p>? (process-run-function "sleep-60" #'(lambda () (sleep 60) (break "Huh?")))
#&lt;PROCESS sleep-60(1) [Enabled] #x3063BF26&gt;</p>
<p>? (process-run-function "sleep-5" #'(lambda () (sleep 5) (break "quicker")))
#&lt;PROCESS sleep-5(2) [Enabled] #x3063D0A6&gt;</p>
<p>?       ;;
;; Process sleep-5(2) needs access to terminal input.
;;
()
NIL</p>
<p>? (:y 2)
;;
;; process sleep-5(2) now controls terminal input
;;
&gt; Break in process sleep-5(2): quicker
&gt; While executing: #x3063CFDE&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt;     ;; Process sleep-60(1) will need terminal access when
;; the initial process regains control of it.
;;
()
NIL
1 &gt; :pop
;;
;; Process sleep-60(1) needs access to terminal input.
;;
;;
;; control of terminal input restored to process Initial(0)
;;</p>
<p>? (:y 1)
;;
;; process sleep-60(1) now controls terminal input
;;
&gt; Break in process sleep-60(1): Huh?
&gt; While executing: #x3063BE5E&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt; :pop
;;
;; control of terminal input restored to process Initial(0)
;;</p>
<p>?
      </p>
</pre>
</div>
<a id="summary_in_background-terminal-input"></a>
<H4>Summary</H4>
<div class="section">
<p>This scheme is certainly not bulletproof: imaginative
	    use of PROCESS-INTERRUPT and similar functions might be able
	    to defeat it and deadlock the lisp, and any scenario where
	    several background processes are clamoring for access to the
	    shared terminal input stream at the same time is likely to be
	    confusing and chaotic. (An alternate scheme, where the input
	    focus was magically granted to whatever thread the user was
	    thinking about, was considered and rejected due to technical
	    limitations.)</p>
<p>	    The longer-term fix would probably involve using network or
	    window-system streams to give each process unique instances of
	    *TERMINAL-IO*.</p>
<p>        Existing code that attempts to read from *TERMINAL-IO*
        from a background process will need to be changed to use
        WITH-TERMINAL-INPUT.  Since that code was probably not working
        reliably in previous versions of Clozure CL, this requirement
        doesn't seem to be too onerous.</p>
<p>        Note that WITH-TERMINAL-INPUT both requests ownership of
        the terminal input stream and promises to restore that
        ownership to the initial process when it's done with it. An ad
        hoc use of READ or READ-CHAR doesn't make this promise; this
        is the rationale for the restriction on the :Y command.</p>
</div>
</div>
<a id="the-threads-which-clozure-cl-uses-for-its-own-purposes"></a>
<H3>The Threads which Clozure CL Uses for Its Own Purposes</H3>
<div class="section">
<p>
      In the "tty world", Clozure CL starts out with 2 lisp-level threads:</p>
<pre class="source-code">
? :proc
1 : -&gt; listener     [Active]
0 :    Initial      [Active]
    
</pre>
<p>If you look at a running Clozure CL with a debugging tool,
      such as GDB, or Apple's Thread Viewer.app, you'll see an
      additional kernel-level thread on Darwin; this is used by the
      Mach exception-handling mechanism.</p>
<p>      The initial thread, conveniently named "initial", is the
      one that was created by the operating system when it launched
      Clozure CL.  It maps the heap image into memory, does some
      Lisp-level initialization, and, when the Cocoa IDE isn't being
      used, creates the thread "listener", which runs the top-level
      loop that reads input, evaluates it, and prints the
      result.</p>
<p>      After the listener thread is created, the initial thread
      does "housekeeping": it sits in a loop, sleeping most of the
      time and waking up occasionally to do "periodic tasks".  These
      tasks include forcing output on specified interactive streams,
      checking for and handling control-C interrupts, etc.  Currently,
      those tasks also include polling for the exit status of external
      processes and handling some kinds of I/O to and from those
      processes.</p>
<p>      In this environment, the initial thread does these
      "housekeeping" activities as necessary, until
      <CODE>ccl:quit</CODE> is called;
      <CODE>quit</CODE>ting interrupts the initial thread, which
      then ends all other threads in as orderly a fashion as possible
      and calls the C function <CODE>#_exit</CODE>.</p>
<p>      The short-term plan is to handle each external-process in
      a dedicated thread; the worst-case behavior of the current
      scheme can involve busy-waiting and excessive CPU utilization
      while waiting for an external process to terminate in some
      cases.</p>
<p>      The Cocoa features use more threads.  Adding a Cocoa
      listener creates two threads:</p>
<pre class="source-code">
      ? :proc
      3 : -&gt; Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    
</pre>
<p>The Cocoa event loop has to run in the initial thread;
      when the event loop starts up, it creates a new thread to do the
      "housekeeping" tasks which the initial thread would do in the
      terminal-only mode.  The initial thread then becomes the one to
      receive all Cocoa events from the window server; it's the only
      thread which can.</p>
<p>      It also creates one "Listener" (capital-L) thread for each
      listener window, with a lifetime that lasts as long as the
      thread does.  So, if you open a second listener, you'll see five
      threads all together:</p>
<pre class="source-code">
      ? :proc
      4 : -&gt; Listener-2   [Active]
      3 :    Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    
</pre>
<p>Unix signals, such as SIGINT (control-C), invoke a handler
      installed by the Lisp kernel.  Although the OS doesn't make any
      specific guarantee about which thread will receive the signal,
      in practice, it seems to be the initial thread.  The handler
      just sets a flag and returns; the housekeeping thread (which may
      be the initial thread, if Cocoa's not being used) will check for
      the flag and take whatever action is appropriate to the
      signal.</p>
<p>      In the case of SIGINT, the action is to enter a break
      loop, by calling on the thread being interrupted.  When there's
      more than one Lisp listener active, it's not always clear what
      thread that should be, since it really depends on the user's
      intentions, which there's no way to divine programmatically.  To
      make its best guess, the handler first checks whether the value
      of <CODE>ccl:*interactive-abort-process*</CODE> is a
      thread, and, if so, uses it.  If that fails, it chooses the
      thread which currently "owns" the default terminal input stream;
      see .</p>
<p>      In the bleeding-edge version of the Cocoa support which is
      based on Hemlock, an Emacs-like editor, each editor window has a
      dedicated thread associated with it.  When a keypress event
      comes in which affects that specific window the initial thread
      sends it to the window's dedicated thread.  The dedicated thread
      is responsible for trying to interpret keypresses as Hemlock
      commands, applying those commands to the active buffer; it
      repeats this in a loop, until the window closes.  The initial
      thread handles all other events, such as mouse clicks and
      drags.</p>
<p>      This thread-per-window scheme makes many things simpler,
      including the process of entering a "recursive command loop" in
      commands like "Incremental Search Forward", etc.  (It might be
      possible to handle all Hemlock commands in the Cocoa event
      thread, but these "recursive command loops" would have to
      maintain a lot of context/state information; threads are a
      straightforward way of maintaining that information.)</p>
<p>      Currently (August 2004), when a dedicated thread needs to
      alter the contents of the buffer or the selection, it does so by
      invoking methods in the initial thread, for synchronization
      purposes, but this is probably overkill and will likely be
      replaced by a more efficient scheme in the future.</p>
<p>      The per-window thread could probably take more
      responsibility for drawing and handling the screen than it
      currently does; -something- needs to be done to buffer screen
      updates a bit better in some cases: you don't need to see
      everything that happens during something like indentation; you
      do need to see the results...</p>
<p>      When Hemlock is being used, listener windows are editor
      windows, so in addition to each "Listener" thread, you should
      also see a thread which handles Hemlock command
      processing.</p>
<p>      The Cocoa runtime may make additional threads in certain
      special situations; these threads usually don't run lisp code,
      and rarely if ever run much of it.</p>
</div>
<a id="threads-dictionary"></a>
<H3>Threads Dictionary</H3>
<div class="section">
<a id="f_all-processes"></a>
<div class=definition>
<code>all-processes</code> <span class="definition-kind">[Function]</span><a id="description_in_f_all-processes"></a>
<p>Returns a fresh list of all lisp processes (threads) known to
       Clozure CL as of the precise instant it's called.  Since other
       threads can create and kill threads at any time, there's
       no way to get a perfectly accurate list of all threads.</p>
</div>
<a id="f_make-process"></a>
<div class=definition>
<code>make-process</code> <i>name</i> <code>&amp;key</code> <i>persistent</i> <i>priority</i> <i>class</i> <i>initargs</i> <i>stack-size</i> <i>vstack-size</i> <i>tstack-size</i> <i>initial-bindings</i> <i>use-standard-initial-bindings</i> <span class="definition-kind">[Function]</span><p>Creates and returns a new process.</p>
<a id="arguments-and-values_in_f_make-process"></a>
<dl><dt><I>name</I></dt>
<dd><p>a string, used to identify the process.</p>
</dd>
<dt><I>persistent</I></dt>
<dd><p>if true, requests that information about the process
		        be retained by SAVE-APPLICATION so that an equivalent
		        process can be restarted when a saved image is run.  The
		        default is nil.</p>
</dd>
<dt><I>priority</I></dt>
<dd><p>ignored.  It
		        shouldn't be ignored of course, but there are
		        complications on some platforms.  The default is 0.</p>
</dd>
<dt><I>class</I></dt>
<dd><p>the class of process object to create;
		        should be a subclass of CCL:PROCESS.  The default is
		        CCL:PROCESS.</p>
</dd>
<dt><I>initargs</I></dt>
<dd><p>Any additional initargs to pass to MAKE-INSTANCE. The default is ().</p>
</dd>
<dt><I>stack-size</I></dt>
<dd><p>the size, in bytes, of the newly-created process's
		        control stack; used for foreign function calls and to save
		        function return address context.  The default is
		        CCL:*DEFAULT-CONTROL-STACK-SIZE*.</p>
</dd>
<dt><I>vstack-size</I></dt>
<dd><p>the size, in bytes, of the newly-created process's
		        value stack; used for lisp function arguments, local
		        variables, and other stack-allocated lisp objects.
		        The default is CCL:*DEFAULT-VALUE-STACK-SIZE*.</p>
</dd>
<dt><I>tstack-size</I></dt>
<dd><p>the size, in bytes, of the newly-created process's
		        temp stack; used for the allocation of dynamic-extent
		        objects.  The default is CCL:*DEFAULT-TEMP-STACK-SIZE*.</p>
</dd>
<dt><I>use-standard-initial-bindings</I></dt>
<dd><p>when true, the global "standard initial
		        bindings" are put into effect in the new thread before. See
		        DEF-STANDARD-INITIAL-BINDING.  "standard" initial bindings
		        are put into effect before any bindings specified by
		        :initial-bindings are.  The default is t.</p>
<p>                       <EMPH>This option is deprecated: the correct
                      behavior of many Clozure CL components depends on thread-local
                      bindings of many special variables being in effect.</EMPH></p>
</dd>
<dt><I>initial-bindings</I></dt>
<dd><p>an alist of (<I>symbol</I> .
		        <I>valueform</I>) pairs, which can be
		        used to initialize special variable bindings in the new
		        thread. Each <I>valueform</I> is used to
		        compute the value of a new binding of
		        <I>symbol</I> in the execution environment of
		        the newly-created thread.  The default is nil.</p>
</dd>
<dt><I>process</I></dt>
<dd><p>the newly-created process.</p>
</dd>
</dl>
<a id="description_in_f_make-process"></a>
<p>Creates and returns a new lisp process (thread) with the
	      specified attributes. <I>process</I> will not begin
	      execution immediately; it will need to be
	      <EMPH>preset</EMPH> (given
	      an initial function to run, as by
	      <a href="#f_process-preset"><CODE>process-preset</CODE></a>) and
	      <EMPH>enabled</EMPH>
	      (allowed to execute, as by <a href="#f_process-enable"><CODE>process-enable</CODE></a>)
	      before it's able to actually do anything.</p>
<p>If <I>valueform</I> is a function, it is
	      called, with no arguments, in the execution environment of the
	      newly-created thread; the primary value it returns is used for
	      the binding of the corresponding <I>symbol</I>.</p>
<p>	      Otherwise, <I>valueform</I> is evaluated in the
	      execution
	      environment of the newly-created thread, and the resulting value
	      is used.</p>
<a id="see-also_in_f_make-process"></a>
<p><a href="#f_process-preset"><CODE>process-preset</CODE></a>, <a href="#f_process-enable"><CODE>process-enable</CODE></a>, <a href="#f_process-run-function"><CODE>process-run-function</CODE></a></p>
</div>
<a id="f_process-suspend"></a>
<div class=definition>
<code>process-suspend</code> <i>process</i> <span class="definition-kind">[Function]</span><p>Suspends a specified process.</p>
<a id="arguments-and-values_in_f_process-suspend"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>result</I></dt>
<dd><p>T if <I>process</I> had been runnable
		        and is now suspended; NIL otherwise.  That is, T if
		        <I>process</I>'s
		        <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a>
		        transitioned from 0 to 1.</p>
</dd>
</dl>
<a id="description_in_f_process-suspend"></a>
<p>Suspends <I>process</I>, preventing it from
	      running, and stopping it if it was already running. This is a fairly
	      expensive operation, because it involves a few
	      calls to the OS.  It also risks creating deadlock if used
	      improperly, for instance, if the process being suspended owns a
	      lock or other resource which another process will wait for.</p>
<p>
	      Each
	      call to <a href="#f_process-suspend"><CODE>process-suspend</CODE></a> must be reversed by
	      a matching call to <a href="#f_process-resume"><CODE>process-resume</CODE></a>
	      before <I>process</I> is able to run.  What
	      <a href="#f_process-suspend"><CODE>process-suspend</CODE></a> actually does is increment
	      the <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a> of
	      <I>process</I>.
	    </p>
<p>A process can't suspend itself, though this once
	    worked and this documentation claimed has claimed that it
	    did.</p>
<a id="see-also_in_f_process-suspend"></a>
<p><a href="#f_process-resume"><CODE>process-resume</CODE></a>, <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a></p>
<a id="notes_in_f_process-suspend"></a>
<p><a href="#f_process-suspend"><CODE>process-suspend</CODE></a> was previously called
	      <CODE>process-disable</CODE>.
	      <a href="#f_process-enable"><CODE>process-enable</CODE></a>
	      now names a function for which there is no
	      obvious inverse, so <CODE>process-disable</CODE>
	      is no longer
	      defined.</p>
</div>
<a id="f_process-resume"></a>
<div class=definition>
<code>process-resume</code> <i>process</i> <span class="definition-kind">[Function]</span><p>Resumes a specified process which had previously
	      been suspended by process-suspend.</p>
<a id="arguments-and-values_in_f_process-resume"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>result</I></dt>
<dd><p>T if <I>process</I> had been suspended
		        and is now runnable; NIL otherwise.  That is, T if
		        <I>process</I>'s
		        <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a>
		        transitioned from  to 0.
		      </p>
</dd>
</dl>
<a id="description_in_f_process-resume"></a>
<p>Undoes the effect of a previous call to
	      <a href="#f_process-suspend"><CODE>process-suspend</CODE></a>; if
	      all such calls are undone, makes the process runnable. Has no
	      effect if the process is not suspended.  What
	      <a href="#f_process-resume"><CODE>process-resume</CODE></a> actually does is decrement
	      the <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a> of
	      <I>process</I>, to a minimum of 0.</p>
<a id="see-also_in_f_process-resume"></a>
<p><a href="#f_process-suspend"><CODE>process-suspend</CODE></a>, <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a></p>
<a id="notes_in_f_process-resume"></a>
<p>
	      This was previously called PROCESS-ENABLE;
	      <a href="#f_process-enable"><CODE>process-enable</CODE></a> now does something slightly
	      different.
	    </p>
</div>
<a id="f_process-suspend-count"></a>
<div class=definition>
<code>process-suspend-count</code> <i>process</i> <span class="definition-kind">[Function]</span><p>Returns the number of currently-pending suspensions
	      applicable to a given process.</p>
<a id="arguments-and-values_in_f_process-suspend-count"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>result</I></dt>
<dd><p>The number of "outstanding"
		        <a href="#f_process-suspend"><CODE>process-suspend</CODE></a> calls on
		        <I>process</I>, or NIL if
		        <I>process</I> has expired.
		      </p>
</dd>
</dl>
<a id="description_in_f_process-suspend-count"></a>
<p>An "outstanding" <a href="#f_process-suspend"><CODE>process-suspend</CODE></a> call
	      is one which has not yet been reversed by a call to
	      <a href="#f_process-resume"><CODE>process-resume</CODE></a>.  A process expires when
	      its initial function returns, although it may later be
	      reset.</p>
<p>A process is <EMPH>runnable</EMPH> when it has a
	      <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a> of 0, has been
	      preset as by <a href="#f_process-preset"><CODE>process-preset</CODE></a>, and has been
	      enabled as by <a href="#f_process-enable"><CODE>process-enable</CODE></a>.  Newly-created
	      processes have a <a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a> of
	      0.</p>
<a id="see-also_in_f_process-suspend-count"></a>
<p><a href="#f_process-suspend"><CODE>process-suspend</CODE></a>, <a href="#f_process-resume"><CODE>process-resume</CODE></a></p>
</div>
<a id="f_process-preset"></a>
<div class=definition>
<code>process-preset</code> <i>process</i> <i>function</i> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Function]</span><p>Sets the initial function and arguments of a specified
	      process.</p>
<a id="arguments-and-values_in_f_process-preset"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>function</I></dt>
<dd><p>a function, designated by itself or by a symbol
		        which names it.
		      </p>
</dd>
<dt><I>args</I></dt>
<dd><p>a list of values, appropriate as arguments to
		        <I>function</I>.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>undefined.</p>
</dd>
</dl>
<a id="description_in_f_process-preset"></a>
<p>Typically used to initialize a newly-created or newly-reset
	      process, setting things up so that when <I>process</I>
	      becomes enabled, it will begin execution by
	      applying <I>function</I> to <I>args</I>.
	      <a href="#f_process-preset"><CODE>process-preset</CODE></a> does not enable
	      <I>process</I>,
	      although a process must be <a href="#f_process-preset"><CODE>process-preset</CODE></a>
	      before it can be enabled.  Processes are normally enabled by
	      <a href="#f_process-enable"><CODE>process-enable</CODE></a>.
	    </p>
<a id="see-also_in_f_process-preset"></a>
<p><a href="#f_make-process"><CODE>make-process</CODE></a>, <a href="#f_process-enable"><CODE>process-enable</CODE></a>, <a href="#f_process-run-function"><CODE>process-run-function</CODE></a></p>
</div>
<a id="f_process-enable"></a>
<div class=definition>
<code>process-enable</code> <i>process</i> <code>&amp;optional</code> <i>timeout</i> <span class="definition-kind">[Function]</span><p>Begins executing the initial function of a specified
	      process.</p>
<a id="arguments-and-values_in_f_process-enable"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>timeout</I></dt>
<dd><p>a time interval in seconds.  May be any
		        non-negative real number the <CODE>floor</CODE> of
		        which fits in 32 bits.  The default is 1.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>undefined.</p>
</dd>
</dl>
<a id="description_in_f_process-enable"></a>
<p>Tries to begin the execution of <I>process</I>.
	      An error is signaled if <I>process</I> has never
	      been <a href="#f_process-preset"><CODE>process-preset</CODE></a>.  Otherwise,
	      <I>process</I> invokes its initial function.
	    </p>
<p><a href="#f_process-enable"><CODE>process-enable</CODE></a> attempts to
	      synchronize with <I>process</I>, which is presumed
	      to be reset or in the act of resetting itself.  If this attempt
	      is not successful within the time interval specified by
	      <I>timeout</I>, a continuable error is signaled,
	      which offers the opportunity to continue waiting.</p>
<p>A process cannot meaningfully attempt to enable itself.</p>
<a id="see-also_in_f_process-enable"></a>
<p><a href="#f_make-process"><CODE>make-process</CODE></a>, <a href="#f_process-preset"><CODE>process-preset</CODE></a>, <a href="#f_process-run-function"><CODE>process-run-function</CODE></a></p>
<a id="notes_in_f_process-enable"></a>
<p>It would be nice to have more discussion of what it means
	      to synchronize with the process.</p>
</div>
<a id="f_process-run-function"></a>
<div class=definition>
<code>process-run-function</code> <i>process-specifier</i> <i>function</i> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Function]</span><p>Creates a process, presets it, and enables it.
	    </p>
<a id="arguments-and-values_in_f_process-run-function"></a>
<dl><dt><I>process-specifier</I></dt>
<dd><p><I>name</I> | 
		        (<CODE>&amp;key</CODE> <I>name</I><I>persistent</I><I>priority</I><I>class</I><I>initargs</I><I>stack-size</I><I>vstack-size</I><I>tstack-size</I>)
		      </p>
</dd>
<dt><I>name</I></dt>
<dd><p>a string, used to identify the process.
		        Passed to <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>function</I></dt>
<dd><p>a function, designated by itself or by a symbol
		        which names it.  Passed to
		        <a href="#f_process-preset"><CODE>process-preset</CODE></a>.
		      </p>
</dd>
<dt><I>persistent</I></dt>
<dd><p>a boolean, passed to <a href="#f_make-process"><CODE>make-process</CODE></a>.
		      </p>
</dd>
<dt><I>priority</I></dt>
<dd><p>ignored.</p>
</dd>
<dt><I>class</I></dt>
<dd><p>a subclass of CCL:PROCESS.  Passed to
		        <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>initargs</I></dt>
<dd><p>a list of any additional initargs to pass to
		        <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>stack-size</I></dt>
<dd><p>a size, in bytes.  Passed to
		        <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>vstack-size</I></dt>
<dd><p>a size, in bytes.  Passed to
		        <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>tstack-size</I></dt>
<dd><p>a size, in bytes.  Passed to
		        <a href="#f_make-process"><CODE>make-process</CODE></a>.</p>
</dd>
<dt><I>process</I></dt>
<dd><p>the newly-created process.</p>
</dd>
</dl>
<a id="description_in_f_process-run-function"></a>
<p>Creates a lisp process (thread) via
	      <a href="#f_make-process"><CODE>make-process</CODE></a>,
	      presets it via <a href="#f_process-preset"><CODE>process-preset</CODE></a>, and
	      enables it via <a href="#f_process-enable"><CODE>process-enable</CODE></a>.  This means
	      that <I>process</I> will immediately begin to
	      execute.
	      <a href="#f_process-run-function"><CODE>process-run-function</CODE></a> is
	      the simplest way to create and run a process.
	    </p>
<a id="see-also_in_f_process-run-function"></a>
<p><a href="#f_make-process"><CODE>make-process</CODE></a>, <a href="#f_process-preset"><CODE>process-preset</CODE></a>, <a href="#f_process-enable"><CODE>process-enable</CODE></a></p>
</div>
<a id="f_process-interrupt"></a>
<div class=definition>
<code>process-interrupt</code> <i>process</i> <i>function</i> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Function]</span><p>Arranges for the target process to invoke a
	      specified function at some point in the near future, and then
	      return to what it was doing.</p>
<a id="arguments-and-values_in_f_process-interrupt"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>function</I></dt>
<dd><p>a function.
		      </p>
</dd>
<dt><I>args</I></dt>
<dd><p>a list of values, appropriate as arguments to
		        <I>function</I>.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the result of applying <I>function</I>
		        to <I>args</I> if <I>process</I>
		        is the <a href="#v_current-process"><CODE>*current-process*</CODE></a>, otherwise
		        NIL.</p>
</dd>
</dl>
<a id="description_in_f_process-interrupt"></a>
<p>Arranges for <I>process</I>
	      to apply <I>function</I> to <I>args</I> at
	      some point in the near future (interrupting whatever
	      <I>process</I>
	      was doing.) If <I>function</I> returns normally,
	      <I>process</I> resumes
	      execution at the point at which it was interrupted.</p>
<p>	      <I>process</I> must be in an enabled state in
	      order to respond
	      to a <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a> request.  It's
	      perfectly legal for a process to call
	      <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a> on itself.</p>
<p>	      <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>
	      uses asynchronous POSIX signals to interrupt threads. If the
	      thread being interrupted is executing lisp code, it can
	      respond to the interrupt almost immediately (as soon as it
	      has finished pseudo-atomic operations like consing and
	      stack-frame initialization.)</p>
<p>	      If the interrupted thread is
	      blocking in a system call, that system call is aborted by
	      the signal and the interrupt is handled on return.</p>
<p>	      It is
	      still difficult to reliably interrupt arbitrary foreign code
	      (that may be stateful or otherwise non-reentrant); the
	      interrupt request is handled when such foreign code returns
	      to or enters lisp.</p>
<a id="see-also_in_f_process-interrupt"></a>
<p><a href="#m_without-interrupts"><CODE>without-interrupts</CODE></a></p>
<a id="notes_in_f_process-interrupt"></a>
<p>It would probably be better for <I>result</I>
	      to always be NIL, since the present behavior is inconsistent.</p>
<p>	      <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a> works by sending signals
	      between threads, via the C function
	      <CODE>#_pthread_signal</CODE>.  It could be argued
	      that it should be done in one of several possible other ways
	      under
	      Darwin, to make it practical to asynchronously interrupt
	      things which make heavy use of the Mach nanokernel.
	    </p>
</div>
<a id="v_current-process"></a>
<div class=definition>
<code>*current-process*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_current-process"></a>
<p>Bound separately in each process, to that process itself.
        It may be used when lisp code needs to find out what process
	it is executing in.  It should not be set by user code.</p>
</div>
<a id="f_process-reset"></a>
<div class=definition>
<code>process-reset</code> <i>process</i> <code>&amp;optional</code> <i>kill-option</i> <span class="definition-kind">[Function]</span><a id="description_in_f_process-reset"></a>
<p>This function causes <I>process</I> to cleanly exit from any
      ongoing computation and enter a state wehre it can be <a href="#f_process-preset"><CODE>process-preset</CODE></a>.</p>
<p>      This is implemented by signaling a condition of type
      PROCESS-RESET; user-defined condition handlers should generally
      refrain from attempting to handle conditions of this type.</p>
<p>      The <I>kill-option</I> argument is for internal
      use only and should not be specified by user code.</p>
<p>      A process can meaningfully reset itself.</p>
<p>      There is in general no way to know precisely when <I>process</I> has completed the act of resetting or killing itself; a
      process which has either entered the limbo of the reset state or
      exited has few ways of communicating either fact.</p>
<p>      The function <a href="#f_process-enable"><CODE>process-enable</CODE></a> can reliably determine
      when a process has entered the limbo of the reset state, but
      can't predict how long the clean exit from ongoing computation
      might take: that depends on the behavior of <a href="#m_unwind-protect"><CODE>unwind-protect</CODE></a> cleanup forms, and of the OS scheduler.</p>
<p>      Resetting a process other than <a href="#v_current-process"><CODE>*current-process*</CODE></a>
      involves the use of the function <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>.</p>
</div>
<a id="f_process-reset-and-enable"></a>
<div class=definition>
<code>process-reset-and-enable</code> <i>process</i> <span class="definition-kind">[Function]</span><p>Reset and enable the specified process, which
	    may not be the current process.</p>
<a id="arguments-and-values_in_f_process-reset-and-enable"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread), which
		      may not be the current process.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>undefined.</p>
</dd>
</dl>
<a id="description_in_f_process-reset-and-enable"></a>
<p>
	      Equivalent to calling (process-reset process) and
	      (process-enable process).
	    </p>
<a id="see-also_in_f_process-reset-and-enable"></a>
<p><a href="#f_process-reset"><CODE>process-reset</CODE></a>, <a href="#f_process-enable"><CODE>process-enable</CODE></a></p>
</div>
<a id="f_process-kill"></a>
<div class=definition>
<code>process-kill</code> <i>process</i> <span class="definition-kind">[Function]</span><a id="description_in_f_process-kill"></a>
<p>Causes <I>process</I> to cleanly exit from any ongoing
      computation, and then exit.  Note that <CODE>unwind-protect</CODE>
      cleanup forms will be run with interrupts disabled.</p>
</div>
<a id="f_process-abort"></a>
<div class=definition>
<code>process-abort</code> <i>process</i> <code>&amp;optional</code> <i>condition</i> <span class="definition-kind">[Function]</span><p>Causes a specified process to process an abort
	      condition, as if it had invoked
	      <CODE>abort</CODE>.</p>
<a id="arguments-and-values_in_f_process-abort"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>condition</I></dt>
<dd><p>a lisp condition.  The default is NIL.</p>
</dd>
</dl>
<a id="description_in_f_process-abort"></a>
<p>Entirely equivalent to calling
	      (<a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a><I>process</I>
	      (<CODE>lambda</CODE> ()
	      (<CODE>abort</CODE><I>condition</I>))).
	      Causes <I>process</I> to transfer control to the
	      applicable handler or restart for <CODE>abort</CODE>.</p>
<p>If <I>condition</I> is non-NIL,
	      <a href="#f_process-abort"><CODE>process-abort</CODE></a> does not consider any
	      handlers which are explicitly bound to conditions other than
	      <I>condition</I>.</p>
<a id="see-also_in_f_process-abort"></a>
<p><a href="#f_process-reset"><CODE>process-reset</CODE></a>, <a href="#f_process-kill"><CODE>process-kill</CODE></a></p>
</div>
<a id="v_ticks-per-second"></a>
<div class=definition>
<code>*ticks-per-second*</code> <span class="definition-kind">[Variable]</span><p>Bound to the clock resolution of the OS
	      scheduler.</p>
<a id="value-type_in_v_ticks-per-second"></a>
<p>A positive integer.</p>
<a id="initial-value_in_v_ticks-per-second"></a>
<p>The clock resolution of the OS scheduler.  Currently,
	      both LinuxPPC and DarwinPPC yield an initial value of 100.
	    </p>
<a id="description_in_v_ticks-per-second"></a>
<p>This value is ordinarily of marginal interest at best,
	      but, for backward compatibility, some functions accept timeout
	      values expressed in "ticks".  This value gives the number of
	      ticks per second.</p>
<a id="see-also_in_v_ticks-per-second"></a>
<p><a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a></p>
</div>
<a id="f_process-whostate"></a>
<div class=definition>
<code>process-whostate</code> <i>process</i> <span class="definition-kind">[Function]</span><p>Returns a string which describes the status of
	      a specified process.</p>
<a id="description_in_f_process-whostate"></a>
<dl><dt><I>process</I></dt>
<dd><p>a lisp process (thread).</p>
</dd>
<dt><I>whostate</I></dt>
<dd><p>a string which describes the "state" of
		        <I>process</I>.</p>
</dd>
</dl>
<p>This information is primarily for the benefit of
	      debugging tools.  <I>whostate</I> is a terse report
	      on what <I>process</I> is doing, or not doing,
	      and why.</p>
<p>If the process is currently waiting in a call to
	      <a href="#f_process-wait"><CODE>process-wait</CODE></a> or
	      <a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a>, its
	      <a href="#f_process-whostate"><CODE>process-whostate</CODE></a> will be the value
	      which was passed to that function as <I>whostate</I>.
	    </p>
<a id="see-also_in_f_process-whostate"></a>
<p><a href="#f_process-wait"><CODE>process-wait</CODE></a>, <a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_process-whostate"></a>
<p>This should arguably be SETFable, but doesn't seem to
	      ever have been.</p>
</div>
<a id="f_process-allow-schedule"></a>
<div class=definition>
<code>process-allow-schedule</code> <span class="definition-kind">[Function]</span><p>Used for cooperative multitasking; probably never
	      necessary.</p>
<a id="description_in_f_process-allow-schedule"></a>
<p>Advises the OS scheduler that the current thread has nothing
	      useful to do and that it should try to find some other thread to
	      schedule in its place. There's almost always a better
	      alternative, such as waiting for some specific event to
	      occur.  For example, you could use a lock or semaphore.</p>
<a id="see-also_in_f_process-allow-schedule"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_process-allow-schedule"></a>
<p>This is a holdover from the days of cooperative
	      multitasking.  All modern general-purpose operating systems use
	      preemptive multitasking.</p>
</div>
<a id="f_process-wait"></a>
<div class=definition>
<code>process-wait</code> <i>whostate</i> <i>function</i> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Function]</span><p>Causes the current lisp process (thread) to wait for
	      a given
	      predicate to return true.</p>
<a id="arguments-and-values_in_f_process-wait"></a>
<dl><dt><I>whostate</I></dt>
<dd><p>a string, which will be the value of
		        <a href="#f_process-whostate"><CODE>process-whostate</CODE></a>
		        while the process is waiting.</p>
</dd>
<dt><I>function</I></dt>
<dd><p>a function, designated by itself or by a symbol
		        which names it.
		      </p>
</dd>
<dt><I>args</I></dt>
<dd><p>a list of values, appropriate as arguments to
		        <I>function</I>.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>NIL.</p>
</dd>
</dl>
<a id="description_in_f_process-wait"></a>
<p>Causes the current lisp process (thread) to repeatedly
	      apply <I>function</I> to
	      <I>args</I> until the call returns a true result, then
	      returns NIL. After
	      each failed call, yields the CPU as if by
	      <a href="#f_process-allow-schedule"><CODE>process-allow-schedule</CODE></a>.</p>
<p>
	      As with <a href="#f_process-allow-schedule"><CODE>process-allow-schedule</CODE></a>, it's almost
	      always more efficient to wait for some
	      specific event to occur; this isn't exactly busy-waiting, but
	      the OS scheduler can do a better job of scheduling if it's given
	      the relevant information.  For example, you could use a lock
	      or semaphore.</p>
<a id="see-also_in_f_process-wait"></a>
<p><a href="#f_process-whostate"><CODE>process-whostate</CODE></a>, <a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_process-wait-with-timeout"></a>
<div class=definition>
<code>process-wait-with-timeout</code> <i>whostate</i> <i>ticks</i> <i>function</i> <i>args</i> <span class="definition-kind">[Function]</span><p>Causes the current thread to wait for a given
	      predicate to return true, or for a timeout to expire.</p>
<a id="arguments-and-values_in_f_process-wait-with-timeout"></a>
<dl><dt><I>whostate</I></dt>
<dd><p>a string, which will be the value of
		        <a href="#f_process-whostate"><CODE>process-whostate</CODE></a>
		        while the process is waiting.</p>
</dd>
<dt><I>ticks</I></dt>
<dd><p>either a positive integer expressing a duration
		        in "ticks" (see <a href="#v_ticks-per-second"><CODE>*ticks-per-second*</CODE></a>),
		        or NIL.</p>
</dd>
<dt><I>function</I></dt>
<dd><p>a function, designated by itself or by a symbol
		        which names it.</p>
</dd>
<dt><I>args</I></dt>
<dd><p>a list of values, appropriate as arguments to
		        <I>function</I>.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>T if <a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a>
		        returned because its <I>function</I> returned
		        true, or NIL if it returned because the duration
		        <I>ticks</I> has been exceeded.</p>
</dd>
</dl>
<a id="description_in_f_process-wait-with-timeout"></a>
<p>If <I>ticks</I> is NIL, behaves exactly like
	      <a href="#f_process-wait"><CODE>process-wait</CODE></a>, except for returning T.
	      Otherwise, <I>function</I> will be tested repeatedly,
	      in the same
	      kind of test/yield loop as in <a href="#f_process-wait"><CODE>process-wait</CODE></a>
	      until either <I>function</I> returns true,
	      or the duration <I>ticks</I> has been exceeded.
	    </p>
<p> Having already read the descriptions of
	      <a href="#f_process-allow-schedule"><CODE>process-allow-schedule</CODE></a> and
	      <a href="#f_process-wait"><CODE>process-wait</CODE></a>, the
	      astute reader has no doubt anticipated the observation that
	      better alternatives should be used whenever possible.</p>
<a id="see-also_in_f_process-wait-with-timeout"></a>
<p><a href="#v_ticks-per-second"><CODE>*ticks-per-second*</CODE></a>, <a href="#f_process-whostate"><CODE>process-whostate</CODE></a>, <a href="#f_process-wait"><CODE>process-wait</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="m_without-interrupts"></a>
<div class=definition>
<code>without-interrupts</code> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Evaluates its body in an environment in which
	      process-interrupt requests are deferred.</p>
<a id="arguments-and-values_in_m_without-interrupts"></a>
<dl><dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_without-interrupts"></a>
<p>Executes <I>body</I>
	      in an environment in which <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>
	      requests are
	      deferred. As noted in the description of
	      <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>, this has nothing to do
	      with the
	      scheduling of other threads; it may be necessary to inhibit
	      <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a> handling when
	      (for instance) modifying some data
	      structure (for which the current thread holds an appropriate lock)
	      in some manner that's not reentrant.</p>
<a id="see-also_in_m_without-interrupts"></a>
<p><a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a></p>
</div>
<a id="m_with-interrupts-enabled"></a>
<div class=definition>
<code>with-interrupts-enabled</code> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Evaluates its body in an environment in which
	      process-interrupt requests have immediate effect.</p>
<a id="arguments-and-values_in_m_with-interrupts-enabled"></a>
<dl><dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_with-interrupts-enabled"></a>
<p>Executes <I>body</I>
	      in an environment in which <a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>
	      requests have immediate effect.
	    </p>
</div>
<a id="f_make-lock"></a>
<div class=definition>
<code>make-lock</code> <code>&amp;optional</code> <i>name</i> <span class="definition-kind">[Function]</span><p>Creates and returns a lock object, which can
	      be used for synchronization between threads.</p>
<a id="arguments-and-values_in_f_make-lock"></a>
<dl><dt><I>name</I></dt>
<dd><p>any lisp object; saved as part of
		        <I>lock</I>.  Typically a string or symbol
		        which may appear in the <a href="#f_process-whostate"><CODE>process-whostate</CODE></a>s
		        of threads which are waiting for <I>lock</I>.
		      </p>
</dd>
<dt><I>lock</I></dt>
<dd><p>a newly-allocated object of type CCL:LOCK.</p>
</dd>
</dl>
<a id="description_in_f_make-lock"></a>
<p>Creates and returns a lock object, which can
	      be used to synchronize access to some shared resource.
	      <I>lock</I> is
	      initially in a "free" state; a lock can also be
	      "owned" by a
	      thread.</p>
<a id="see-also_in_f_make-lock"></a>
<p><a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a>, <a href="#f_grab-lock"><CODE>grab-lock</CODE></a>, <a href="#f_release-lock"><CODE>release-lock</CODE></a>, <a href="#f_try-lock"><CODE>try-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="m_with-lock-grabbed"></a>
<div class=definition>
<code>with-lock-grabbed</code> <i>(lock)</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Waits until a given lock can be obtained, then
	      evaluates its body with the lock held.</p>
<a id="arguments-and-values_in_m_with-lock-grabbed"></a>
<dl><dt><I>lock</I></dt>
<dd><p>an object of type CCL:LOCK.</p>
</dd>
<dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_with-lock-grabbed"></a>
<p>Waits until <I>lock</I> is either free or
	      owned by the calling
	      thread, then executes <I>body</I> with the
	      lock owned by the calling thread. If <I>lock</I>
	      was free when <a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a> was called,
	      it is restored to a free state after <I>body</I>
	      is executed.</p>
<a id="see-also_in_m_with-lock-grabbed"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_grab-lock"><CODE>grab-lock</CODE></a>, <a href="#f_release-lock"><CODE>release-lock</CODE></a>, <a href="#f_try-lock"><CODE>try-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_grab-lock"></a>
<div class=definition>
<code>grab-lock</code> <i>lock</i> <span class="definition-kind">[Function]</span><p>Waits until a given lock can be obtained, then
	      obtains it.</p>
<a id="arguments-and-values_in_f_grab-lock"></a>
<dl><dt><I>lock</I></dt>
<dd><p>an object of type CCL:LOCK.</p>
</dd>
</dl>
<a id="description_in_f_grab-lock"></a>
<p>Blocks until <I>lock</I> is owned by the
	      calling thread.</p>
<p>The macro <a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a><EMPH>could</EMPH> be defined in
	      terms of <a href="#f_grab-lock"><CODE>grab-lock</CODE></a> and
	      <a href="#f_release-lock"><CODE>release-lock</CODE></a>, but it is actually
	      implemented at a slightly lower level.</p>
<a id="see-also_in_f_grab-lock"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a>, <a href="#f_release-lock"><CODE>release-lock</CODE></a>, <a href="#f_try-lock"><CODE>try-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_release-lock"></a>
<div class=definition>
<code>release-lock</code> <i>lock</i> <span class="definition-kind">[Function]</span><p>Relinquishes ownership of a given lock.</p>
<a id="arguments-and-values_in_f_release-lock"></a>
<dl><dt><I>lock</I></dt>
<dd><p>an object of type CCL:LOCK.</p>
</dd>
</dl>
<a id="description_in_f_release-lock"></a>
<p>Signals an error of type CCL:LOCK-NOT-OWNER if
	      <I>lock</I>
	      is not already owned by the calling thread; otherwise, undoes the
	      effect of one previous 
	      <a href="#f_grab-lock"><CODE>grab-lock</CODE></a>.  If this means that
	      <a href="#f_release-lock"><CODE>release-lock</CODE></a> has now been called on
	      <I>lock</I> the same number of times as
	      <a href="#f_grab-lock"><CODE>grab-lock</CODE></a> has, <I>lock</I>
	      becomes free.</p>
<a id="see-also_in_f_release-lock"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a>, <a href="#f_grab-lock"><CODE>grab-lock</CODE></a>, <a href="#f_try-lock"><CODE>try-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_try-lock"></a>
<div class=definition>
<code>try-lock</code> <i>lock</i> <span class="definition-kind">[Function]</span><p>Obtains the given lock, but only if it is not
	      necessary to wait for it.</p>
<a id="arguments-and-values_in_f_try-lock"></a>
<dl><dt><I>lock</I></dt>
<dd><p>an object of type CCL:LOCK.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>T if <I>lock</I> has been obtained,
		        or NIL if it has not.</p>
</dd>
</dl>
<a id="description_in_f_try-lock"></a>
<p>Tests whether <I>lock</I>
	      can be obtained without blocking - that is, either
	      <I>lock</I> is already free, or it is already owned
	      by <a href="#v_current-process"><CODE>*current-process*</CODE></a>.  If it can,
	      causes it to
	      be owned by the calling lisp process (thread) and returns T.
	      Otherwise, the lock
	      is already owned by another thread and cannot be obtained without
	      blocking; NIL is returned in this case.</p>
<a id="see-also_in_f_try-lock"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a>, <a href="#f_grab-lock"><CODE>grab-lock</CODE></a>, <a href="#f_release-lock"><CODE>release-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_make-read-write-lock"></a>
<div class=definition>
<code>make-read-write-lock-write-lock</code> <span class="definition-kind">[Function]</span><p>Creates and returns a read-write lock, which can
	      be used for synchronization between threads.</p>
<a id="arguments-and-values_in_f_make-read-write-lock"></a>
<dl><dt><I>read-write-lock</I></dt>
<dd><p>a newly-allocated object of type
		        CCL:READ-WRITE-LOCK.</p>
</dd>
</dl>
<a id="description_in_f_make-read-write-lock"></a>
<p>Creates and returns an object of type CCL::READ-WRITE-LOCK.
	      A read-write lock may, at any given time, belong to any number
	      of lisp processes (threads) which act as "readers"; or, it may
	      belong to at most one process which acts as a "writer".  A
	      read-write lock may never be held by a reader at the same time as
	      a writer.  Initially, <I>read-write-lock</I> has
	      no readers and no writers.</p>
<a id="see-also_in_f_make-read-write-lock"></a>
<p><a href="#m_with-read-lock"><CODE>with-read-lock</CODE></a>, <a href="#m_with-write-lock"><CODE>with-write-lock</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_make-read-write-lock"></a>
<p>There probably should be some way to
	      atomically "promote" a reader, making it a writer without
	      releasing the lock, which could otherwise cause delay.</p>
</div>
<a id="m_with-read-lock"></a>
<div class=definition>
<code>with-read-lock</code> <i>(read-write-lock)</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Waits until a given lock is available for
	      read-only access, then evaluates its body with the lock
	      held.</p>
<a id="arguments-and-values_in_m_with-read-lock"></a>
<dl><dt><I>read-write-lock</I></dt>
<dd><p>an object of type
		        CCL:READ-WRITE-LOCK.</p>
</dd>
<dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_with-read-lock"></a>
<p>Waits until <I>read-write-lock</I> has no
	      writer,
	      ensures that <a href="#v_current-process"><CODE>*current-process*</CODE></a> is a
	      reader of it, then executes <I>body</I>.
	    </p>
<p>After executing <I>body</I>, if
	      <a href="#v_current-process"><CODE>*current-process*</CODE></a> was not a reader of
	      <I>read-write-lock</I> before
	      <a href="#m_with-read-lock"><CODE>with-read-lock</CODE></a> was called, the lock is
	      released.  If it was already a reader, it remains one.</p>
<a id="see-also_in_m_with-read-lock"></a>
<p><a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#m_with-write-lock"><CODE>with-write-lock</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="m_with-write-lock"></a>
<div class=definition>
<code>with-write-lock</code> <i>(read-write-lock)</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Waits until the given lock is available for write
	      access, then executes its body with the lock held.</p>
<a id="arguments-and-values_in_m_with-write-lock"></a>
<dl><dt><I>read-write-lock</I></dt>
<dd><p>an object of type
		        CCL:READ-WRITE-LOCK.</p>
</dd>
<dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_with-write-lock"></a>
<p>Waits until <I>read-write-lock</I> has no
	      readers and no writer other than <a href="#v_current-process"><CODE>*current-process*</CODE></a>,
	      then ensures that <a href="#v_current-process"><CODE>*current-process*</CODE></a> is the
	      writer of it.  With the lock held, executes <I>body</I>.
	    </p>
<p>After executing <I>body</I>, if
	      <a href="#v_current-process"><CODE>*current-process*</CODE></a> was not the writer of
	      <I>read-write-lock</I> before
	      <a href="#m_with-write-lock"><CODE>with-write-lock</CODE></a> was called, the lock is
	      released.  If it was already the writer, it remains the
	      writer.</p>
<a id="see-also_in_m_with-write-lock"></a>
<p><a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#m_with-read-lock"><CODE>with-read-lock</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_make-semaphore"></a>
<div class=definition>
<code>make-semaphore</code> <span class="definition-kind">[Function]</span><p>Creates and returns a semaphore, which can be used
	      for synchronization between threads.</p>
<a id="arguments-and-values_in_f_make-semaphore"></a>
<dl><dt><I>semaphore</I></dt>
<dd><p>a newly-allocated object of type CCL:SEMAPHORE.</p>
</dd>
</dl>
<a id="description_in_f_make-semaphore"></a>
<p>Creates and returns an object of type CCL:SEMAPHORE.
	      A semaphore has an associated "count" which may be incremented
	      and decremented atomically; incrementing it represents sending
	      a signal, and decrementing it represents handling that signal.
	      <I>semaphore</I> has an initial count of 0.</p>
<a id="see-also_in_f_make-semaphore"></a>
<p><a href="#f_signal-semaphore"><CODE>signal-semaphore</CODE></a>, <a href="#f_wait-on-semaphore"><CODE>wait-on-semaphore</CODE></a>, <a href="#f_timed-wait-on-semaphore"><CODE>timed-wait-on-semaphore</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_signal-semaphore"></a>
<div class=definition>
<code>signal-semaphore</code> <i>semaphore</i> <span class="definition-kind">[Function]</span><p>Atomically increments the count of a given
	      semaphore.</p>
<a id="arguments-and-values_in_f_signal-semaphore"></a>
<dl><dt><I>semaphore</I></dt>
<dd><p>an object of type CCL:SEMAPHORE.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>an integer representing an error identifier
		        which was returned by the underlying OS call.</p>
</dd>
</dl>
<a id="description_in_f_signal-semaphore"></a>
<p>Atomically increments <I>semaphore</I>'s
	      "count" by 1; this
	      may enable a waiting thread to resume execution.</p>
<a id="see-also_in_f_signal-semaphore"></a>
<p><a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_wait-on-semaphore"><CODE>wait-on-semaphore</CODE></a>, <a href="#f_timed-wait-on-semaphore"><CODE>timed-wait-on-semaphore</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_signal-semaphore"></a>
<p><I>result</I> should probably be interpreted
	      and acted on by <a href="#f_signal-semaphore"><CODE>signal-semaphore</CODE></a>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</p>
</div>
<a id="f_wait-on-semaphore"></a>
<div class=definition>
<code>wait-on-semaphore</code> <i>semaphore</i> <span class="definition-kind">[Function]</span><p>Waits until the given semaphore has a positive
	      count which can be atomically decremented.</p>
<a id="arguments-and-values_in_f_wait-on-semaphore"></a>
<dl><dt><I>semaphore</I></dt>
<dd><p>an object of type CCL:SEMAPHORE.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>an integer representing an error identifier
		        which was returned by the underlying OS call.</p>
</dd>
</dl>
<a id="description_in_f_wait-on-semaphore"></a>
<p>Waits until <I>semaphore</I>
	      has a positive count that can be
	      atomically decremented; this will succeed exactly once for each
	      corresponding call to SIGNAL-SEMAPHORE.</p>
<a id="see-also_in_f_wait-on-semaphore"></a>
<p><a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_signal-semaphore"><CODE>signal-semaphore</CODE></a>, <a href="#f_timed-wait-on-semaphore"><CODE>timed-wait-on-semaphore</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_wait-on-semaphore"></a>
<p><I>result</I> should probably be interpreted
	      and acted on by <a href="#f_wait-on-semaphore"><CODE>wait-on-semaphore</CODE></a>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</p>
</div>
<a id="f_timed-wait-on-semaphore"></a>
<div class=definition>
<code>timed-wait-on-semaphore</code> <i>semaphore</i> <i>timeout</i> <span class="definition-kind">[Function]</span><p>Waits until the given semaphore has a positive
	      count which can be atomically decremented, or until a timeout
	      expires.</p>
<a id="arguments-and-values_in_f_timed-wait-on-semaphore"></a>
<dl><dt><I>semaphore</I></dt>
<dd><p>An object of type CCL:SEMAPHORE.</p>
</dd>
<dt><I>timeout</I></dt>
<dd><p>a time interval in seconds.  May be any
		        non-negative real number the <CODE>floor</CODE> of
		        which fits in 32 bits.  The default is 1.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>T if <a href="#f_timed-wait-on-semaphore"><CODE>timed-wait-on-semaphore</CODE></a>
		        returned because it was able to decrement the count of
		        <I>semaphore</I>; NIL if it returned because
		        the duration <I>timeout</I> has been
		        exceeded.</p>
</dd>
</dl>
<a id="description_in_f_timed-wait-on-semaphore"></a>
<p>Waits until <I>semaphore</I>
	      has a positive count that can be
	      atomically decremented, or until the duration
	      <I>timeout</I> has
	      elapsed.</p>
<a id="see-also_in_f_timed-wait-on-semaphore"></a>
<p><a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_wait-on-semaphore"><CODE>wait-on-semaphore</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
</div>
<a id="f_process-input-wait"></a>
<div class=definition>
<code>process-input-wait</code> <i>fd</i> <code>&amp;optional</code> <i>timeout</i> <span class="definition-kind">[Function]</span><p>Waits until input is available on a given
	      file-descriptor.</p>
<a id="arguments-and-values_in_f_process-input-wait"></a>
<dl><dt><I>fd</I></dt>
<dd><p>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <a href="#f_stream-device"><CODE>stream-device</CODE></a>.</p>
</dd>
<dt><I>timeout</I></dt>
<dd><p>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</p>
</dd>
</dl>
<a id="description_in_f_process-input-wait"></a>
<p>Wait until input is available on <I>fd</I>.
	      This uses the <CODE>select()</CODE> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting for input. More
	      accurately, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>
	      waits until it's possible to read
	      from fd without blocking, or until <I>timeout</I>, if
	      it is not NIL, has been exceeded.</p>
<p>	      Note that it's possible to read without blocking if
	      the file is at its end - although, of course, the read will
	      return zero bytes.</p>
<a id="see-also_in_f_process-input-wait"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_process-input-wait"></a>
<p><a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a> has a timeout parameter,
	      and
	      <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a> does not.  This
	      inconsistency should probably be corrected.
	    </p>
</div>
<a id="f_process-output-wait"></a>
<div class=definition>
<code>process-output-wait</code> <i>fd</i> <code>&amp;optional</code> <i>timeout</i> <span class="definition-kind">[Function]</span><p>Waits until output is possible on a given file
	      descriptor.</p>
<a id="arguments-and-values_in_f_process-output-wait"></a>
<dl><dt><I>fd</I></dt>
<dd><p>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <a href="#f_stream-device"><CODE>stream-device</CODE></a>.</p>
</dd>
<dt><I>timeout</I></dt>
<dd><p>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</p>
</dd>
</dl>
<a id="description_in_f_process-output-wait"></a>
<p>Wait until output is possible on <I>fd</I> or until <I>timeout</I>, if
	      it is not NIL, has been exceeded.
	      This uses the <CODE>select()</CODE> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting to output.</p>
<p>	      If <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a> is called on
	      a network socket which has not yet established a connection, it
	      will wait until the connection is established.  This is an
	      important use, often overlooked.</p>
<a id="see-also_in_f_process-output-wait"></a>
<p><a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a></p>
<a id="notes_in_f_process-output-wait"></a>
<p><a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a> has a timeout parameter,
	      and
	      <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a> does not.  This
	      inconsistency should probably be corrected.
	    </p>
</div>
<a id="m_with-terminal-input"></a>
<div class=definition>
<code>with-terminal-input</code> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Executes its body in an environment with exclusive
	      read access to the terminal.</p>
<a id="arguments-and-values_in_m_with-terminal-input"></a>
<dl><dt><I>body</I></dt>
<dd><p>an implicit progn.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>the primary value returned by
		        <I>body</I>.</p>
</dd>
</dl>
<a id="description_in_m_with-terminal-input"></a>
<p>Requests exclusive read access to the standard terminal
	      stream, <CODE>*terminal-io*</CODE>.  Executes
	      <I>body</I> in an environment with that access.
	    </p>
<a id="see-also_in_m_with-terminal-input"></a>
<p><a href="#v_request-terminal-input-via-break"><CODE>*request-terminal-input-via-break*</CODE></a>, <a href="#tc_y"><CODE>":Y"</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a></p>
</div>
<a id="v_request-terminal-input-via-break"></a>
<div class=definition>
<code>*request-terminal-input-via-break*</code> <span class="definition-kind">[Variable]</span><p>Controls how attempts to obtain ownership of
	      terminal input are made.</p>
<a id="value-type_in_v_request-terminal-input-via-break"></a>
<p>A boolean.</p>
<a id="initial-value_in_v_request-terminal-input-via-break"></a>
<p>NIL.</p>
<a id="description_in_v_request-terminal-input-via-break"></a>
<p>Controls how attempts to obtain ownership of terminal input
	      are made. When NIL, a message is printed on *TERMINAL-IO*;
	      it's expected that the user will later yield
	      control of the terminal via the :Y toplevel command. When T, a
	      BREAK condition is signaled in the owning process; continuing from
	      the break loop will yield the terminal to the requesting process
	      (unless the :Y command was already used to do so in the break
	      loop.)</p>
<a id="see-also_in_v_request-terminal-input-via-break"></a>
<p><a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a>, <a href="#tc_y"><CODE>":Y"</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a></p>
</div>
<a id="tc_y"></a>
<div class=definition>
<code>(</code> <i>:y</i> <i>p</i>) <span class="definition-kind">[Toplevel Command]</span><p>Yields control of terminal input to a specified
	      lisp process (thread).</p>
<a id="arguments-and-values_in_tc_y"></a>
<dl><dt><I>p</I></dt>
<dd><p>a lisp process (thread), designated either by
		        an integer which matches its
		        <CODE>process-serial-number</CODE>,
		        or by a string which is <CODE>equal</CODE> to
		        its <CODE>process-name</CODE>.</p>
</dd>
</dl>
<a id="description_in_tc_y"></a>
<p>:Y is a toplevel command, not a function.  As such, it
	      can only be used interactively, and only from the initial
	      process.</p>
<p>The command yields control of terminal input to the
	      process <I>p</I>, which must have used
	      <a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a> to request access to the
	      terminal input stream.</p>
<a id="see-also_in_tc_y"></a>
<p><a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a>, <a href="#v_request-terminal-input-via-break"><CODE>*request-terminal-input-via-break*</CODE></a>, <a href="#f_make-lock"><CODE>make-lock</CODE></a>, <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>, <a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>, <a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>, <a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a></p>
</div>
<a id="f_join-process"></a>
<div class=definition>
<code>join-process</code> <i>process</i> <code>&amp;optional</code> <i>default</i> <span class="definition-kind">[Function]</span><p>Waits for a specified process to complete and
	returns the values that that process's initial function
	returned.</p>
<a id="arguments-and-values_in_f_join-process"></a>
<dl><dt><I>process</I></dt>
<dd><p>a process, typically created by <a href="#f_process-run-function"><CODE>process-run-function</CODE></a> or by <a href="#f_make-process"><CODE>make-process</CODE></a></p>
</dd>
<dt><I>default</I></dt>
<dd><p>A default value to be returned if the specified
	      process doesn't exit normally.</p>
</dd>
<dt><I>values</I></dt>
<dd><p>The values returned by the specified process's
	      initial function if that function returns, or the value
	      of the default argument, otherwise.</p>
</dd>
</dl>
<a id="description_in_f_join-process"></a>
<p>Waits for the specified process to terminate.  If the
	process terminates "normally" (if its initial function
	returns), returns the values that that initial function
	returnes.  If the process does not terminate normally (e.g.,
	if it's terminated via <a href="#f_process-kill"><CODE>process-kill</CODE></a> and a
	default argument is provided, returns the value of that
	default argument.  If the process doesn't terminate normally
	and no default argument is provided, signals an error.</p>
<p>A process can't successfully join itself, and only one
	process can successfully receive notification of another process's
	termination.</p>
</div>
</div>
</div>
<a id="the-foreign-function-interface"></a>
<H2>The Foreign Function Interface</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#brief-examples">
Brief Examples</a>
<ul style="list-style: none">
</ul>
<li><a href="#specifying-and-using-foreign-types">
Specifying And Using Foreign Types</a>
<ul style="list-style: none">
<li><a href="#type-annotations">
Type Annotations</a>
<li><a href="#foreign-types-as-classes">
Foreign Types as Classes</a>
</ul>
<li><a href="#syntax-of-foreign-type-specifiers">
Syntax of Foreign Type Specifiers</a>
<ul style="list-style: none">
</ul>
<li><a href="#foreign-function-calls">
Foreign Function Calls</a>
<ul style="list-style: none">
<li><a href="#overview_in_foreign-function-calls">
Overview</a>
<li><a href="#return-conventions-for-c-structures">
Return Conventions for C Structures</a>
</ul>
<li><a href="#referencing-and-using-foreign-memory-addresses">
Referencing and Using Foreign Memory Addresses</a>
<ul style="list-style: none">
<li><a href="#overview_in_referencing-and-using-foreign-memory-addresses">
Overview</a>
<li><a href="#foreign-memory-addresses-dictionary">
Foreign-Memory-Addresses Dictionary</a>
</ul>
<li><a href="#the-interface-database">
The Interface Database</a>
<ul style="list-style: none">
<li><a href="#overview_in_the-interface-database">
Overview</a>
<li><a href="#other-issues">
Other issues:</a>
</ul>
<li><a href="#using-interface-directories">
Using Interface Directories</a>
<ul style="list-style: none">
<li><a href="#overview_in_using-interface-directories">
Overview</a>
<li><a href="#creating-new-interface-directories">
Creating new interface directories</a>
</ul>
<li><a href="#using-shared-libraries">
Using Shared Libraries</a>
<ul style="list-style: none">
<li><a href="#overview_in_using-shared-libraries">
Overview</a>
<li><a href="#limitations-and-known-bugs_in_using-shared-libraries">
Limitations and known bugs</a>
<li><a href="#darwin-notes">
&gt;Darwin Notes</a>
</ul>
<li><a href="#the-interface-translator">
The Interface Translator</a>
<ul style="list-style: none">
<li><a href="#overview_in_the-interface-translator">
Overview</a>
<li><a href="#details-rebuilding-the-cdb-databases-step-by-step">
Details: rebuilding the CDB databases, step by step</a>
</ul>
<li><a href="#case-sensitivity-of-foreign-names-in-clozure-cl">
Case-sensitivity of foreign names in Clozure CL</a>
<ul style="list-style: none">
<li><a href="#overview_in_case-sensitivity-of-foreign-names-in-clozure-cl">
Overview</a>
<li><a href="#foreign-constant-and-function-names">
Foreign constant and function names</a>
<li><a href="#foreign-type-record-and-field-names">
Foreign type, record, and field names</a>
<li><a href="#examples_in_case-sensitivity-of-foreign-names-in-clozure-cl">
Examples</a>
</ul>
<li><a href="#reading-foreign-names">
Reading Foreign Names</a>
<ul style="list-style: none">
</ul>
<li><a href="#tutorial-using-basic-calls-and-types">
Tutorial: Using Basic Calls and Types</a>
<ul style="list-style: none">
<li><a href="#acknowledgement_in_tutorial-using-basic-calls-and-types">
Acknowledgement</a>
</ul>
<li><a href="#tutorial-allocating-foreign-data-on-the-lisp-heap">
Tutorial: Allocating Foreign Data on the Lisp Heap </a>
<ul style="list-style: none">
<li><a href="#acknowledgement_in_tutorial-allocating-foreign-data-on-the-lisp-heap">
Acknowledgement</a>
</ul>
<li><a href="#the-foreign-function-interface-dictionary">
The Foreign-Function-Interface Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<p>Clozure CL can call external code that uses the platform's C ABI.  C++
functions cannot be called directly.  All of the mechanisms used to do
this are ultimately based on the function <a href="#f_._ff-call"><CODE>%ff-call</CODE></a>, but the
<CODE>#_</CODE> reader macro and the <a href="#m_external-call"><CODE>external-call</CODE></a> macro are
typically more convenient and easier to use.</p>
<p>There is also a mechanism to let external code call into lisp.  This is
useful when you want to pass a lisp function as a callback function. (See
<a href="#m_defcallback"><CODE>defcallback</CODE></a>.)</p>
<a id="brief-examples"></a>
<H3>Brief Examples</H3>
<div class="section">
<p>A few examples may be useful before discussing the FFI facilities
in detail.</p>
<p>     Most functions that are in the system C library are included in the
interface database that comes with Clozure CL.  The reader macro <CODE>#_</CODE>
consults that database for information about the foriegn code, and makes
foreign functions easy to use.</p>
<pre class="source-code">? (#_getpid)
2845
? (#_log2 2048d0)
11.0D0
? (with-encoded-cstrs :ascii ((s "Yow!"))
    (#_write 1 s 4))
</pre>
<p>These same calls can be made with the slightly lower-level
<a href="#m_external-call"><CODE>external-call</CODE></a>.</p>
<pre class="source-code">? (external-call "getpid" :pid_t)
2845
? (external-call "log2" :double 2048d0 :double)
11.0D0
? (with-encoded-cstrs :ascii ((s "Yow!"))
    (external-call "write" :int 1 :address s :size_t 4 :ssize_t))
</pre>
<p>Note that with <a href="#m_external-call"><CODE>external-call</CODE></a>, it is necessary to specify
the foreign types of the arguments and return values.  The <CODE>#_</CODE>
reader macro uses the interface database to determine that the
function <CODE>getpid</CODE> (for example) returns a <CODE>pid_t</CODE> value, and
it is therefore not necessary to specify it explicitly.</p>
<p>Finally, just to frighten pets and small children, here is a fairly
complicated example (adapted  from a man page for <CODE>getpwuid_r</CODE>):</p>
<pre class="source-code">? (let ((bufsize (#_sysconf #$_SC_GETPW_R_SIZE_MAX)))
    (when (= bufsize -1)
      (error "sysconf failed"))
    (%stack-block ((buf bufsize))
      (rlet ((pw (:struct :passwd))
	     (result :address))
        (let ((err (#_getpwuid_r (#_getuid) pw buf bufsize result)))
	  (when (or (not (zerop err))
		    (%null-ptr-p (%get-ptr result)))
	    (error "getpwuid_r failed"))
	  (let ((cname (pref pw :passwd.pw_name))
	        (gid (pref pw :passwd.pw_gid)))
	    (format t "~&amp;user ~s gid is ~d" (get-encoded-string :ascii
		  					        cname
							        (#_strlen cname))
		  gid))))))
</pre>
</div>
<a id="specifying-and-using-foreign-types"></a>
<H3>Specifying And Using Foreign Types</H3>
<div class="section">
<p>Clozure CL provides a fairly rich language for defining and specifying
     foreign data types (this language is derived from CMUCL's “alien
     type” system.)</p>
<p>     In practice, most foreign type definitions are introduced into
     Clozure CL via its interface database, though it is also possible to
     define foreign types interactively and/or programmatically.</p>
<p>     Clozure CL's foreign type system is “evolving” (a polite word for
     not-quite-complete): there are some inconsistencies involving
     package usage, for instance. Symbols used in foreign type
     specifiers <EMPH>should</EMPH> be keywords, but this convention
     isn't always enforced.</p>
<p>     Foreign type, record, and field names are case-sensitive; Clozure CL
     uses some escaping conventions to allow keywords to be used to
     denote these names.</p>
<a id="type-annotations"></a>
<H4>Type Annotations</H4>
<div class="section">
<p>As of version 1.2, Clozure CL supports annotating the types of
          foreign pointers on Mac OS X. Forms that create pointers to
          foreign memory-that is, <CODE>MACPTR</CODE>s-store
          with the <CODE>MACPTR</CODE> object a type annotation that
          identifies the foreign type of the object pointed
          to. Calling <CODE>PRINT-OBJECT</CODE> on a <CODE>MACPTR</CODE>
          attempts to print information about the identified foreign
          type, including whether it was allocated on the heap or the
          stack, and whether it's scheduled for automatic reclamation by
          the garbage collector.</p>
<p>          Support for type annotation is not yet complete. In
          particular, some uses of <CODE>PREF</CODE>
          and <CODE>SLOT-VALUE</CODE> do ot yet take type annotations into
          account, and neither do <CODE>DESCRIBE</CODE>
          and <CODE>INSPECT</CODE>.</p>
</div>
<a id="foreign-types-as-classes"></a>
<H4>Foreign Types as Classes</H4>
<div class="section">
<p>Some types of foreign pointers take advantage of the
          support for type annotations, and pointers of these types
          can be treated as instances of known classes. Specifically,
          a pointer to an <CODE>:&lt;NSR&gt;ect</CODE> is recognized
          as an instance of the built-in
          class <CODE>NS:NS-RECT</CODE>, a pointer to
          an <CODE>&lt;NSS&gt;ize</CODE> is treated as an instance
          of <CODE>NS:NS-SIZE</CODE>, a pointer to
          an <CODE>&lt;NSP&gt;oint</CODE> is recognized as an
          instance of <CODE>NS:NS-POINT</CODE>, and a pointer to
          an <CODE>&lt;NSR&gt;ange</CODE> is recognized as an
          instance of <CODE>NS:NS-RANGE</CODE>.</p>
<p>        A few more obscure structure types also support this
        mechanism, and it's possible that a future version will
        support user definition of similar type mappings.</p>
<p>        This support for foreign types as classes provides the
        following conveniences for each supported type:</p>
<ul><li><p>a <CODE>PRINT-OBJECT</CODE> method is defined</p>
<li><p>a foreign type name is created and treated as an alias
          for the corresponding type. As an example, the
          name <CODE>:NS-RECT</CODE> is a name for the type that
          corresponds to <CODE>NS:NS-RECT</CODE>, and you can
          use <CODE>:NS-RECT</CODE> as a type designator
          in <a href="#m_rlet"><CODE>rlet</CODE></a> forms to
          specify a structure of type <CODE>NS-RECT</CODE>.</p>
<li><p>the class is integrated into the type system so that
            <CODE>(TYPEP R 'NS:NS-RECT)</CODE> is implemented with
            fair efficiency.</p>
<li><p>inlined accessor and <CODE>SETF</CODE> inverses are
            defined for the structure type's fields.  In the case of
            an <CODE>&lt;NSR*gt;ect</CODE>, for example, the fields in
            question are the fields of the embedded point and size, so
            that <CODE>NS:NS-RECT-X</CODE>, <CODE>NS:NS-RECT-Y</CODE>, <CODE>NS:NS-RECT-WIDTH</CODE>,
            <CODE>NS-RECT-HEIGHT</CODE> and <CODE>SETF</CODE> inverses
            are defined.  The accessors and setter functions typecheck
            their arguments and the setters handle coercion to the
            appropriate type of <CODE>CGFLOAT</CODE> where
            applicable.</p>
<li><p>an initialization function is defined; for
            example,</p>
<pre class="source-code">(NS:INIT-NS-SIZE s w h)
</pre>
<p>is roughly equivalent to</p>
<pre class="source-code">(SETF (NS:NS-SIZE-WIDTH s) w
      (NS:NS-SIZE-HEIGHT s) h)
          
</pre>
<p>but might be a little more efficient.</p>
<li><p>a creation function is defined; for
            example</p>
<pre class="source-code">(ns:ns-make-point x y)
</pre>
<p>is functionally equivalent to</p>
<pre class="source-code">(LET ((P (MAKE-GCABLE-RECORD :NS-POINT)))
  (NS:INIT-NS-POINT P X Y)
  p)
          
</pre>
<li><p>a macro is defined which, like <CODE>RLET</CODE>,
            stack-allocates an instance of the foreign record type,
            optionally initializes that instance, and executes a body
            of code with a variable bound to that instance.</p>
<p>For example,</p>
<pre class="source-code">(ns:with-ns-range (r loc len)
  (format t "~&amp; range has location ~s, length ~s" 
     (ns:ns-range-location r) (ns:ns-range-length r)))
</pre>
<li></ul>
</div>
</div>
<a id="syntax-of-foreign-type-specifiers"></a>
<H3>Syntax of Foreign Type Specifiers</H3>
<div class="section">
<ul><li><p>Some foreign types are builtin: keywords denote
            primitive,builtin types such as the IEEE-double-float type
            (denoted:DOUBLE-FLOAT), in much the same way as certain
            symbols(CONS, FIXNUM,etc.) define primitive CL
            types.</p>
<li><p>Constructors such as :SIGNED and :UNSIGNED can be
            used to denote signed and unsigned integer subtypes
            (analogous to the CL type specifiers SIGNED-BYTE and
            UNSIGNED-BYTE.) :SIGNED is shorthand for(:SIGNED 32) and
            :UNSIGNED is shorthand for (:UNSIGNED 32).</p>
<li><p>Aliases for other (perhaps more complicated) types
            can be defined via ccl:def-foreign-type (sort of like
            cl:deftype or the C typedef facility). The type :char is
            defined as an alias for (:SIGNED8) on some platforms, as
            (:UNSIGNED 8) on others.</p>
<li><p>The construct (:struct <EMPH>name</EMPH>)
	        can be used to refer to a named structure type; (:UNION
	        <EMPH>name</EMPH>) can be used to refer to a named
	        union type. It isn't necessary to enumerate a structure or
	        union type's fields in order to refer to the type.</p>
<li><p>If <EMPH>X</EMPH> is a valid foreign type
	        reference,then (:* <EMPH>X</EMPH>) denotes the foreign
	        type “pointer to <EMPH>X</EMPH>”. By convention, (:* T)
	        denotes an anonymous pointer type, vaguely equivalent
	        to <CODE>void *</CODE> in C.</p>
<li><p>If a fieldlist is a list of lists, each of whose CAR
	        is a foreign field name (keyword) and whose CADR is a
	        foreign type specifier, then (:STRUCT
	        <EMPH>name</EMPH> ,@fieldlist) is a definition of
	        the structure type <EMPH>name</EMPH>,
	        and (:UNION <EMPH>name</EMPH> ,@fieldlist) is a
	        definition of the union type
	        <EMPH>name</EMPH>. Note that it's necessary
	        to define a structure or union type in order to include
	        that type in a structure, union, or array, but only
	        necessary to refer to a structure or union type in order
	        to define a type alias or a pointer type.</p>
<li><p>If <EMPH>X</EMPH> is a defined foreign type,
              then (:array <EMPH>X</EMPH> &amp;rest dims)
	        denotes the foreign type “array of
	        <EMPH>X</EMPH>”. Although multiple array dimensions
	        are allowed by the :array constructor,
	        only single-dimensioned arrays are (at all) well-supported
	        in Clozure CL.</p>
</ul>
</div>
<a id="foreign-function-calls"></a>
<H3>Foreign Function Calls</H3>
<div class="section">
<a id="overview_in_foreign-function-calls"></a>
<H4>Overview</H4>
<div class="section">
<p>Clozure CL provides a number of constructs for calling foreign
        functions from Lisp code, all of which are based on the
        function <a href="#f_._ff-call"><CODE>%ff-call</CODE></a>. In many cases, Clozure CL's
        interface translator provides information about the foreign
        function's entrypoint name and argument and return types; this
        enables the use of the <CODE>#_</CODE> reader macro (described
        below), which is usually nicer to use than the than other
        constructs.</p>
<p>        Clozure CL also provides a mechanism for defining <EMPH>callbacks</EMPH>: lisp functions which can be called from foreign
        code.</p>
<p>        There's no supported way to directly pass lisp data to
        foreign functions: scalar lisp data must be coerced to an
        equivalent foreign representation, and lisp arrays (notably
        strings) must be copied to non-GCed memory.</p>
<a id="type-designators-for-arguments-and-return-values"></a>
<H5>Type Designators for Arguments and Return Values</H5>
<div class="section">
<p>The types of foreign argument and return values in foreign
	      function calls and callbacks can be specified by any of the following
          keywords:</p>
<dl><dt><CODE>:UNSIGNED-BYTE</CODE></dt>
<dd><p>The argument/return value is of type (UNSIGNED-BYTE 8)</p>
</dd>
<dt><CODE>:SIGNED-BYTE</CODE></dt>
<dd><p>The argument/return value is of type (SIGNED-BYTE 8)</p>
</dd>
<dt><CODE>:UNSIGNED-HALFWORD</CODE></dt>
<dd><p>The argument/return value is of type (UNSIGNED-BYTE 16)</p>
</dd>
<dt><CODE>:SIGNED-HALFWORD</CODE></dt>
<dd><p>The argument/return value is of type (SIGNED-BYTE 16)</p>
</dd>
<dt><CODE>:UNSIGNED-FULLWORD</CODE></dt>
<dd><p>The argument/return value is of type (UNSIGNED-BYTE 32)</p>
</dd>
<dt><CODE>:SIGNED-FULLWORD</CODE></dt>
<dd><p>The argument/return value is of type (SIGNED-BYTE 32)</p>
</dd>
<dt><CODE>:UNSIGNED-DOUBLEWORD</CODE></dt>
<dd><p>The argument/return value is of type (UNSIGNED-BYTE 64)</p>
</dd>
<dt><CODE>:SIGNED-DOUBLEWORD</CODE></dt>
<dd><p>The argument/return value is of type (SIGNED-BYTE 64)</p>
</dd>
<dt><CODE>:SINGLE-FLOAT</CODE></dt>
<dd><p>The argument/return value is of type SINGLE-FLOAT</p>
</dd>
<dt><CODE>:DOUBLE-FLOAT</CODE></dt>
<dd><p>The argument/return value is of type DOUBLE-FLOAT</p>
</dd>
<dt><CODE>:ADDRESS</CODE></dt>
<dd><p>The argument/return values
		        is <a href="#referencing-and-using-foreign-memory-addresses">a MACPTR</a>.</p>
</dd>
<dt><CODE>:VOID</CODE></dt>
<dd><p>or NIL Not valid as an argument type specifier; specifies
		        that there is no meaningful return value</p>
</dd>
</dl>
<p>On some platforms, a small positive integer
          <EMPH>N</EMPH> can also be used as an argument
          specifier; it indicates that the corresponding argument is a
          pointer to an <EMPH>N</EMPH>-word structure or union
          which should be passed by value to the foreign
          function.  Exactly which foreign structures are passed
	      by value and how is very dependent on the Application
	      Binary Interface (ABI) of the platform; unless you're
	      very familiar with ABI details (some of which are quite
	      baroque), it's often easier to let higher-level constructs
	      deal with these details.</p>
</div>
<a id="external-entrypoints-and-named-external-entrypoints"></a>
<H5>External Entrypoints and Named External Entrypoints</H5>
<div class="section">
<p>PowerPC machine instructions are always aligned on
          32-bit boundaries, so the two least significant bits of the
          first instruction (the entrypoint) of a foreign function are
          always 0. Clozure CL often represents an entrypoint address as
          a fixnum that's binary-equivalent to the entrypoint address:
          if<EMPH>E</EMPH> is an entrypoint address expressed
          as a signed 32-bit integer, then (ash <EMPH>E</EMPH>
          -2) is an equivalent fixnum representation of that
          address. An entrypoint address can also be encapsulated in a
          MACPTR, but that's somewhat less efficient.</p>
<p>          Although it's possible to use fixnums or macptrs to
          represent entrypoint addresses, it's somewhat cumbersome to
          do so. Clozure CL can cache the addresses of named external
          functions in structure-like objects of type
          CCL:EXTERNAL-ENTRY-POINT (sometimes abbreviated as EEP).
          Through the use of LOAD-TIME-VALUE, compiled lisp functions
          are able to reference EEPs as constants; the use of an
          indirection allows Clozure CL runtime system to ensure that the
          EEP's address is current and correct.</p>
</div>
</div>
<a id="return-conventions-for-c-structures"></a>
<H4>Return Conventions for C Structures</H4>
<div class="section">
<p>On some platforms, C functions that are defined to
        return structures do so by reference: they actually
        accept a first parameter of type “pointer to returned
        struct/union” - which must be allocated by the caller - and
        don't return a meaningful value.</p>
<p>	    <EMPH>Exactly</EMPH> how a C function that's
	    defined to return a foreign structure does so is dependent on
	    the ABI (and on the size and composition of the structure/union
	    in many cases.)</p>
</div>
</div>
<a id="referencing-and-using-foreign-memory-addresses"></a>
<H3>Referencing and Using Foreign Memory Addresses</H3>
<div class="section">
<a id="overview_in_referencing-and-using-foreign-memory-addresses"></a>
<H4>Overview</H4>
<div class="section">
<a id="basics"></a>
<H5>Basics</H5>
<div class="section">
<p>For a variety of technical reasons, it isn't generally
          possible to directly reference arbitrary absolute addresses
          (such as those returned by the C library function malloc(),
          for instance) in Clozure CL. In Clozure CL (and in MCL), such
          addresses need to be <EMPH>encapsulated</EMPH> in
          objects of type CCL:MACPTR; one can think of a MACPTR as
          being a specialized type of structure whose sole purpose is
          to provide a way of referring to an underlying raw
          address.</p>
<p>          It's sometimes convenient to blur the distinction
          between a MACPTR and the address it represents; it's
          sometimes necessary to maintain that distinction. It's
          important to remember that a MACPTR is (generally) a
          first-class Lisp object in the same sense that a CONS cell
          is: it'll get GCed when it's no longer possible to reference
          it. The lifetime of a MACPTR doesn't generally have
          anything to do with the lifetime of the block of memory its
          address points to.</p>
<p>          It might be tempting to ask “How does one obtain the
          address encapsulated by a macptr?”. The answer to that
          question is that one doesn't do that (and there's no way to
          do that): addresses aren't first-class objects, and there's
          no way to refer to one.</p>
<p>          Two MACPTRs that encapsulate the same address are EQL
          to each other.</p>
<p>          There are a small number of ways to directly create a
          MACPTR (and there's a fair amount of syntactic sugar built
          on top of of those primitives.) These primitives will be
          discussed in greater detail below, but they include:</p>
<ul><li><p>Creating a MACPTR with a specified address, usually
	          via the function CCL:%INT-TO-PTR.</p>
<li><p>Referencing the return value of a foreign function
	          call (see )that's specified to return an address.</p>
<li><p>Referencing a memory location that's specified to
	          contain an address.</p>
</ul>
<p>All of these primitive MACPTR-creating operations are
          usually open-coded by the compiler; it has a fairly good
          notion of what low-level operations produce MACPTRs and
          which operations consume the addresses that the
          encapsulate, and will usually optimize out the introduction
          of intermediate MACPTRs in a simple expression.</p>
<p>          One consequence of the use of MACPTR objects to
          encapsulate foreign addresses is that (naively)
          <EMPH>every reference to a foreign address causes a
            MACPTR to be allocated.</EMPH></p>
<p>Consider a code fragment like the following:</p>
<pre class="source-code">(defun get-next-event ()
  "get the next event from a hypothetical window system"
  (loop
     (let* ((event (#_get_next_window_system_event))) ; via an FF-CALL
       (unless (null-event-p event)
         (handle-event event)))))
</pre>
<p>As this is written, each call to the (hypothetical)
          foreign function #_get_next_window_system_event will return
          a new MACPTR object.  Ignoring for the sake of argument the
          question of whether this code fragment exhibits a good way
          to poll for external events (it doesn't), it's not hard to
          imagine that this loop could execute several million times
          per second (producing several million MACPTRs per second.)
          Clearly, the naive approach is impractical in many
          cases.</p>
</div>
<a id="stack-allocation-of-and-destructive-operations-on-macptrs."></a>
<H5>Stack allocation of-and destructive operations on-MACPTRs.</H5>
<div class="section">
<p>If certain conditions held in the environment in which
	      GET-NEXT-EVENT ran-namely, if it was guaranteed that
	      neither NULL-EVENT-P nor HANDLE-EVENT cached or otherwise
	      retained their arguments (the “event” pointer)-there'd be
	      a few alternatives to the naive approach. One of those
	      approaches would be to use the primitive function
	      %SETF-MACPTR (described in greater detail below) to
	      destructively modify a MACPTR (to change the value of the
	      address it encapsulates.) The GET-NEXT-EVENT example could
	      be re-written as:</p>
<pre class="source-code">(defun get-next-event ()
  (let* ((event (%int-to-ptr 0)))     ; create a MACPTR with address 0
    (loop
       (%setf-macptr event (#_get_next_window_system_event)) ; re-use it
       (unless (null-event-p event)
         (handle-event event)))))
        
</pre>
<p>That version's a bit more realistic: it allocates a
          single MACPTR outside if the loop, then changes its address
          to point to the current address of the hypothetical event
          structure on each loop iteration. If there are a million
          loop iterations per call to GET-NEXT-EVENT, we're allocating
          a million times fewer MACPTRs per call; that sounds like a
          Good Thing.</p>
<p>          An Even Better Thing would be to advise the compiler
          that the initial value (the null macptr) bound to the
          variable event has dynamic extent (that value won't be
          referenced once control leaves the extent of the binding of
          that variable.) Common Lisp allows us to make such an
          assertion via a dynamic-extent declaration; Clozure CL's
          compiler can recognize the primitive macptr-creating
          operation involved and can replace it with an equivalent
          operation that stack-allocates the macptr object. If we're
          not worried about the cost of allocating that macptr on
          every iteration (the cost is small and there's no hidden GC
          cost), we could move the binding back inside the
          loop:</p>
<pre class="source-code">(defun get-next-event ()
  (loop
     (let* ((event (%null-ptr))) ; (%NULL-PTR) is shorthand for (%INT-TO-PTR 0)
       (declare (dynamic-extent event))
       (%setf-macptr event (#_get_next_window_system_event))
       (unless (null-event-p event)
         (handle-event event)))))
        
</pre>
<p>The idiom of binding one or more variables to
          stack-allocated MACPTRs, then destructively modifying those
          MACPTRs before executing a body of code is common enough
          that Clozure CL provides a macro (WITH-MACPTRS) that handles
          all of the gory details. The following version of
          GET-NEXT-EVENT is semantically equivalent to the previous
          version, but hopefully a bit more concise:</p>
<pre class="source-code">(defun get-next-event ()
  (loop
     (with-macptrs ((event (#_get_next_window_system_event)))
       (unless (null-event-p event)
         (handle-event event)))))
        
</pre>
</div>
<a id="stack-allocated-memory-and-stack-allocated-pointers-to-it."></a>
<H5>Stack-allocated memory (and stack-allocated pointers to it.)</H5>
<div class="section">
<p>Fairly often, the blocks of foreign memory (obtained
	      by malloc or something similar) have well-defined lifetimes
	      (they can safely be freed at some point when it's known that
	      they're no longer needed and it's known that they're no
	      longer referenced.) A common idiom might be:</p>
<pre class="source-code">(with-macptrs (p (#_allocate_foreign_memory size))
  (unwind-protect
       (use-foreign-memory p)
    (#_deallocate_foreign_memory p)))
        
</pre>
<p>That's not unreasonable code, but it's fairly
          expensive for a number of reasons: foreign functions calls
          are themselves fairly expensive (as is UNWIND-PROTECT), and
          most library routines for allocating and deallocating
          foreign memory (things like malloc and free) can be fairly
          expensive in their own right.</p>
<p>          In the idiomatic code above, both the MACPTR P and the
          block of memory that's being allocated and freed have
          dynamic extent and are therefore good candidates for stack
          allocation. Clozure CL provides the %STACK-BLOCK macro, which
          executes a body of code with one or more variables bound to
          stack-allocated MACPTRs which encapsulate the addresses of
          stack-allocated blocks of foreign memory. Using
          %STACK-BLOCK, the idiomatic code is:</p>
<pre class="source-code">(%stack-block ((p size))
              (use-foreign-memory p))
        
</pre>
<p>which is a bit more efficient and a bit more concise
          than the version presented earlier.</p>
<p>          %STACK-BLOCK is used as the basis for slightly
          higher-level things like RLET. (See FIXTHIS for more information
          about RLET.)</p>
</div>
<a id="caveats"></a>
<H5>Caveats</H5>
<div class="section">
<p>Reading from, writing to, allocating, and freeing
          foreign memory are all potentially dangerous operations;
          this is no less true when these operations are performed in
          Clozure CL than when they're done in C or some other
          lower-level language. In addition, destructive operations on
          Lisp objects be dangerous, as can stack allocation if it's
          abused (if DYNAMIC-EXTENT declarations are violated.)
          Correct use of the constructs and primitives described here
          is reliable and safe; even slightly incorrect use of these
          constructs and primitives can crash Clozure CL.</p>
</div>
</div>
<a id="foreign-memory-addresses-dictionary"></a>
<H4>Foreign-Memory-Addresses Dictionary</H4>
<div class="section">
<p>Unless otherwise noted, all of the symbols mentioned
        below are exported from the CCL package.</p>
<a id="scalar-memory-reference"></a>
<H5>Scalar memory reference</H5>
<div class="section">
<a id="f_._get-unsigned-byte"></a>
<div class=definition>
<code>%get-unsigned-byte</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-unsigned-byte"></a>
<p>References and returns the unsigned 8-bit byte at the effective byte
          address formed by adding <I>offset</I> to the address encapsulated by
          <I>ptr</I>.</p>
</div>
<a id="f_._get-signed-byte"></a>
<div class=definition>
<code>%get-signed-byte</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-signed-byte"></a>
<p>Like <a href="#f_._get-unsigned-byte"><CODE>%get-unsigned-byte</CODE></a> above, but returns
          the signed 8-bit byte at the computed address.</p>
</div>
<a id="f_._get-unsigned-word"></a>
<div class=definition>
<code>%get-unsigned-word</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-unsigned-word"></a>
<p>References and returns the unsigned 16-bit word at the effective byte
          address formed by adding <I>offset</I> to the address encapsulated by
          <I>ptr</I>.</p>
</div>
<a id="f_._get-signed-word"></a>
<div class=definition>
<code>%get-signed-word</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-signed-word"></a>
<p>Like <a href="#f_._get-unsigned-word"><CODE>%get-unsigned-word</CODE></a> above, but returns
          the signed 16-bit word at the computed address.</p>
</div>
<a id="f_._get-unsigned-long"></a>
<div class=definition>
<code>%get-unsigned-long</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-unsigned-long"></a>
<p>References and returns the unsigned 32-bit long word at the effective byte
          address formed by adding <I>offset</I> to the address encapsulated by
          <I>ptr</I>.</p>
</div>
<a id="f_._get-signed-long"></a>
<div class=definition>
<code>%get-signed-long</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-signed-long"></a>
<p>Like <a href="#f_._get-unsigned-long"><CODE>%get-unsigned-long</CODE></a> above, but returns
          the signed 32-bit long word at the computed address.</p>
</div>
<a id="f_.._get-unsigned-longlong"></a>
<div class=definition>
<code>%%get-unsigned-longlong</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_.._get-unsigned-longlong"></a>
<p>References and returns the unsigned 64-bit long long word at the effective byte
          address formed by adding <I>offset</I> to the address encapsulated by
          <I>ptr</I>.</p>
</div>
<a id="f_.._get-signed-longlong"></a>
<div class=definition>
<code>%%get-signed-longlong</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_.._get-signed-longlong"></a>
<p>Like <a href="#f_.._get-unsigned-longlong"><CODE>%%get-unsigned-longlong</CODE></a> above, but returns
          the signed 64-bit long long word at the computed address.</p>
</div>
<a id="f_._get-ptr"></a>
<div class=definition>
<code>%get-ptr</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-ptr"></a>
<p>Returns a macptr encapsulating the address found at the effective byte address
          formed by adding <I>offset</I> to the address represented by <I>ptr</I>.</p>
</div>
<a id="f_._get-single-float"></a>
<div class=definition>
<code>%get-single-float</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-single-float"></a>
<p>Returns the <CODE>single-float</CODE> found at the effective byte address
          formed by adding <I>offset</I> to the address represented by <I>ptr</I>.</p>
</div>
<a id="f_._get-double-float"></a>
<div class=definition>
<code>%get-double-float</code> <i>ptr</i> <code>&amp;optional</code>  (<i>offset</i> <i>0</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._get-double-float"></a>
<p>Returns the <CODE>double-float</CODE> found at the effective byte address
          formed by adding <I>offset</I> to the address represented by <I>ptr</I>.</p>
</div>
<p>All of the memory reference primitives described above can be used with
        <CODE>setf</CODE>.</p>
</div>
<a id="f_._get-bit"></a>
<div class=definition>
<code>%get-bit</code> <i>ptr</i> <i>bit-offset</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._get-bit"></a>
<p>References and returns the <I>bit-offset</I>th bit at the address
        encapsulated by <I>ptr</I>. (Bit 0 at a given address is the most
        significant bit of the byte at that address.)  Can be used with
        SETF.</p>
</div>
<a id="f_._get-bitfield"></a>
<div class=definition>
<code>%get-bitfield</code> <i>ptr</i> <i>bit-offset</i> <i>width</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._get-bitfield"></a>
<p>References and returns an unsigned integer composed from the
        <I>width</I> bits found <I>bit-offset</I> bits from the address encapsulated by
        <I>ptr</I>. The least significant bit of the result is the value of
        <CODE>(%get-bit ptr (1- (+ bit-offset width)))</CODE>. Can be used with <CODE>setf</CODE>.</p>
</div>
<a id="f_._int-to-ptr"></a>
<div class=definition>
<code>%int-to-ptr</code> <i>int</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._int-to-ptr"></a>
<p>Creates and returns a macptr whose address is <I>int</I>.</p>
</div>
<a id="f_._inc-ptr"></a>
<div class=definition>
<code>%inc-ptr</code> <i>ptr</i> <code>&amp;optional</code>  (<i>delta</i> <i>1</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_._inc-ptr"></a>
<p>Creates and returns a macptr whose address is the address of
        <I>ptr</I> plus <I>delta</I>. The idiom <CODE>(%inc-ptr ptr 0)</CODE>
        is sometimes used to copy a macptr, that is, to create a new macptr
        encapsulating the same address as <I>ptr</I>.</p>
</div>
<a id="f_._ptr-to-int"></a>
<div class=definition>
<code>%ptr-to-int</code> <i>ptr</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._ptr-to-int"></a>
<p>Returns the address encapsulated by <I>ptr</I> as an integer.</p>
</div>
<a id="m_._null-ptr"></a>
<div class=definition>
<code>%null-ptr</code> <span class="definition-kind">[Macro]</span><a id="description_in_m_._null-ptr"></a>
<p>Equivalent to <CODE>(%int-to-ptr 0)</CODE>.</p>
</div>
<a id="v_null-ptr"></a>
<div class=definition>
<code>+null-ptr+</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_null-ptr"></a>
<p>This constant variable contains the result of <CODE>(%null-ptr)</CODE>.</p>
</div>
<a id="f_._null-ptr-p"></a>
<div class=definition>
<code>%null-ptr-p</code> <i>ptr</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._null-ptr-p"></a>
<p>This function returns true if <I>ptr</I> is a macptr that encapsulates the
        address 0.  It returns <CODE>nil</CODE> if <I>ptr</I> encapsulates some other address.</p>
</div>
<a id="f_._setf-macptr"></a>
<div class=definition>
<code>%setf-macptr</code> <i>dest-ptr</i> <i>src-ptr</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._setf-macptr"></a>
<p>Causes <I>dest-ptr</I> to encapsulate the same address that
        <I>src-ptr</I> does, then returns the updated <I>dest-ptr</I>.</p>
</div>
<a id="m_._incf-ptr"></a>
<div class=definition>
<code>%incf-ptr</code> <i>ptr</i> <code>&amp;optional</code>  (<i>delta</i> <i>1</i>) <span class="definition-kind">[Macro]</span><a id="description_in_m_._incf-ptr"></a>
<p>Destructively modifies <I>ptr</I> by adding <I>delta</I> to
        the address it encapsulates. Returns <I>ptr</I>.</p>
</div>
<a id="m_with-macptrs"></a>
<div class=definition>
<code>with-macptrs</code>  (<i>var</i> <i>expr)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-macptrs"></a>
<p>Executes <I>body</I> in an environment in which each <I>var</I> is bound to a stack-allocated macptr which encapsulates
        the foreign address yielded by the corresponding <I>expr</I>. Returns whatever values body returns.</p>
</div>
<a id="m_._stack-block"></a>
<div class=definition>
<code>%stack-block</code>  (<i>var</i> <i>expr)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_._stack-block"></a>
<p>Executes <I>body</I> in an environment in which each <I>var</I> is bound to a stack-allocated macptr which encapsulates
        the address of a stack-allocated region of size <I>expr</I>
        bytes. Returns whatever value(s) body returns.</p>
</div>
<a id="f_make-cstring"></a>
<div class=definition>
<code>make-cstring</code> <i>string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-cstring"></a>
<p>Allocates a block of foreign memory (via <CODE>malloc</CODE>) of
length <CODE>(1+ (length <I>string</I>))</CODE>.  It then copies <I>string</I> to this block and appends a trailing nul byte.  Returns a
macptr to the block.</p>
</div>
<a id="m_with-encoded-cstrs"></a>
<div class=definition>
<code>with-encoded-cstrs</code> <i>encoding-name</i>  (<i>var</i> <i>string)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-encoded-cstrs"></a>
<p>Executes body in an environment in which each <I>var</I> is bound
        to a macptr which encapsulates the %address of a
        stack-allocated region of into which each <I>string</I> (and a
        trailing NUL character) has been copied. Returns whatever
        value(s) body returns.</p>
<p>        The <I>encoding-name</I> should be a keyword that names a
        character encoding. Each foreign string is encoded according
        to the named encoding. Each foreign string has dynamic
        extent.</p>
<p>        Note that <a href="#m_with-encoded-cstrs"><CODE>with-encoded-cstrs</CODE></a> does not automatically
        prepend byte-order marks to the encoded strings;
        additionally, the size of the terminating <CODE>#\NUL</CODE>
        character depends on the number of octets per code unit in
        the encoding.</p>
<p>        The expression </p>
<pre class="source-code">(ccl:with-cstrs ((x "x")) (#_puts x))
</pre>
<p>is functionally equivalent to </p>
<pre class="source-code">(ccl:with-encoded-cstrs :iso-8859-1 ((x "x")) (#_puts x))
</pre>
</div>
<a id="m_with-cstrs"></a>
<div class=definition>
<code>with-cstrs</code>  (<i>var</i> <i>string)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-cstrs"></a>
<p>Executes <I>body</I> in an environment in which each <I>var</I>
         is bound to a macptr which encapsulates the address of a
         stack-allocated region of memory into which each <I>string</I> (and
         a trailing NUL character) has been copied. Returns whatever
         values body returns.</p>
<p>         This macro is hard-coded to use the <CODE>:iso-8859-1</CODE> encoding.  The macro
         <a href="#m_with-encoded-cstrs"><CODE>with-encoded-cstrs</CODE></a> allows you to specify the encoding.</p>
</div>
<a id="f_._get-cstring"></a>
<div class=definition>
<code>%get-cstring</code> <i>ptr</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._get-cstring"></a>
<p>This function interprets <I>ptr</I> as a pointer to a (null-terminated) C string,
           and returns an equivalent lisp string.</p>
</div>
<a id="f_._str-from-ptr"></a>
<div class=definition>
<code>%str-from-ptr</code> <i>ptr</i> <i>length</i> <span class="definition-kind">[Function]</span><a id="description_in_f_._str-from-ptr"></a>
<p>Returns a lisp string of length <I>length</I>,
          whose contents are initialized from the bytes at <I>ptr.</I></p>
</div>
<a id="f_get-encoded-string"></a>
<div class=definition>
<code>get-encoded-string</code> <i>encoding-name</i> <i>ptr</i> <i>len</i> <span class="definition-kind">[Function]</span><a id="description_in_f_get-encoded-string"></a>
<p>Creates and returns a lisp string from <I>len</I> octets pointed to by <I>ptr</I>
          decoded according to <I>encoding-name</I>.</p>
</div>
</div>
</div>
<a id="the-interface-database"></a>
<H3>The Interface Database</H3>
<div class="section">
<a id="overview_in_the-interface-database"></a>
<H4>Overview</H4>
<div class="section">
<p>Clozure CL uses a set of database files which contain
        foreign type, record, constant, and function definitions
        derived from the operating system's header files, be that
        Linux or Darwin.  An archive containing these database files
        (and the shell scripts which were used in their creation) is
        available; see the Distributions page for information about
        obtaining current interface database files.</p>
<p>Not surprisingly, different platforms use different database files.</p>
<p>Clozure CL defines reader macros that consult these databases:</p>
<ul><li><p>#$foo looks up the value of the constant definition of foo</p>
<li><p>#_foo looks up the foreign function definition for foo</p>
</ul>
<p>In both cases, the symbol foo is interned in the <CODE>OS</CODE>
        package. The #$ reader macro has the side-effect of defining
        foo as a constant (as if via DEFCONSTANT); the #_ reader macro
        has the side effect of defining foo as a macro which will
        expand into an (EXTERNAL-CALL form.)</p>
<p>        It's important to remember that the side-effect happens
        when the form containing the reader macro is
        read. Macroexpansion functions that expand into forms which
        contain instances of those reader macros don't do what one
        might think that they do, unless the macros are expanded in
        the same lisp session as the reader macro was read in.</p>
<p>        In addition, references to foreign type,
        structure/union, and field names (when used in the RREF/PREF
        and RLET macros) will cause these database files to be
        consulted.</p>
<p>        Since the Clozure CL sources contain instances of these
        reader macros (and references to foreign record types and
        fields), compiling Clozure CL from those sources depends on the
        ability to find and use (see <a href="#building-the-heap-image">Building the Heap Image</a>).</p>
</div>
<a id="other-issues"></a>
<H4>Other issues:</H4>
<div class="section">
<ul><li><p>Clozure CL now preserves the case of external symbols in
	        its database
	        files. See <a href="#case-sensitivity-of-foreign-names-in-clozure-cl">Case-sensitivity of foreign names in Clozure CL</a> for information about
	        case in foreign symbol names.</p>
<li><p>The Linux databases are derived from a somewhat
	        arbitrary set of Linux header files. Linux is enough of a
	        moving target that it may be difficult to define a standard,
	        reference set of interfaces from which to derive a standard,
	        reference set of database files.This seems to be less of
	        an issue with Darwin and FreeBSD.</p>
</ul>
<p>For information about building the database files,
	    see <a href="#the-interface-translator">The Interface Translator</a>.</p>
</div>
</div>
<a id="using-interface-directories"></a>
<H3>Using Interface Directories</H3>
<div class="section">
<a id="overview_in_using-interface-directories"></a>
<H4>Overview</H4>
<div class="section">
<p>As distributed, the <CODE>ccl:headers;</CODE> (for LinuxPPC)
        directory is organized like:</p>
<pre class="source-code">
        headers/
        headers/gl/
        headers/gl/C/
        headers/gl/C/populate.sh
        headers/gl/constants.cdb
        headers/gl/functions.cdb
        headers/gl/records.cdb
        headers/gl/objc-classes.cdb
        headers/gl/objc-methods.cdb
        headers/gl/types.cdb
        headers/gnome/
        headers/gnome/C/
        headers/gnome/C/populate.sh
        headers/gnome/constants.cdb
        headers/gnome/functions.cdb
        headers/gnome/records.cdb
        headers/gnome/objc-classes.cdb
        headers/gnome/objc-methods.cdb
        headers/gnome/types.cdb
        headers/gtk/
        headers/gtk/C/
        headers/gtk/C/populate.sh
        headers/gtk/constants.cdb
        headers/gtk/functions.cdb
        headers/gtk/records.cdb
        headers/gtk/objc-classes.cdb
        headers/gtk/objc-methods.cdb
        headers/gtk/types.cdb
        headers/libc/
        headers/libc/C/
        headers/libc/C/populate.sh
        headers/libc/constants.cdb
        headers/libc/functions.cdb
        headers/libc/records.cdb
        headers/libc/objc-classes.cdb
        headers/libc/objc-methods.cdb
        headers/libc/types.cdb
      
</pre>
<p>e.g, as a set of parallel subdirectories, each with a
        lowercase name and each of which contains a set of 6 database
        files and a <CODE>C</CODE> subdirectory which contains a shell script
        used in the database creation process.</p>
<p>        As one might assume, the database files in each of these
        subdirectories contain foreign type, constant, and function
        definitions - as well as Objective-C class and method info -that
        correspond (roughly) to the information contained in the
        header files associated with a “-dev” package in a Linux
        distribution.  <CODE>libc</CODE> corresponds pretty closely to the
        interfaces associated with glibc/libc6 header files, <CODE>gl</CODE>
        corresponds to an openGL+GLUT development package, <CODE>gtk</CODE>
        and <CODE>gnome</CODE> contain interface information from the GTK+1.2 and
        GNOME libraries, respectively.</p>
<p>        For Darwin, the <CODE>ccl:darwin-headers;</CODE> directory contains
        a <CODE>libc</CODE> subdirectory, whose contents roughly correspond to
        those of <CODE>/usr/include</CODE> under Darwin, as well as
        subdirectories corresponding to the MacOSX Carbon and Cocoa
        frameworks.</p>
<p>        To see the precise set of .h files used to generate the
        database files in a given interface directory, consult the
        corresponding <CODE>populate.sh</CODE> shell script (in the interface
        directory's <CODE>C</CODE> subdirectory.)</p>
<p>        The intent is that this initial set can be augmented to
        meet local needs, and that this can be done in a fairly
        incremental fashion: one needn't have unrelated header files
        installed in order to generate interface databases for a
        package of interest.</p>
<p>        Hopefully, this scheme will also make it easier to
        distribute patches and bug fixes.</p>
<p>        Clozure CL maintains a list of directories; when looking
        for a foreign type, constant, function, or record definition,
        it'll consult the database files in each directory on that
        list. Initially, the list contains an entry for the <CODE>libc</CODE>
        interface directory. Clozure CL needs to be explicitly told to
        look in other interface directories should it need to do
        so.</p>
</div>
<a id="creating-new-interface-directories"></a>
<H4>Creating new interface directories</H4>
<div class="section">
<p>This example refers to "ccl:headers;", which is
        appropriate for LinuxPPC. The procedure's analogous under
        Darwin, where the "ccl:darwin-headers;" directory would be
        used instead.</p>
<p>        To create a new interface directory, "foo", and a set of
        database files in that directory:</p>
<ol><li><p>Create a subdirectory of "ccl:headers;" named
	        "foo".</p>
<li><p>Create a subdirectory of "ccl:headers;foo;" named
	        "C".</p>
<li><p>Create a file in "ccl:headers;foo;C;" named
	        "populate.sh".</p>
<p>One way of accomplishing the above steps is:</p>
<pre class="source-code">
            ? (close (open "ccl:headers;foo;C;populate.sh" :direction :output :
                           if-does-not-exist :create :if-exists :overwrite))
          
</pre>
<li><p>Edit the file created above, using the "populate.sh"
	        files in the distribution as guidelines.</p>
<p>The file might wind up looking something like:</p>
<pre class="source-code">#/bin/sh
            h-to-ffi.sh `foo-config -cflags` /usr/include/foo/foo.h
</pre>
</ol>
<p>Refer to <a href="#the-interface-translator">The Interface Translator</a> for
        information about running the interface translator and .ffi
        parser.</p>
<p>Assuming that all went well, there should now be .cdb
        files in "ccl:headers;foo;". You can then do
        <pre class="source-code">
          ? (use-interface-dir :foo)
	    
</pre>
 
	    whenever you need to
        access the foreign type information in those database
        files.</p>
</div>
</div>
<a id="using-shared-libraries"></a>
<H3>Using Shared Libraries</H3>
<div class="section">
<a id="overview_in_using-shared-libraries"></a>
<H4>Overview</H4>
<div class="section">
<p>Clozure CL provides facilities to open and close shared
        libraries.</p>
<p>"Opening" a shared library, which is done with <a href="#f_open-shared-library"><CODE>open-shared-library</CODE></a>, maps the library's code and
        data into Clozure CL's address space and makes its exported
        symbols accessible to Clozure CL.</p>
<p>"Closing" a shared library, which is done with <a href="#f_close-shared-library"><CODE>close-shared-library</CODE></a>, unmaps the library's code
        and and removes the library's symbols from the global
        namespace.</p>
<p>A small number of shared libraries (including libc,
        libm, libdl under Linux, and the "system" library under
        Darwin) are opened by the lisp kernel and can't be
        closed.</p>
<p>        Clozure CL uses data structures of type
        EXTERNAL-ENTRY-POINT to map a foreign function name (string)
        to that foreign function's <EMPH>current</EMPH>
        address. (A function's address may vary from session to
        session as different versions of shared libraries may load at
        different addresses; it may vary within a session for similar
        reasons.)</p>
<p>        An EXTERNAL-ENTRY-POINT whose address is known is said
        to be <EMPH>resolved</EMPH>. When an external entry
        point is resolved, the shared library which defines that entry
        point is noted; when a shared library is closed, the entry
        points that it defines are made unresolved.  An
        EXTERNAL-ENTRY-POINT must be in the resolved state in order to
        be FF-CALLed; calling an unresolved entry point causes a "last
        chance" attempt to resolve it. Attempting to resolve an
        entrypoint that was defined in a closed library will cause an
        attempt to reopen that library.</p>
<p>        Clozure CL keeps track of all libraries that have been
        opened in a lisp session. When a saved application is first
        started, an attempt is made to reopen all libraries that were
        open when the image was saved, and an attempt is made to
        resolve all entry points that had been referenced when the
        image was saved. Either of these attempts can fail "quietly",
        leaving some entry points in an unresolved state.</p>
<p>        Linux shared libraries can be referred to either by a
        string which describes their full pathname or by their
        <EMPH>soname</EMPH>, a shorter string that can be
        defined when the library is created. The dynamic linker
        mechanisms used in Linux make it possible (through a series of
        filesystem links and other means) to refer to a library via
        several names; the library's soname is often the most
        appropriate identifier.</p>
<p>        so names are often less version-specific than other names
        for libraries; a program that refers to a library by the name
        "libc.so.6" is more portable than one which refers to
        "libc-2.1.3.so" or to "libc-2.2.3.so", even though the latter
        two names might each be platform-specific aliases of the
        first.</p>
<p>        All of the global symbols described below are exported
        from the CCL package.</p>
</div>
<a id="limitations-and-known-bugs_in_using-shared-libraries"></a>
<H4>Limitations and known bugs</H4>
<div class="section">
<ul><li><p>Don't get me started.</p>
<li><p>The underlying functionality has a poor notion of
	        dependency;it's not always possible to open libraries that
	        depend on unopened libraries, but it's possible to close
	        libraries on which other libraries depend. It
	        <EMPH>may</EMPH> be possible to generate
	        more explicit dependency information by parsing the output
	        of the Linux ldd and ldconfig programs.</p>
</ul>
</div>
<a id="darwin-notes"></a>
<H4>&gt;Darwin Notes</H4>
<div class="section">
<p>Darwin shared libraries come in two (basic) flavors:</p>
<ul><li><p>"dylibs" (which often have the extension".dylib") are
	        primarily intended to be linked against at compile/link
	        time. They can be loaded dynamically,<EMPH>but can't
	        be unloaded</EMPH>. Accordingly,OPEN-SHARED-LIBRARY
	        can be used to open a .dylib-style library;calling
	        CLOSE-SHARED-LIBRARY on the result of such a call produces
	        a warning, and has no other effect. It appears that (due
	        to an OS bug) attempts to open .dylib shared-libraries
	        that are already open can cause memory corruption unless
	        the full pathname of the .dylib file is specified on the
	        first and all subsequent calls.</p>
<li><p>"bundles" are intended to serve as application
	        extensions; they can be opened multiple times (creating
	        multiple instances of the library!) and closed
	        properly.</p>
</ul>
<p>Thanks to Michael Klingbeil for getting both kinds of
        Darwin shared libraries working in Clozure CL.</p>
</div>
</div>
<a id="the-interface-translator"></a>
<H3>The Interface Translator</H3>
<div class="section">
<a id="overview_in_the-interface-translator"></a>
<H4>Overview</H4>
<div class="section">
<p>Clozure CL uses an interface translation system based on the FFIGEN
	    system, which is described at
	    <a href="http://www.ccs.neu.edu/home/lth/ffigen/">this page</a>

	    The interface translator makes
	    the constant, type, structure, and function definitions in a set of
	    C-language header files available to lisp code.</p>
<p>        The basic idea of the FFIGEN scheme is to use the C
        compiler's frontend and parser to translate .h files into
        semantically equivalent .ffi files, which represent the
        definitions from the headers using a syntax based on
        S-expressions.  Lisp code can then concentrate on the .ffi
        representation, without having to concern itself with the
        semantics of header file inclusion or the arcana of C
        parsing.</p>
<p>        The original FFIGEN system used a modified version of
        the LCC C compiler to produce .ffi files. Since many OS
        header files contain GCC-specific constructs, Clozure CL's
        translation system uses a modified version of GCC (called,
        somewhat confusingly, ffigen.)</p>
<p>	See <a href="http://trac.clozure.com/openmcl/wiki/BuildFFIGEN">here</a>
 for information on building and installing ffigen.</p>
<p>        A component shell script called h-to-ffi.sh reads a
        specified .h file (and optional preprocessor arguments) and writes
         a (hopefully) equivalent .ffi file to standard output, calling 
        the ffigen program with appropriate  arguments.</p>
<p>        For each interface directory (see FIXTHIS)
        <EMPH>subdir</EMPH> distributed with Clozure CL, a shell
        script (distributed with Clozure CL as
        "ccl:headers;<EMPH>subdir</EMPH>;C;populate.sh"
        (or some other platform-specific headers directory)
        calls h-to-ffi.sh on a large number of the header
        files in /usr/include (or some other <EMPH>system header
          path</EMPH>) and creates a parallel directory tree in
        "ccl:headers;<EMPH>subdir</EMPH>;C;<EMPH>system</EMPH>;<EMPH>header</EMPH>;<EMPH>path</EMPH>;"
        (or
        "ccl:darwin-headers;<EMPH>subdir</EMPH>;C;<EMPH>system</EMPH>;<EMPH>header</EMPH>;<EMPH>path</EMPH>;", etc.),
        populating that directory with .ffi files.</p>
<p>        A lisp function defined in "ccl:library;parse-ffi.lisp"
        reads the .ffi files in a specified interface directory
        <EMPH>subdir</EMPH> and generates new versions of the
        databases (files with the extension .cdb).</p>
<p>        The CDB databases are used by the #$ and #_ reader
        macros and are used in the expansion of RREF, RLET, and
        related macros.</p>
</div>
<a id="details-rebuilding-the-cdb-databases-step-by-step"></a>
<H4>Details: rebuilding the CDB databases, step by step</H4>
<div class="section">
<ol><li><p>Ensure that the FFIGEN program is installed. See
	        the"README" file generated during the FFIGEN build process for
	        specific installation instructions.This example assumes
	        LinuxPPC; for other platforms, substitute the appropriate
		headers directory. </p>
<li><p>Edit the
	        "ccl:headers;<EMPH>subdir</EMPH>;C;populate.sh"shell
	        script. When you're confident that the files
	        and preprocessor options match your environment, cd to
	        the"ccl:headers;<EMPH>subdir</EMPH>;C;" directory
	        and invoke ./populate.sh. Repeat this step until you're
	        able to cleanly translate all files referenced in the shell
	        script.</p>
<li><p>Run Clozure CL:
            <pre class="source-code"><p>
              ? (require "PARSE-FFI")
              PARSE-FFI</p>
<p>              ? (ccl::parse-standard-ffi-files :SUBDIR)
              ;;; lots of output ... after a while, shiny new .cdb files should
              ;;; appear in "ccl:headers;subdir;"
          </p>
</pre>
</p>
<p>It may be necessary to call CCL::PARSE-STANDARD-FFI-FILES
                  twice, to ensure that forward-references are resolved </p>
</ol>
</div>
</div>
<a id="case-sensitivity-of-foreign-names-in-clozure-cl"></a>
<H3>Case-sensitivity of foreign names in Clozure CL</H3>
<div class="section">
<a id="overview_in_case-sensitivity-of-foreign-names-in-clozure-cl"></a>
<H4>Overview</H4>
<div class="section">
<p>As of release 0.11, Clozure CL addresses the fact that
	    foreign type, constant, record, field, and function nams are
	    case-sensitive and provides mechanisms to refer to these names
	    via lisp symbols.</p>
<p>        Previous versions of Clozure CL have tried to ignore that
        fact, under the belief that case conflicts were rare and that
        many users (and implementors) would prefer not to deal with
        case-related issues. The fact that some information in the
        interface databases was incomplete or inaccessible because of
        this policy made it clearer that the policy was untenable. I
        can't claim that the approach described here is aesthetically
        pleasing, but I can honestly say that it's less unpleasant
        than other approaches that I'd thought of. I'd be interested
        to hear alternate proposals.</p>
<p>        The issues described here have to do with how lisp
        symbols are used to denote foreign functions, constants,
        types, records, and fields. It doesn't affect how other lisp
        objects are sometimes used to denote foreign objects. For
        instance, the first argument to the EXTERNAL-CALL macros is
        now and has always been a case-sensitive string.</p>
</div>
<a id="foreign-constant-and-function-names"></a>
<H4>Foreign constant and function names</H4>
<div class="section">
<p>The primary way of referring to foreign constant and
        function names in Clozure CL is via the #$ and #_ reader
        macros. These reader macro functions each read a symbol into
        the "OS" package, look up its constant or function definition
        in the interface database, and assign the value of the
        constant to the symbol or install a macroexpansion function on
        the symbol.</p>
<p>        In order to observe case-sensitivity, the reader-macros
        now read the symbol with (READTABLE-CASE :PRESERVE) in
        effect.</p>
<p>        This means that it's necessary to type the foreign
        constant or function name in correct case, but it isn't
        necessary to use any special escaping constructs when writing
        the variable name. For instance:</p>
<pre class="source-code">
        (#_read fd buf n) ; refers to foreign symbol "read"
        (#_READ fd buf n) ; refers to foreign symbol "READ", which may
        ; not exist ...
        #$o_rdonly ; Probably doesn't exist
        #$O_RDONLY ; Exists on most platforms
      
</pre>
</div>
<a id="foreign-type-record-and-field-names"></a>
<H4>Foreign type, record, and field names</H4>
<div class="section">
<p>Constructs like RLET expect a foreign type or record
	    name to be denoted by a symbol (typically a keyword); RREF
	    (and PREF) expect an "accessor" form, typically a keyword
	    formed by concatenating a foreign type or record name with a
	    sequence of one or more foreign field names, separated by
	    dots. These names are interned by the reader as other lisp
	    symbols are, with an arbitrary value of READTABLE-CASE in
	    effect (typically :UPCASE.) It seems like it would be very
	    tedious to force users to manually escape (via vertical bar or
	    backslash syntax) all lowercase characters in symbols used to
	    specify foreign type, record, and field names (especially
	    given that many traditional POSIX structure, type, and field
	    names are entirely lowercase.)</p>
<p>        The approach taken by Clozure CL is to allow the symbols
        (keywords) used to denote foreign type, record, and field
        names to contain angle brackets (<CODE>&lt;</CODE> and
        <CODE>&gt;</CODE>). Such symbols are translated to
	    foreign names via the following set of conventions:</p>
<ul><li><p>All instances of &lt; and &gt; in the symbol's pname
	        are balanced and don't nest.</p>
<li><p>Any alphabetic characters in the symbol's pname
	        that aren't enclosed in angle brackets are treated as
	        lower-case,regardless of the value of READTABLE-CASE and
	        regardless of the case in which they were written.</p>
<li><p>Alphabetic characters that appear within angle
	        brackets are mapped to upper-case, again regardless of how
	        they were written or interned.</p>
</ul>
<p>There may be many ways of "escaping" (with angle
	    brackets) sequences of upper-case and non-lower-case
	    characters in a symbol used to denote a foreign name. When
	    translating in the other direction, Clozure CL always escapes the
	    longest sequence that starts with an upper-case character and
	    doesn't contain a lower-case character.</p>
<p>        It's often preferable to use this canonical form of a
        foreign type name.</p>
<p>        The accessor forms used by PREF/RREF should be viewed as
        a series of foreign type/record and field names; upper-case
        sequences in the component names should be escaped with angle
        brackets, but those sequences shouldn't span components. (More
        simply, the separating dots shouldn't be enclosed, even if
        both surrounding characters need to be.)</p>
<p>        Older POSIX code tends to use lower-case exclusively for
        type, record, and field names; there are only a few cases in
        the Clozure CL sources where mixed-case names need to be
        escaped.</p>
</div>
<a id="examples_in_case-sensitivity-of-foreign-names-in-clozure-cl"></a>
<H4>Examples</H4>
<div class="section">
<pre class="source-code">
        ;;; Allocate a record of type "window".
        (rlet ((w :window)) ...)
        ;;; Allocate a record of type "Window", which is probably a
        ;;;  different type
        (rlet ((w :&lt;w&gt;indow)) ...)
        ;;; This is equivalent to the last example
        (rlet ((w :&lt;w&gt;INDOW)))
      
</pre>
</div>
</div>
<a id="reading-foreign-names"></a>
<H3>Reading Foreign Names</H3>
<div class="section">
<p>Clozure CL
      provides several reader macros to make it more convenient to
      handle foreign type, function, variable, and constant
      names. Each of these reader macros reads symbols preserving the
      case of the source text, and selects an appropriate package in
      which to intern the resulting symbol. These reader macros are
      especially useful when your Lisp code interacts extensively with
      a foreign library-for example, when using Mac OS X's Cocoa
      frameworks.</p>
<p>      These reader macros include <CODE>#_</CODE> to read foreign function
      names, <CODE>#&amp;</CODE> to read foreign variable names, <CODE>#$</CODE>
      to read foreign constant names, <CODE>#/</CODE> to
      read the names of foreign Objective-C methods, and <CODE>#&gt;</CODE> to read
      keywords that can be used as the names of types, records, and
      accessors.</p>
<p>      All of these reader macros preserve the case of the text
      that they read; beyond that similarity, each performs some
      additional work, unique to each reader macro, to create symbols
      suitable for a particular use. For example, the function,
      variable, and constant reader macros intern the resulting symbol
      in the <CODE>os</CODE> package of the running platform, but the reader
      macro for Objective-C method names interns symbols in the
      <CODE>nextstep-functions</CODE> package.</p>
<p>      You are likely to see these reader macros used extensively
      in Lisp code that works with foreign libraries; for example,
      Clozure CL IDE code, which defines numerous Objective-C classes
      and methods, uses these reader macros extensively.</p>
<p>      For more detailed descriptions of each of these reader
      macros, see the Foreign-Function-Interface Dictionary
      section.</p>
</div>
<a id="tutorial-using-basic-calls-and-types"></a>
<H3>Tutorial: Using Basic Calls and Types</H3>
<div class="section">
<p>This tutorial is meant to cover the basics of Clozure CL for
      calling external C functions and passing data back and forth.
      These basics will provide the foundation for more advanced
      techniques which will allow access to the various external
      libraries and toolkits.</p>
<p>      The first step is to start with a simple C dynamic library
      in order to actually observe what is actually passing between
      Clozure CL and C.  So, some C code is in order:</p>
<p>      Create the file typetest.c, and put the following code
      into it:</p>
<pre class="source-code"><p>
#include &lt;stdio.h&gt;</p>
<p>void
void_void_test(void)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
}</p>
<p>signed char
sc_sc_test(signed char data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %d\n", (signed int)data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}</p>
<p>unsigned char
uc_uc_test(unsigned char data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %d\n", (signed int)data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}
    </p>
</pre>
<p>This defines three functions.  If you're familiar with C,
      notice that there's no <CODE>main()</CODE>, because we're
      just building a library, not an executable.</p>
<p>      The function <CODE>void_void_test()</CODE> doesn't
      take any parameters, and doesn't return anything, but it prints
      two lines to let us know it was called.
      <CODE>sc_sc_test()</CODE> takes a signed char as a
      parameter, prints it, and returns it.
      <CODE>uc_uc_test()</CODE> does the same thing, but with an
      unsigned char.  Their purpose is just to prove to us that we
      really can call C functions, pass them values, and get values
      back from them.</p>
<p>      This code is compiled into a dynamic library on OS X
      10.3.4 with the command:</p>
<pre class="source-code"><p></p>
<p>      gcc -dynamiclib -Wall -o libtypetest.dylib typetest.c \
      -install_name ./libtypetest.dylib
    </p>
</pre>
<blockquote>
<p>Users of 64-bit platforms may need to pass options such
        as "-m64" to gcc, may need to give the output library a different
        extension (such as ".so"), and may need to user slightly different
        values for other options in order to create an equivalent test
        library.</p>
</blockquote>
<p>The -dynamiclib tells gcc that we will be compiling this
      into a dynamic library and not an executable binary program.
      The output filename is "libtypetest.dylib".  Notice that we
      chose a name which follows the normal OS X convention, being in
      the form "libXXXXX.dylib", so that other programs can link to
      the library.  Clozure CL doesn't need it to be this way, but it is
      a good idea to adhere to existing conventions.</p>
<p>      The -install_name flag is primarily used when building OS
      X "bundles".  In this case, we are not using it, so we put a
      placeholder into it, "./libtypetest.dylib".  If we wanted to use
      typetest in a bundle, the -install_name argument would be a
      relative path from some "current" directory.</p>
<p>      After creating this library, the first step is to tell
      Clozure CL to open the dynamic library.  This is done by calling
      .</p>
<pre class="source-code"><p></p>
<p>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</p>
<p>      ? (open-shared-library "/Users/andewl/openmcl/libtypetest.dylib")
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;
    </p>
</pre>
<p>You should use an absolute path here; using a relative
      one, such as just "libtypetest.dylib", would appear to work, but
      there are subtle problems which occur after reloading it.  See
      the Darwin notes on for details.  It would be a bad idea anyway,
      because software should never rely on its starting directory
      being anything in particular.</p>
<p>      This command returns a reference to the opened shared library, and
      Clozure CL also adds one to the global variable
      <CODE>ccl::*shared-libraries*</CODE>:</p>
<pre class="source-code"><p></p>
<p>      ? ccl::*shared-libraries*
      (#&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;
       #&lt;SHLIB /usr/lib/libSystem.B.dylib #x606179E&gt;)
    </p>
</pre>
<p>Before we call anything, let's check that the individual
      functions can actually be found by the system.  We don't have to
      do this, but it helps to know how to find out whether this is
      the problem, when something goes wrong.  We use <a href="#m_external-call"><CODE>external-call</CODE></a>:</p>
<pre class="source-code"><p></p>
<p>      ? (external "_void_void_test")
      #&lt;EXTERNAL-ENTRY-POINT "_void_void_test" (#x000CFDF8) /Users/andewl/openmcl/libtypetest.dylib #x638EDF6&gt;</p>
<p>      ? (external "_sc_sc_test")
      #&lt;EXTERNAL-ENTRY-POINT "_sc_sc_test" (#x000CFE50) /Users/andewl/openmcl/libtypetest.dylib #x638EB3E&gt;</p>
<p>      ? (external "_uc_uc_test")
      #&lt;EXTERNAL-ENTRY-POINT "_uc_uc_test" (#x000CFED4) /Users/andewl/openmcl/libtypetest.dylib #x638E626&gt;
    </p>
</pre>
<p>Notice that the actual function names have been "mangled"
      by the C linker.  The first function was named "void_void_test"
      in typetest.c, but in libtypetest.dylib, it has an underscore (a
      "_" symbol) before it: "_void_void_test".  So, this is the name
      which you have to use.  The mangling - the way the name is
      changed - may be different for other operating systems or other
      versions, so you need to "just know" how it's done...</p>
<p>      Also, pay particular attention to the fact that a
      hexadecimal value appears in the EXTERNAL-ENTRY-POINT.
      (#x000CFDF8, for example - but what it is doesn't matter.)
      These hex numbers mean that the function can be dereferenced.
      Functions which aren't found will not have a hex number.  For
      example:</p>
<pre class="source-code"><p></p>
<p>      ? (external "functiondoesnotexist")
      #&lt;EXTERNAL-ENTRY-POINT "functiondoesnotexist" {unresolved}  #x638E3F6&gt;
    </p>
</pre>
<p>The "unresolved" tells us that Clozure CL wasn't able to find this
      function, which means you would get an error, "Can't resolve foreign
      symbol," if you tried to call it.</p>
<p>      These external function references also are stored in a
      hash table which is accessible through a global variable,
      <CODE>ccl::*eeps*</CODE>.</p>
<p>      At this point, we are ready to try our first external
      function call:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_void_void_test" :void)
      Entered void_void_test:
      Exited  void_void_test:
      NIL
    </p>
</pre>
<p>We used , which is is the normal mechanism for accessing
      externally linked code.  The "_void_void_test" is the mangled
      name of the external function.  The :void refers to the return
      type of the function.</p>
<p>      The next step is to try passing a value to C, and getting one
      back:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_sc_sc_test" :signed-byte -128 :signed-byte)
      Entered sc_sc_test:
      Data In: -128
      Exited  sc_sc_test:
      -128
    </p>
</pre>
<p>The first :signed-byte gives the type of the first
      argument, and then -128 gives the value to pass for it.  The
      second :signed-byte gives the return type.  The return type is
      always given by the last argument to .</p>
<p>      Everything looks good.  Now, let's try a number outside
      the range which fits in one byte:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_sc_sc_test" :signed-byte -567 :signed-byte)
      Entered sc_sc_test:
      Data In: -55
      Exited  sc_sc_test:
      -55
    </p>
</pre>
<p>Hmmmm.  A little odd.  Let's look at the unsigned stuff to
      see how it reacts:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_uc_uc_test" :unsigned-byte 255 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 255
      Exited  uc_uc_test:
      255
    </p>
</pre>
<p>That looks okay.  Now, let's go outside the valid range again:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_uc_uc_test" :unsigned-byte 567 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 55
      Exited  uc_uc_test:
      55</p>
<p>      ? (external-call "_uc_uc_test" :unsigned-byte -567 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 201
      Exited  uc_uc_test:
      201
    </p>
</pre>
<p>Since a signed byte can only hold values from -128 through 127, and
      an unsigned one can only hold values from 0 through 255, any number
      outside that range gets "clipped": only the low eight bits of it
      are used.</p>
<p>        What is important to remember is that <EMPH>external
        function calls have
        very few safety checks.</EMPH>
      Data outside the valid range for its type will silently do
      very strange things; pointers outside the valid range can very well
      crash the system.</p>
<p>      That's it for our first example library.  If you're still
      following along, let's add some more C code to look at the rest
      of the primitive types.  Then we'll need to recompile the
      dynamic library, load it again, and then we can see what
      happens.</p>
<p>Add the following code to typetest.c:</p>
<pre class="source-code"><p>
int
si_si_test(int data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %d\n", data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}</p>
<p>long
sl_sl_test(long data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %ld\n", data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}</p>
<p>long long
sll_sll_test(long long data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %lld\n", data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}</p>
<p>float
f_f_test(float data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %e\n", data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}</p>
<p>double
d_d_test(double data)
{
    printf("Entered %s:\n", __FUNCTION__);
    printf("Data In: %e\n", data);
    printf("Exited  %s:\n", __FUNCTION__);
    fflush(stdout);
    return data;
}
    </p>
</pre>
<p>The command line to compile the dynamic library is the same as before:</p>
<pre class="source-code"><p></p>
<p>      gcc -dynamiclib -Wall -o libtypetest.dylib typetest.c \
      -install_name ./libtypetest.dylib
    </p>
</pre>
<p>Now, restart Clozure CL.  This step is required because
      Clozure CL cannot close and reload a dynamic library on OS
      X.</p>
<p>Have you restarted?  Okay, try out the new code:</p>
<pre class="source-code"><p></p>
<p>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</p>
<p>      ? (open-shared-library "/Users/andewl/openmcl/libtypetest.dylib")
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;</p>
<p>      ? (external-call "_si_si_test" :signed-fullword -178965 :signed-fullword)
      Entered si_si_test:
      Data In: -178965
      Exited  si_si_test:
      -178965</p>
<p>      ? ;; long is the same size as int on 32-bit machines.
      (external-call "_sl_sl_test" :signed-fullword -178965 :signed-fullword)
      Entered sl_sl_test:
      Data In: -178965
      Exited  sl_sl_test:
      -178965</p>
<p>      ? (external-call "_sll_sll_test"
      :signed-doubleword -973891578912 :signed-doubleword)
      Entered sll_sll_test:
      Data In: -973891578912
      Exited  sll_sll_test:
      -973891578912
    </p>
</pre>
<p>Okay, everything seems to be acting as expected.  However,
      just to remind you that most of this stuff has no safety net,
      here's what happens if somebody mistakes
      <CODE>sl_sl_test()</CODE> for
      <CODE>sll_sll_test()</CODE>, thinking that a long is
      actually a doubleword:</p>
<pre class="source-code"><p></p>
<p>      ? (external-call "_sl_sl_test"
      :signed-doubleword -973891578912 :signed-doubleword)
      Entered sl_sl_test:
      Data In: -227
      Exited  sl_sl_test:
      -974957576192
    </p>
</pre>
<p>Ouch.  The C function changes the value with no warning
      that something is wrong.  Even worse, it manages to pass the
      original value back to Clozure CL, which hides the fact that
      something is wrong.</p>
<p>      Finally, let's take a look at doing this with
      floating-point numbers.</p>
<pre class="source-code"><p></p>
<p>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</p>
<p>      ? (open-shared-library "/Users/andewl/openmcl/libtypetest.dylib")
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;</p>
<p>      ? (external-call "_f_f_test" :single-float -1.256791e+11 :single-float)
      Entered f_f_test:
      Data In: -1.256791e+11
      Exited  f_f_test:
      -1.256791E+11</p>
<p>      ? (external-call "_d_d_test" :double-float -1.256791d+290 :double-float)
      Entered d_d_test:
      Data In: -1.256791e+290
      Exited  d_d_test:
      -1.256791D+290
    </p>
</pre>
<p>Notice that the number ends with "...e+11" for the single-float,
      and "...d+290" for the
      double-float.  Lisp has both of these float types itself, and the
      d instead of the e is how you specify which to create.  If
      you tried to pass :double-float 1.0e2 to external-call, Lisp would
      be nice enough to notice and give you a type error.  Don't get the
      :double-float wrong, though, because then there's no protection.</p>
<p>      Congratulations!  You now know how to call external C functions from
      within Clozure CL, and pass numbers back and forth.  Now that the basic
      mechanics of calling and passing work, the next step is to examine how
      to pass more complex data structures around.</p>
<a id="acknowledgement_in_tutorial-using-basic-calls-and-types"></a>
<H4>Acknowledgement</H4>
<div class="section">
<p>This chapter was generously contributed by Andrew
	    P. Lentvorski Jr.</p>
</div>
</div>
<a id="tutorial-allocating-foreign-data-on-the-lisp-heap"></a>
<H3>Tutorial: Allocating Foreign Data on the Lisp Heap </H3>
<div class="section">
<p>Not every foreign function is so marvelously easy to use
      as the ones we saw in the last section.  Some functions require
      you to allocate a C struct, fill it with your own
      information, and pass in a pointer to that struct.  Some of them
      require you to allocate an empty struct that they will fill in
      so that you can read the information out of it.</p>
<p>    There are generally two ways to allocate foreign data.  The
    first way is to allocate it on the stack; the RLET macro is one way to do this.
    This is analogous to using automatic variables in C.  In the
    jargon of Common Lisp, data allocated this way is said to have
    dynamic extent.</p>
<p>    The other way to heap-allocate the foreign data.  This is
    analogous to calling malloc in C.  Again in the jargon of Common
    Lisp, heap-allocated data is said to have indefinite extent. If a
    function heap-allocates some data, that data remains valid even
    after the function itself exits.  This is useful for data which
    may need to be passed between multiple C calls or multiple
    threads. Also, some data may be too large to copy multiple times
    or may be too large to allocate on the stack.</p>
<p>      The big disadvantage to allocating data on the heap is
      that it must be explicitly deallocated-you need to "free" it
      when you're done with it.  Normal Lisp objects, even those with indefinite
      extent, are deallocated by the garbage collector when it can prove
      that they're no longer referenced.  Foreign data, though, is outside the
      GC's ken:  it has no way to know whether a blob of foreign data is still
      referenced by foreign code or not. It is thus up to the programmer
      to manage it manually, just as one
      does in C with malloc and free.</p>
<p>      What that means is that, if you allocate something and
      then lose track of the pointer to it, there's no way to ever
      free that memory.  That's what's called a memory leak, and if
      your program leaks enough memory it will eventually use up all
      of it!  So, you need to be careful to not lose your
      pointers.</p>
<p>      That disadvantage, though, is also an advantage for using
      foreign functions.  Since the garbage collector doesn't know
      about this memory, it will never move it around.  External C
      code needs this, because it doesn't know how to follow it to
      where it moved, the way that Lisp code does.  If you allocate
      data manually, you can pass it to foreign code and know that no
      matter what that code needs to do with it, it will be able to,
      until you deallocate it.  Of course, you'd better be sure it's
      done before you do.  Otherwise, your program will be unstable
      and might crash sometime in the future, and you'll have trouble
      figuring out what caused the trouble, because there won't be
      anything pointing back and saying "you deallocated this too
      soon."</p>
<p>And, so, on to the code...</p>
<p>      As in the last tutorial, our first step
      is to create a local dynamic library in order to help show
      what is actually going on between Clozure CL and C.  So, create the file
      ptrtest.c, with the following code:</p>
<pre class="source-code"><p>
#include &lt;stdio.h&gt;</p>
<p>void reverse_int_array(int * data, unsigned int dataobjs)
{
    int i, t;</p>
<p>    for(i=0; i&lt;dataobjs/2; i++)
        {
            t = *(data+i);
            *(data+i) = *(data+dataobjs-1-i);
            *(data+dataobjs-1-i) = t;
        }
}</p>
<p>void reverse_int_ptr_array(int **ptrs, unsigned int ptrobjs)
{
    int *t;
    int i;</p>
<p>    for(i=0; i&lt;ptrobjs/2; i++)
        {
            t = *(ptrs+i);
            *(ptrs+i) = *(ptrs+ptrobjs-1-i);
            *(ptrs+ptrobjs-1-i) = t;
        }
}</p>
<p>void
reverse_int_ptr_ptrtest(int **ptrs)
{
    reverse_int_ptr_array(ptrs, 2);</p>
<p>    reverse_int_array(*(ptrs+0), 4);
    reverse_int_array(*(ptrs+1), 4);
}
    </p>
</pre>
<p>This defines three functions.
      <CODE>reverse_int_array</CODE> takes a pointer to an array
      of <CODE>int</CODE>s, and a count telling how many items
      are in the array, and loops through it putting the elements in
      reverse.  <CODE>reverse_int_ptr_array</CODE> does the same
      thing, but with an array of pointers to <CODE>int</CODE>s.
      It only reverses the order the pointers are in; each pointer
      still points to the same thing.
      <CODE>reverse_int_ptr_ptrtest</CODE> takes an array of
      pointers to arrays of <CODE>int</CODE>s.  (With me?)  It
      doesn't need to be told their sizes; it just assumes that the
      array of pointers has two items, and that both of those are
      arrays which have four items.  It reverses the array of
      pointers, then it reverses each of the two arrays of
      <CODE>int</CODE>s.</p>
<p>      Now, compile ptrtest.c into a dynamic library using the
      command:</p>
<pre class="source-code">
      gcc -dynamiclib -Wall -o libptrtest.dylib ptrtest.c -install_name ./libptrtest.dylib
    
</pre>
<p>The function <CODE>make-heap-ivector</CODE> is the
      primary tool for allocating objects in heap memory.  It
      allocates a fixed-size Clozure CL object in heap memory.  It
      returns both an array reference, which can be used directly from
      Clozure CL, and a <CODE>macptr</CODE>, which can be used to
      access the underlying memory directly.  For example:</p>
<pre class="source-code"><p>
      ? ;; Create an array of 3 4-byte-long integers
      (multiple-value-bind (la lap)
          (make-heap-ivector 3 '(unsigned-byte 32))
        (setq a la)
        (setq ap lap))
      ;Compiler warnings :
      ;   Undeclared free variable A, in an anonymous lambda form.
      ;   Undeclared free variable AP, in an anonymous lambda form.
      #&lt;A Mac Pointer #x10217C&gt;</p>
<p>      ? a
      #(1396 2578 97862649)</p>
<p>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;
    </p>
</pre>
<p>It's important to realize that the contents of the
      <CODE>ivector</CODE> we've just created haven't been
      initialized, so their values are unpredictable, and you should
      be sure not to read from them before you set them, to avoid
      confusing results.</p>
<p>      At this point, <CODE>a</CODE> references an object
      which works just like a normal array.  You can refer to any item
      of it with the standard <CODE>aref</CODE> function, and
      set them by combining that with <CODE>setf</CODE>.  As
      noted above, the <CODE>ivector</CODE>'s contents haven't
      been initialized, so that's the next order of business:</p>
<pre class="source-code"><p>
      ? a
      #(1396 2578 97862649)</p>
<p>      ? (aref a 2)
      97862649</p>
<p>      ? (setf (aref a 0) 3)
      3</p>
<p>      ? (setf (aref a 1) 4)
      4</p>
<p>      ? (setf (aref a 2) 5)
      5</p>
<p>      ? a
      #(3 4 5)
    </p>
</pre>
<p>In addition, the <CODE>macptr</CODE> allows direct
      access to the same memory:</p>
<pre class="source-code"><p>
      ? (setq *byte-length-of-long* 4)
      4</p>
<p>      ? (%get-signed-long ap (* 2 *byte-length-of-long*))
      5</p>
<p>      ? (%get-signed-long ap (* 0 *byte-length-of-long*))
      3</p>
<p>      ? (setf (%get-signed-long ap (* 0 *byte-length-of-long*)) 6)
      6</p>
<p>      ? (setf (%get-signed-long ap (* 2 *byte-length-of-long*)) 7)
      7</p>
<p>      ? ;; Show that a actually got changed through ap
      a
      #(6 4 7)
    </p>
</pre>
<p>So far, there is nothing about this object that could not
      be done much better with standard Lisp.  However, the
      <CODE>macptr</CODE> can be used to pass this chunk of
      memory off to a C function.  Let's use the C code to reverse the
      elements in the array:</p>
<pre class="source-code"><p>
      ? ;; Insert the full path to your copy of libptrtest.dylib
      (open-shared-library "/Users/andrewl/openmcl/openmcl/gtk/libptrtest.dylib")
      #&lt;SHLIB /Users/andrewl/openmcl/openmcl/gtk/libptrtest.dylib #x639D1E6&gt;</p>
<p>      ? a
      #(6 4 7)</p>
<p>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;</p>
<p>      ? (external-call "_reverse_int_array" :address ap :unsigned-int (length a) :address)
      #&lt;A Mac Pointer #x10217C&gt;</p>
<p>      ? a
      #(7 4 6)</p>
<p>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;
    </p>
</pre>
<p>The array gets passed correctly to the C function,
      <CODE>reverse_int_array</CODE>.  The C function reverses
      the contents of the array in-place; that is, it doesn't make a
      new array, just keeps the same one and reverses what's in it.
      Finally, the C function passes control back to Clozure CL.  Since
      the allocated array memory has been directly modified, Clozure CL
      reflects those changes directly in the array as well.</p>
<p>      There is one final bit of housekeeping to deal with.
      Before moving on, the memory needs to be deallocated:</p>
<pre class="source-code">
      ? (dispose-heap-ivector a ap)
      NIL
    
</pre>
<p>The <CODE>dispose-heap-ivector</CODE> macro actually
      deallocates the ivector, releasing its memory into the heap for
      something else to use.  Both <CODE>a</CODE> and <CODE>ap</CODE>
      now have undefined values.</p>
<p>      When do you call <CODE>dispose-heap-ivector</CODE>?
      Anytime after you know the ivector will never be used again, but
      no sooner.  If you have a lot of ivectors, say, in a hash table,
      you need to make sure that when whatever you were doing with the
      hash table is done, those ivectors all get freed.  Unless
      there's still something somewhere else which refers to them, of
      course!  Exactly what strategy to take depends on the situation,
      so just try to keep things simple unless you know better.</p>
<p>      The simplest situation is when you have things set up so
      that a Lisp object "encapsulates" a pointer to foreign data,
      taking care of all the details of using it.  In this case, you
      don't want those two things to have different lifetimes: You
      want to make sure your Lisp object exists as long as the foreign
      data does, and no longer; and you want to make sure the foreign
      data doesn't get deallocated while your Lisp object still refers
      to it.</p>
<p>      If you're willing to accept a few limitations, you can
      make this easy.  First, you can't let foreign code keep a
      permanent pointer to the memory; it has to always finish what
      it's doing, then return, and not refer to that memory again.
      Second, you can't let any Lisp code that isn't part of your
      encapsulating "wrapper" refer to the pointer directly.  Third,
      nothing, either foreign code or Lisp code, should explicitly
      deallocate the memory.</p>
<p>      If you can make sure all of these are true, you can at
      least ensure that the foreign pointer is deallocated when the
      encapsulating object is about to become garbage, by using
      Clozure CL's nonstandard "termination" mechanism, which is
      essentially the same as what Java and other languages call
      "finalization".</p>
<p>      Termination is a way of asking the garbage collector to
      let you know when it's about to destroy an object which isn't
      used anymore.  Before destroying the object, it calls a function
      which you write, called a terminator.</p>
<p>      So, you can use termination to find out when a particular
      <CODE>macptr</CODE> is about to become garbage.  That's
      not quite as helpful as it might seem: It's not exactly the same
      thing as knowing that the block of memory it points to is
      unreferenced.  For example, there could be another
      <CODE>macptr</CODE> somewhere to the same block; or, if
      it's a struct, there could be a <CODE>macptr</CODE> to one
      of its fields.  Most problematically, if the address of that
      memory has been passed to foreign code, it's sometimes hard to
      know whether that code has kept the pointer.  Most foreign
      functions don't, but it's not hard to think of
      exceptions.</p>
<p>You can use code such as this to make all this happen:</p>
<pre class="source-code"><p>
      (defclass wrapper (whatever)
        ((element-type :initarg :element-type)
         (element-count :initarg :element-count)
         (ivector)
         (macptr)))</p>
<p>      (defmethod initialize-instance ((wrapper wrapper) <CODE>&amp;rest</CODE> initargs)
        (declare (ignore initargs))
        (call-next-method)
        (ccl:terminate-when-unreachable wrapper)
        (with-slots (ivector macptr element-type element-count) wrapper
          (multiple-value-bind (new-ivector new-macptr)
              (make-heap-ivector element-count element-type)
            (setq ivector new-ivector
                  macptr new-macptr))))</p>
<p>      (defmethod ccl:terminate ((wrapper wrapper))
        (with-slots (ivector macptr) wrapper
          (when ivector
            (dispose-heap-ivector ivector macptr)
            (setq ivector nil
                  macptr nil))))
    </p>
</pre>
<p>The <CODE>ccl:terminate</CODE> method will be called
      on some arbitrary thread sometime (hopefully soon) after the GC
      has decided that there are no strong references to an object
      which has been the argument of a
      <CODE>ccl:terminate-when-unreachable</CODE> call.</p>
<p>      If it makes sense to say that the foreign object should
      live as long as there's Lisp code that references it (through
      the encapsulating object) and no longer, this is one way of doing
      that.</p>
<p>      Now we've covered passing basic types back and forth with
      C, and we've done the same with pointers.  You may think this is
      all...  but we've only done pointers to basic types.  Join us
      next time for pointers... to pointers.</p>
<a id="acknowledgement_in_tutorial-allocating-foreign-data-on-the-lisp-heap"></a>
<H4>Acknowledgement</H4>
<div class="section">
<p>Much of this chapter was generously contributed by
	    Andrew P. Lentvorski Jr.</p>
</div>
</div>
<a id="the-foreign-function-interface-dictionary"></a>
<H3>The Foreign-Function-Interface Dictionary</H3>
<div class="section">
<a id="r_sharp"></a>
<div class=definition>
<code>#_</code> <span class="definition-kind">[Reader Macro]</span><a id="description_in_r_sharp"></a>
<p>Reads a symbol from the current input stream, with *PACKAGE*
	      bound to the "OS" package and with readtable-case preserved.</p>
<p>Does a lookup on that symbol in <a href="#the-interface-database">the Clozure CL interface database</a>, signalling an error if no foreign function
	      information can be found for the symbol in any active <a href="#using-interface-directories">interface directory</a>.</p>
<p>Notes the foreign function information, including the foreign
	      function's return type, the number and type of the foreign
	      function's required arguments, and an indication of whether or
	      not the function accepts additional arguments (via e.g., the
	      "varargs" mechanism in C).</p>
<p>	      Defines a macroexpansion function on the symbol, which expand
	      macro calls involving the symbol into EXTERNAL-CALL forms where
	      foreign argument type specifiers for required arguments and the
	      return value specifer are provided from the information in the
	      database.</p>
<p>Returns the symbol.</p>
<p>	      The effect of these steps is that it's possible to call
	      foreign functions that take fixed numbers of arguments by simply
	      providing argument values, as in:</p>
<pre class="source-code">(#_isatty fd)
          (#_read fd buf n)
</pre>
<p>and to call foreign functions that take variable numbers of
	      arguments by specifying the types of non-required args, as in:</p>
<pre class="source-code">(with-cstrs ((format-string "the answer is: %d"))
          (#_printf format-string :int answer))
</pre>
<p>You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</p>
<pre class="source-code">
          CL-USER&gt; #_?printf
          T
          CL-USER&gt; #_?foo
          NIL
        
</pre>
</div>
<a id="r_sharp_amp"></a>
<div class=definition>
<code>#&amp;</code> <span class="definition-kind">[Reader Macro]</span><a id="description_in_r_sharp_amp"></a>
<p>In Clozure CL 1.2 and later, the #&amp; reader macro can be used to
	      access foreign variables; this functionality depends on the presence of
	      "vars.cdb" files in the interface database. The current behavior
	      of the #&amp; reader macro is to:</p>
<p>	      Read a symbol from the current input stream, with *PACKAGE*
	      bound to the "OS" package and with readtable-case preserved.</p>
<p>	      Use that symbol's pname to access the Clozure CL interface
	      database, signalling an error if no appropriate foreign variable
	      information can be found with that name in any active interface
	      directory.</p>
<p>	      Use type information recorded in the database to construct a
	      form which can be used to access the foreign variable, and return
	      that form.</p>
<p>	      Please note that the set of foreign variables declared in header files
	      may or may not match the set of foreign variables exported from
	      libraries (we're generally talking about C and Unix here ...). When
	      they do match, the form constructed by the #&amp; reader macro manages the
	      details of resolving and tracking changes to the foreign variable's
	      address.</p>
<p>	      Future extensions (via prefix arguments to the reader macro) may
	      offer additional behavior; it might be convenient (for instance) to be
	      able to access the address of a foreign variable without dereferencing
	      that address.</p>
<p>	      Foreign variables in C code tend to be platform- and
	      package-specific (the canonical example - "errno" - is typically
	      not a variable when threads are involved. )</p>
<p>In LinuxPPC, </p>
<pre class="source-code">? #&amp;stderr
</pre>
<p>returns a pointer to the stdio error stream ("stderr" is a
	      macro under OSX/Darwin).</p>
<p>On both LinuxPPC and DarwinPPC, </p>
<pre class="source-code">? #&amp;sys_errlist
</pre>
<p>returns a pointer to a C array of C error message strings.</p>
<p>          You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</p>
<pre class="source-code">
          CL-USER&gt; #&amp;?sys_errlist
          T
          CL-USER&gt; #&amp;?foo
          NIL
        
</pre>
</div>
<a id="r_sharp_dollar"></a>
<div class=definition>
<code>#$</code> <span class="definition-kind">[Reader Macro]</span><a id="description_in_r_sharp_dollar"></a>
<p>In Clozure CL 0.14.2 and later, the #? reader macro can be used
	      to access foreign constants; this functionality depends on the
	      presence of "constants.cdb" files in the interface
	      database. The current behavior of the #$ reader macro is
	      to:</p>
<p>	      Read a symbol from the current input stream, with
	      *PACKAGE* bound to the "OS" package and with
	      readtable-case preserved.</p>
<p>	      Use that symbol's pname to access the Clozure CL interface
	      database, signalling an error if no appropriate foreign constant
	      information can be found with that name in any active interface
	      directory.</p>
<p>	      Use type information recorded in the database to construct a
	      form which can be used to access the foreign constant, and return
	      that form.</p>
<p>	      Please note that the set of foreign constants declared in
	      header files may or may not match the set of foreign constants
	      exported from libraries. When they do match, the form
	      constructed by the #$ reader macro manages the details of
	      resolving and tracking changes to the foreign constant's
	      address.</p>
<p>          You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</p>
<pre class="source-code">
          CL-USER&gt; #$?SO_KEEPALIVE
          T
          CL-USER&gt; #$?foo
          NIL
        
</pre>
</div>
<a id="r_sharp_slash"></a>
<div class=definition>
<code>#/</code> <span class="definition-kind">[Reader Macro]</span><a id="description_in_r_sharp_slash"></a>
<p>In Clozure CL 1.2 and later, the #/ reader macro can be used to
	      access foreign functions on the Darwin platform. The current
	      behavior of the #/ reader macro is to:</p>
<p>	      Read a symbol from the current input stream, with
	      *PACKAGE* bound to the "NEXTSTEP-FUNCTIONS" package, with
	      readtable-case preserved, and with any colons included.</p>
<p>          Do limited sanity-checking on the resulting symbol; for
          example, any name that contains at least one colon is required
          also to end with a colon, to conform to Objective-C
          method-naming conventions.</p>
<p>          Export the resulting symbol from the "NEXTSTEP-FUNCTIONS"
          package and return it.</p>
<p>          For example, reading "#/alloc" interns and returns
          NEXTSTEP-FUNCTIONS:|alloc|. Reading "#/initWithFrame:" interns
          and returns NEXTSTEP-FUNCTIONS:|initWithFrame:|.</p>
<p>          A symbol read using this macro can be used as an operand
          in most places where an Objective-C message name can be used, such as
          in the (OBJ:@SELECTOR ...) construct.</p>
<p>          Please note: the reader macro is not rigorous about
          enforcing Objective-C method-naming conventions. Despite the
          simple checking done by the reader macro, it may still be
          possible to use it to construct invalid names.</p>
<p>          The act of interning a new symbol in the
          NEXTSTEP-FUNCTIONS package triggers an interface database lookup
          of Objective-C methods with the corresponding message name.  If any
          such information is found, a special type of dispatching
          function is created and initialized and the new symbol is given
          the newly-created dispatching function as its function
          definition.</p>
<p>          The dispatching knows how to call declared Objective-C methods
          defined on the message. In many cases, all methods have the same
          foreign type signature, and the dispatching function merely
          passes any arguments that it receives to a function that does an
          Objective-C message send with the indicated foreign argument and return
          types. In other cases, where different Objective-C messages have
          different type signatures, the dispatching function tries to
          choose a function that handles the right type signature based on
          the class of the dispatching function's first argument.</p>
<p>          If new information about Objective-C methods is introduced
          (e.g., by using additional interface files or as Objective-C
          methods are defined from lisp), the dispatch function is
          reinitialized to recognize newly-introduced foreign type
          signatures.</p>
<p>          The argument and result coercion that the bridge has
          traditionally supported is supported by the new mechanism (e.g.,
          :&lt;BOOL&gt; arguments can be specified as lisp booleans and :&lt;BOOL&gt;
          results are returned as lisp boolean values, and an argument
          value of NIL is coerced to a null pointer if the corresponding
          argument type is :ID.</p>
<p>          Some Objective-C methods accept variable numbers of
          arguments; the foreign types of non-required arguments are
          determined by the lisp types of those arguments (e.g., integers
          are passed as integers, floats as floats, pointers as pointers,
          record types by reference.)</p>
<p>Examples:</p>
<pre class="source-code"><p>
          ;;; #/alloc is a known message.
          ? #'#/alloc
          #&lt;OBJC-DISPATCH-FUNCTION NEXTSTEP-FUNCTIONS:|alloc| #x300040E94EBF&gt;
          ;;; Sadly, #/foo is not ...
          ? #'#/foo
          &gt; Error: Undefined function: NEXTSTEP-FUNCTIONS:|foo|</p>
<p>          ;;; We can send an "init" message to a newly-allocated instance of
          ;;; "NSObject" by:</p>
<p>          (send (send ns:ns-object 'alloc) 'init)</p>
<p>          ;;; or by</p>
<p>          (#/init (#/alloc ns:ns-object))
        </p>
</pre>
<p>Objective-C methods that "return" structures return them
          as garbage-collectable pointers when called via dispatch
          functions.  For example, if "my-window" is an NS:NS-WINDOW
          instance, then</p>
<pre class="source-code">
          (#/frame my-window)
        
</pre>
<p>returns a garbage-collectable pointer to a structure that
          describes that window's frame rectangle. This convention means
          that there's no need to use SLET or special structure-returning
          message send syntax; keep in mind, though, that #_malloc,
          #_free, and the GC are all involved in the creation and eventual
          destruction of structure-typed return values. In some programs
          these operations may have an impact on performance.</p>
</div>
<a id="r_sharp_gt"></a>
<div class=definition>
<code>#&gt;</code> <span class="definition-kind">[Reader Macro]</span><a id="description_in_r_sharp_gt"></a>
<p>In Clozure CL 1.2 and later, the #&gt; reader macro reads
          the following text as a keyword, preserving the case of the
          text. For example:</p>
<pre class="source-code">
          CL-USER&gt; #&gt;FooBar
          :&lt;F&gt;OO&lt;B&gt;AR
        
</pre>
<p>The resulting keyword can be used as the name of foreign
          types, records, and accessors.</p>
</div>
<a id="f_close-shared-library"></a>
<div class=definition>
<code>close-shared-library</code> <i>library</i> <code>&amp;key</code> <i>completely</i> <span class="definition-kind">[Function]</span><p>Stops using a shared library, informing the operating
	      system that it can be unloaded if appropriate.</p>
<a id="values_in_f_close-shared-library"></a>
<dl><dt><I>library</I></dt>
<dd><p>either an object of type SHLIB, or a string which
		        designates one by its so-name.</p>
</dd>
<dt><I>completely</I></dt>
<dd><p>a boolean.  The default is T.</p>
</dd>
</dl>
<a id="description_in_f_close-shared-library"></a>
<p>If <I>completely</I> is T, sets the
	      reference count of <I>library</I> to 0.  Otherwise,
	      decrements it by 1.  In either case, if the reference count
	      becomes 0, <a href="#f_close-shared-library"><CODE>close-shared-library</CODE></a>
	      frees all memory resources consumed <I>library</I>
	      and
	      causes any EXTERNAL-ENTRY-POINTs known to be defined by it to
	      become unresolved.</p>
</div>
<a id="m_defcallback"></a>
<div class=definition>
<code>defcallback</code> <i>name</i>  (<i>{arg-type-specifier</i> <i>var}*</i> <code>&amp;optional</code> <i>result-type-specifier</i>) <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p><p>Proclaims <I>name</I>
	      to be a special variable; sets its value to a
	      MACPTR which, when called by foreign code, calls a lisp function
	      which expects foreign arguments of the specified types and which
	      returns a foreign value of the specified result type. Any argument
	      variables which correspond to foreign arguments of type :ADDRESS
	      are bound to stack-allocated MACPTRs.</p>
<p>	      If <I>name</I>
	      is already a callback function pointer, its value is
	      not changed; instead, it's arranged
	      that an
	      updated version of the lisp callback function will be called.
	      This feature allows for callback functions to be redefined
	      incrementally, just like Lisp functions are.</p>
<p>	      <a href="#m_defcallback"><CODE>defcallback</CODE></a>
	      returns the callback pointer, e.g., the
	      value of <I>name</I>.</p>
</p>
<a id="values_in_m_defcallback"></a>
<dl><dt><I>name</I></dt>
<dd><p>A symbol which can be made into a special variable</p>
</dd>
<dt><I>arg-type-specifer</I></dt>
<dd><p>One of the foreign argument-type keywords,
		        described above, or an equivalent <a href="#specifying-and-using-foreign-types">foreign type specifier</a>.  In addition, if the keyword
		        :WITHOUT-INTERRUPTS is specified, the callback will be
		        executed with lisp interrupts disabled if the
		        corresponding var is non-NIL. If :WITHOUT-INTERRUPTS
		        is specified more than once, the rightmost instance
		        wins.</p>
</dd>
<dt><I>var</I></dt>
<dd><p>A symbol (lisp variable), which will be bound to a
		        value of the specified type.</p>
</dd>
<dt><I>body</I></dt>
<dd><p>A sequence of lisp forms, which should return a value
		        which can be coerced to the specified result-type.</p>
</dd>
</dl>
</div>
<a id="m_def-foreign-type"></a>
<div class=definition>
<code>def-foreign-type</code> <i>name</i> <i>foreign-type-spec</i> <span class="definition-kind">[Macro]</span><p>If name is non-<CODE>nil</CODE>, defines <I>name</I> to be an alias
       for the foreign type specified by <I>foreign-type-spec</I>. If
       <I>foreign-type-spec</I> is a named structure or union type,
       additionally defines that structure or union type.</p>
<p>       If name is <CODE>nil</CODE>, <I>foreign-type-spec</I> must be a
       named foreign struct or union definition, in which case the
       foreign structure or union definition is put in effect.</p>
<p>       Note that there are two separate namespaces for foreign type
       names: one for the names of ordinary types and one for the
       names of structs and unions.  Which one <I>name</I> refers to
       depends on <I>foreign-type-spec</I> in the obvious manner.</p>
<a id="values_in_m_def-foreign-type"></a>
<dl><dt><I>name</I></dt>
<dd><p>NIL or a keyword; the keyword may contain
		        <a href="#case-sensitivity-of-foreign-names-in-clozure-cl">escaping constructs</a>.</p>
</dd>
<dt><I>foreign-type-spec</I></dt>
<dd><p>A foreign type specifier, whose syntax is (loosely)
		        defined above.</p>
</dd>
</dl>
</div>
<a id="m_external"></a>
<div class=definition>
<code>external</code> <i>name</i> <span class="definition-kind">[Macro]</span><p>Resolves a reference to an external symbol which
	      is defined in a shared library.</p>
<a id="values_in_m_external"></a>
<dl><dt><I>name</I></dt>
<dd><p>
		        a simple-string which names an external symbol.
		        Case-sensitive.
		      </p>
</dd>
<dt><I>entry</I></dt>
<dd><p>
		        an object of type EXTERNAL-ENTRY-POINT which maintains
		        the address of the foreign symbol named by
		        <I>name</I>.
		      </p>
</dd>
</dl>
<a id="description_in_m_external"></a>
<p>If there is already an EXTERNAL-ENTRY-POINT for
	      the symbol named by <I>name</I>, finds it and
	      returns it.  If not, creates one and returns it.</p>
<p>	      Tries to resolve the entry point to a memory address,
	      and identify the containing library.</p>
<p>	      Be aware that under Darwin, external functions which
	      are callable from C have underscores prepended to their names,
	      as in "_fopen".</p>
</div>
<a id="m_external-call"></a>
<div class=definition>
<code>external-call</code> <i>name</i> <i>{arg-type-specifier</i> <i>arg}*</i> <code>&amp;optional</code> <i>result-type-specifier</i> <span class="definition-kind">[Macro]</span><p>Calls the foreign function at the address obtained by
	      resolving the external-entry-point associated with name, passing
	      the values of each arg as a foreign argument of type indicated by
	      the corresponding arg-type-specifier. Returns the foreign function
	      result (coerced to a Lisp object of type indicated by
	      result-type-specifier), or NIL if result-type-specifer is :VOID or
	      NIL</p>
<a id="values_in_m_external-call"></a>
<dl><dt><I>name</I></dt>
<dd><p>A lisp string. See external, above.</p>
</dd>
<dt><I>arg-type-specifer</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above, or an equivalent <a href="#specifying-and-using-foreign-types">foreign type specifier</a>.</p>
</dd>
<dt><I>arg</I></dt>
<dd><p>A lisp value of type indicated by the corresponding
		        arg-type-specifier</p>
</dd>
<dt><I>result-type-specifier</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above, or an equivalent <a href="#specifying-and-using-foreign-types">foreign type specifier</a>.</p>
</dd>
</dl>
</div>
<a id="f_._ff-call"></a>
<div class=definition>
<code>%ff-call</code> <i>entrypoint</i> <i>{arg-type-keyword</i> <i>arg}*</i> <code>&amp;optional</code> <i>result-type-keyword</i> <span class="definition-kind">[Function]</span><p>This is the most fundamental and lowest-level way to call
a foreign function.  It calls the foreign function at address <I>entrypoint</I>
passing the values of each <I>arg</I> as a foreign argument of type indicated
by the corresponding <I>arg-type-keyword</I>. Returns the foreign function
result (coerced to a Lisp object of type indicated by
result-type-keyword), or <CODE>nil</CODE> if result-type-keyword is <CODE>:void</CODE> or
<CODE>NIL</CODE>.</p>
<a id="values_in_f_._ff-call"></a>
<dl><dt><I>entrypoint</I></dt>
<dd><p>A fixnum or macptr</p>
</dd>
<dt><I>arg-type-keyword</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above</p>
</dd>
<dt><I>arg</I></dt>
<dd><p>A lisp value of type indicated by the corresponding
		        arg-type-keyword</p>
</dd>
<dt><I>result-type-keyword</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above</p>
</dd>
</dl>
</div>
<a id="m_ff-call"></a>
<div class=definition>
<code>ff-call</code> <i>entrypoint</i> <i>{arg-type-specifier</i> <i>arg}*</i> <code>&amp;optional</code> <i>result-type-specifier</i> <span class="definition-kind">[Macro]</span><p>Calls the foreign function at address entrypoint passing the
	      values of each arg as a foreign argument of type indicated by the
	      corresponding arg-type-specifier. Returns the foreign function
	      result (coerced to a Lisp object of type indicated by
	      result-type-specifier), or NIL if result-type-specifer is :VOID or
	      NIL</p>
<a id="values_in_m_ff-call"></a>
<dl><dt><I>entrypoint</I></dt>
<dd><p>A fixnum or MACPTR</p>
</dd>
<dt><I>arg-type-specifer</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above, or an equivalent <a href="#specifying-and-using-foreign-types">foreign type specifier</a>.</p>
</dd>
<dt><I>arg</I></dt>
<dd><p>A lisp value of type indicated by the corresponding
		        arg-type-specifier</p>
</dd>
<dt><I>result-type-specifier</I></dt>
<dd><p>One of the foreign argument-type keywords, described
		        above, or an equivalent <a href="#specifying-and-using-foreign-types">foreign type specifier</a>.</p>
</dd>
</dl>
</div>
<a id="f_foreign-symbol-address"></a>
<div class=definition>
<code>foreign-symbol-address</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_foreign-symbol-address"></a>
<p>This function tries to resolve the address of the foreign
	     symbol <I>name</I> (a lisp string). If successful, it
	     returns that address encapsulated in a macptr; otherwise,
	     it returns <CODE>nil</CODE>.</p>
</div>
<a id="f_foreign-symbol-entry"></a>
<div class=definition>
<code>foreign-symbol-entry</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_foreign-symbol-entry"></a>
<p>This function rries to resolve the address of the foreign
	     symbol <I>name</I> (a lisp string). If successful, it
	     returns a fixnum representation of that address.
	     Otherwise, it returns <CODE>nil</CODE>.</p>
</div>
<a id="f_free"></a>
<div class=definition>
<code>free</code> <i>ptr</i> <span class="definition-kind">[Function]</span><a id="description_in_f_free"></a>
<p>Free the foreign memory pointed to by <I>ptr</I> by invoking
the standard C function <CODE>free()</CODE>.  If <I>ptr</I> is a gcable
pointer (such as an object returned from <a href="#m_make-gcable-record"><CODE>ccl::make-gcable-record</CODE></a>), then <a href="#f_free"><CODE>free</CODE></a> first informs the garbage
collector that the foreign memory has been deallocted before actually
calling <CODE>free()</CODE>.</p>
</div>
<a id="f_make-heap-ivector"></a>
<div class=definition>
<code>make-heap-ivector</code> <i>element-count</i> <i>element-type</i> <span class="definition-kind">[Function]</span><p>An ivector is a one-dimensional array that's specialized to
	 a numeric or character element type.</p>
<p>	 <a href="#f_make-heap-ivector"><CODE>make-heap-ivector</CODE></a> allocates an ivector in
	  foreign memory.  The GC will never move this vector, and
	  will in fact not pay any attention to it at all.  The
	  returned pointer to it can therefore be passed safely to
	  foreign code.</p>
<p>	  The vector must be explicitly deallocated with
	  <CODE>dispose-heap-ivector</CODE>.</p>
<a id="values_in_f_make-heap-ivector"></a>
<dl><dt><I>element-count</I></dt>
<dd><p>A positive integer.</p>
</dd>
<dt><I>element-type</I></dt>
<dd><p>A type specifier.</p>
<p>		      </p>
</dd>
<dt><I>vector</I></dt>
<dd><p>A lisp vector.  The initial contents are
		      undefined.</p>
</dd>
<dt><I>mactpr</I></dt>
<dd><p>A pointer to the first byte of data stored
		      in the vector.
		      </p>
</dd>
<dt><I>size</I></dt>
<dd><p>The size of the returned vector in octets.
		      </p>
</dd>
</dl>
</div>
<a id="m_make-gcable-record"></a>
<div class=definition>
<code>make-gcable-record</code> <i>typespec</i> <code>&amp;rest</code> <i>initforms</i> <span class="definition-kind">[Macro]</span><p>Allocates a block of foreign memory suitable to hold the foreign
	      type described by <I>typespec</I>, in the same manner
	      as <a href="#m_make-record"><CODE>make-record</CODE></a>. In
	      addition, <a href="#m_make-gcable-record"><CODE>ccl::make-gcable-record</CODE></a> marks the
	      returned object gcable: in other words, it informs the garbage
	      collector that it may reclaim the object when it becomes
	      unreachable.</p>
<p>In all other respects, <a href="#m_make-gcable-record"><CODE>ccl::make-gcable-record</CODE></a> works
          the same way as <a href="#m_make-record"><CODE>make-record</CODE></a>.</p>
<p> When using gcable pointers, it's important to remember the
          distinction between a <CODE>macptr</CODE> object (which is a
          lisp object, more or less like any other) and the block of
          foreign memory that the <CODE>macptr</CODE> object points to.
          If a gcable <CODE>macptr</CODE> object is the only thing in the
          world (lisp world or foreign world) that references the
          underlying block of foreign memory, then freeing the foreign
          memory when it becomes impossible to reference it is convenient
          and sane.  If other lisp <CODE>macptr</CODE>s reference the
          underlying block of foreign memory or if the address of that
          foreign memory is passed to and retained by foreign code, having
          the GC free the memory may have unpleasant consequences if those
          other references are used.</p>
<p>          Take care, therefore, not to create a gcable record unless
          you are sure that the returned <CODE>macptr</CODE> will be the
          only reference to the allocated memory that will ever be
          used.</p>
<a id="values_in_m_make-gcable-record"></a>
<dl><dt><I>typespec</I></dt>
<dd><p>A foreign type specifier, or a keyword which is used
		        as the name of a foreign struct or union.</p>
</dd>
<dt><I>initforms</I></dt>
<dd><p>If the type denoted by <I>typespec</I>
		        is scalar, a single value appropriate for that type;
		        otherwise, a list of alternating field names and
		        values appropriate for the types of those fields.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>
		        A <CODE>macptr</CODE> which encapsulates the address of a
		        newly-allocated record on the foreign heap. The foreign
		        object returned by <a href="#m_make-gcable-record"><CODE>ccl::make-gcable-record</CODE></a>
		        is freed when the garbage collector determines that
		        the <CODE>MACPTR</CODE> object that describes it is
		        unreachable.</p>
</dd>
</dl>
</div>
<a id="m_make-record"></a>
<div class=definition>
<code>make-record</code> <i>typespec</i> <code>&amp;rest</code> <i>initforms</i> <span class="definition-kind">[Macro]</span><p>Expands into code which allocates and initializes an instance
	of the type denoted by <I>typespec</I>, on the foreign heap.
	The record is allocated using the C function <CODE>ccl::malloc</CODE>, and the user of <a href="#m_make-record"><CODE>make-record</CODE></a> must
	explicitly call the function <a href="#f_free"><CODE>free</CODE></a> to deallocate the
	record, when it is no longer needed.</p>
<p>        If <I>initforms</I> is provided, its value or values are used
	in the initialization.  When the type is a scalar, <I>initforms</I> is either a single value which can be coerced to
	that type, or no value, in which case binary 0 is used.  When
	the type is a <CODE>struct</CODE>, <I>initforms</I> is a list,
	giving field names and the values for each.  Each field is
	treated in the same way as a scalar is: If a value for it is
	given, it must be coerceable to the field's type; if not,
	binary 0 is used.</p>
<p>        When the type is an array, <I>initforms</I> may not be
	provided, because <a href="#m_make-record"><CODE>make-record</CODE></a> cannot initialize its
	values.  <a href="#m_make-record"><CODE>make-record</CODE></a> is also unable to initialize
	fields of a <CODE>struct</CODE> which are themselves <CODE>struct</CODE>s.
	The user of <a href="#m_make-record"><CODE>make-record</CODE></a> should set these values by
	another means.</p>
<p>        A possibly-significant limitation is that it must be possible
	to find the foreign type at the time the macro is expanded;
	<a href="#m_make-record"><CODE>make-record</CODE></a> signals an error if this is not the
	case.</p>
<a id="values_in_m_make-record"></a>
<dl><dt><I>typespec</I></dt>
<dd><p>A foreign type specifier, or a keyword which is used
		        as the name of a foreign struct or union.</p>
</dd>
<dt><I>initforms</I></dt>
<dd><p>If the type denoted by <I>typespec</I>
		        is scalar, a single value appropriate for that type;
		        otherwise, a list of alternating field names and
		        values appropriate for the types of those fields.</p>
</dd>
<dt><I>result</I></dt>
<dd><p>
		        A <CODE>macptr</CODE> which encapsulates the address of a
		        newly-allocated record on the foreign heap.
		      </p>
</dd>
</dl>
<a id="notes_in_m_make-record"></a>
<p>
	      It is inconvenient that <a href="#m_make-record"><CODE>make-record</CODE></a> is a
	      macro, because this means that <I>typespec</I>
	      cannot be a variable; it must be an immediate value.</p>
<p>	      If it weren't for this requirement,
	      <a href="#m_make-record"><CODE>make-record</CODE></a> could be a function.  However,
	      that would mean that any stand-alone application using it would
	      have to include a copy of the interface database
	      (see <a href="#the-interface-database">The Interface Database</a>), which is undesirable
	      because it's large.</p>
</div>
<a id="f_open-shared-library"></a>
<div class=definition>
<code>open-shared-library</code> <i>name</i> <span class="definition-kind">[Function]</span><p>Asks the operating system to load a shared library for Clozure CL to use.</p>
<a id="values_in_f_open-shared-library"></a>
<dl><dt><I>name</I></dt>
<dd><p>A SIMPLE-STRING which is presumed to be the so-name of
		        or a filesystem path to the library.</p>
</dd>
<dt><I>library</I></dt>
<dd><p>An object of type SHLIB which describes the
		        library denoted by <I>name</I>.</p>
</dd>
</dl>
<a id="description_in_f_open-shared-library"></a>
<p>If the library denoted by <I>name</I> can
	      be loaded by the
	      operating system, returns an object of type SHLIB that describes
	      the library; if the library is already open, increments a
	      reference count. If the library can't be loaded, signals a
	      SIMPLE-ERROR which contains an often-cryptic message from the
	      operating system.</p>
<a id="examples_in_f_open-shared-library"></a>
<pre class="source-code"><p>;;; Try to do something simple.
          ? (open-shared-library "libgtk.so")
          &gt; Error: Error opening shared library "libgtk.so": /usr/lib/libgtk.so: undefined symbol: gdk_threads_mutex
          &gt; While executing: OPEN-SHARED-LIBRARY</p>
<p>          ;;; Grovel around, curse, and try to find out where "gdk_threads_mutex"
          ;;; might be defined. Then try again:</p>
<p>          ? (open-shared-library "libgdk.so")
          #&lt;SHLIB libgdk.so #x3046DBB6&gt;</p>
<p>          ? (open-shared-library "libgtk.so")
          #&lt;SHLIB libgtk.so #x3046DC86&gt;</p>
<p>          ;;; Reference an external symbol defined in one of those libraries.</p>
<p>          ? (external "gtk_main")
          #&lt;EXTERNAL-ENTRY-POINT "gtk_main" (#x012C3004) libgtk.so #x3046FE46&gt;</p>
<p>          ;;; Close those libraries.</p>
<p>          ? (close-shared-library "libgtk.so")
          T</p>
<p>          ? (close-shared-library "libgdk.so")
          T</p>
<p>          ;;; Reference the external symbol again.</p>
<p>          ? (external "gtk_main")
          #&lt;EXTERNAL-ENTRY-POINT "gtk_main" {unresolved} libgtk.so #x3046FE46&gt;</p>
</pre>
<a id="notes_in_f_open-shared-library"></a>
<p>It would be helpful to describe what an soname is and give
	      examples of one.</p>
<p>	      Does the SHLIB still get returned if the library is
	      already open?</p>
</div>
<a id="m_pref"></a>
<div class=definition>
<code>pref</code> <i>ptr</i> <i>accessor-form</i> <span class="definition-kind">[Macro]</span><p>References an instance of a foreign type (or a component of a
       foreign type) accessible via <I>ptr</I>.</p>
<p>       Expands into code which references the indicated scalar type
       or component, or returns a pointer to a composite type.</p>
<p>       PREF can be used with SETF.</p>
<a id="values_in_m_pref"></a>
<dl><dt><I>ptr</I></dt>
<dd><p><a href="#referencing-and-using-foreign-memory-addresses">a MACPTR</a>.</p>
</dd>
<dt><I>accessor-form</I></dt>
<dd><p>a keyword which names a foreign type or record, as
		        described in <a href="#foreign-type-record-and-field-names">Foreign type, record, and field names</a>.
		      </p>
</dd>
</dl>
</div>
<a id="f_._reference-external-entry-point"></a>
<div class=definition>
<code>%reference-external-entry-point</code> <i>eep</i> <span class="definition-kind">[Function]</span><p>Tries to resolve the address of the external-entry-point
	     <I>eep</I> and returns a fixnum representation of that address if
	     successful; else signals an error.</p>
<a id="values_in_f_._reference-external-entry-point"></a>
<dl><dt><I>eep</I></dt>
<dd><p>An EXTERNAL-ENTRY-POINT, as obtained by the EXTERNAL
		        macro.</p>
</dd>
</dl>
</div>
<a id="m_rlet"></a>
<div class=definition>
<code>rlet</code>  (<i>var</i> <i>typespec</i> <code>&amp;rest</code> <i>initforms)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><p>Executes <I>body</I> in an environment in which each
	      var is bound to a macptr encapsulating the 
	      address of a stack-allocated foreign memory block, allocated and
	      initialized from <I>typespec</I> and <I>initforms</I> as per<a href="#m_make-record"><CODE>make-record</CODE></a>. Returns
              whatever values <I>body</I> returns.</p>
<p>Record fields that aren't explicitly initialized have
	      unspecified contents.</p>
<a id="values_in_m_rlet"></a>
<dl><dt><I>var</I></dt>
<dd><p>A symbol (a lisp variable)</p>
</dd>
<dt><I>typespec</I></dt>
<dd><p>A foreign type specifier or foreign record name.</p>
</dd>
<dt><I>initforms</I></dt>
<dd><p>As described above, for
		        <a href="#m_make-record"><CODE>make-record</CODE></a></p>
</dd>
</dl>
</div>
<a id="m_rletz"></a>
<div class=definition>
<code>rletz</code>  (<i>var</i> <i>typespec</i> <code>&amp;rest</code> <i>initforms)*</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_rletz"></a>
<p>This macro is just like <a href="#m_rlet"><CODE>rlet</CODE></a>, except that the stack-allocated
      foreign memory is zeroed.</p>
</div>
<a id="f_terminate-when-unreachable"></a>
<div class=definition>
<code>terminate-when-unreachable</code> <i>object</i> <span class="definition-kind">[Function]</span><p>The termination mechanism is a way to have the garbage
       collector run a function right before an object is about to
       become garbage.  It is very similar to the finalization
       mechanism which Java has.  It is not standard Common Lisp,
       although other Lisp implementations have similar features.  It
       is useful when there is some sort of special cleanup,
       deallocation, or releasing of resources which needs to happen
       when a certain object is no longer being used.</p>
<p>       When the garbage collector discovers that an object is no
       longer referred to anywhere in the program, it deallocates that
       object, freeing its memory.  However, if <a href="#f_terminate-when-unreachable"><CODE>terminate-when-unreachable</CODE></a> has been called on the object at
       any time, the garbage collector first invokes the generic
       function <CODE>terminate</CODE>, passing it the object as a
       parameter.</p>
<p>       Therefore, to make termination do something useful, you need to
       define a method on <CODE>terminate</CODE>.</p>
<p>       Because calling <a href="#f_terminate-when-unreachable"><CODE>terminate-when-unreachable</CODE></a> only
       affects a single object, rather than all objects of its class,
       you may wish to put a call to it in the <CODE>initialize-instance</CODE> method of a class.  Of course, this is
       only appropriate if you do in fact want to use termination for
       all objects of a given class.</p>
<a id="values_in_f_terminate-when-unreachable"></a>
<dl><dt><I>object</I></dt>
<dd><p>A CLOS object of a class for which there exists a method of the generic function <CODE>terminate</CODE>.</p>
</dd>
</dl>
<a id="example_in_f_terminate-when-unreachable"></a>
<pre class="source-code"><p>
          (defclass resource-wrapper ()
            ((resource :accessor resource)))</p>
<p>          (defmethod initialize-instance :after ((x resource-wrapper) &amp;rest initargs)
             (ccl:terminate-when-unreachable x))</p>
<p>          (defmethod ccl:terminate ((x resource-wrapper))
             (when (resource x)
                (deallocate (resource x))))</p>
</pre>
<a id="see-also_in_f_terminate-when-unreachable"></a>
<p><a href="#tutorial-allocating-foreign-data-on-the-lisp-heap">Tutorial: Allocating Foreign Data on the Lisp Heap </a></p>
</div>
<a id="f_unuse-interface-dir"></a>
<div class=definition>
<code>unuse-interface-dir</code> <i>dir-id</i> <span class="definition-kind">[Function]</span><p>Tells Clozure CL to remove the interface directory denoted by
	      <I>dir-id</I> from the list of interface directories which are
	      consulted for foreign type and function
	      information. Returns T if the directory was on the
	      search list, NIL otherwise.</p>
<a id="values_in_f_unuse-interface-dir"></a>
<dl><dt><I>dir-id</I></dt>
<dd><p>A keyword whose pname, mapped to lower case, names a subdirectory of "ccl:headers;" (or "ccl:darwin-headers;")</p>
</dd>
</dl>
</div>
<a id="f_use-interface-dir"></a>
<div class=definition>
<code>use-interface-dir</code> <i>dir-id</i> <span class="definition-kind">[Function]</span><p>Tells Clozure CL to add the interface directory denoted by
	      dir-id to the list of interface directories which it consults for
	      foreign type and function information. Arranges that that
	      directory is searched before any others.</p>
<p>Note that <a href="#f_use-interface-dir"><CODE>use-interface-dir</CODE></a>
	      merely adds an entry
	      to a search list.
	      If the named directory doesn't exist in the file system
	      or doesn't
	      contain a set of database files, a runtime error may occur
	      when Clozure CL
	      tries to open some database file in that directory, and it
	      will try to
	      open such a database file whenever it needs to find any
	      foreign type or
	      function information. <a href="#f_unuse-interface-dir"><CODE>unuse-interface-dir</CODE></a>
	      may come in
	      handy in that case.</p>
<a id="values_in_f_use-interface-dir"></a>
<dl><dt><I>dir-id</I></dt>
<dd><p>A keyword whose pname, mapped to lower case, names a
		        subdirectory of "ccl:headers;" (or
		        "ccl:darwin-headers;")</p>
</dd>
</dl>
<a id="examples_in_f_use-interface-dir"></a>
<p>One typically wants interface information to be
	      available at compile-time (or, in many cases, at read-time).
	      A typical idiom would be:</p>
<pre class="source-code">(eval-when (:compile-toplevel :execute)
          (use-interface-dir :GTK))
</pre>
<p>Using the :GTK interface directory makes available
	      information on
	      foreign types, functions, and constants.  It's generally
	      necessary to
	      load foreign libraries before actually calling the
	      foreign code, which for GTK can be done like this:</p>
<pre class="source-code">(load-gtk-libraries)
</pre>
<p>It should now be possible to do things like:</p>
<pre class="source-code">(#_gtk_widget_destroy w)
</pre>
</div>
</div>
</div>
<a id="running-other-programs-as-subprocesses"></a>
<H2>Running Other Programs as Subprocesses</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#overview_in_running-other-programs-as-subprocesses">
Overview</a>
<ul style="list-style: none">
</ul>
<li><a href="#examples_in_running-other-programs-as-subprocesses">
Examples</a>
<ul style="list-style: none">
</ul>
<li><a href="#limitations-and-known-bugs_in_running-other-programs-as-subprocesses">
Limitations and known bugs</a>
<ul style="list-style: none">
</ul>
<li><a href="#external-program-dictionary">
External-Program Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="overview_in_running-other-programs-as-subprocesses"></a>
<H3>Overview</H3>
<div class="section">
<p>Clozure CL provides primitives to run external Unix programs,
      to select and connect Lisp streams to their input and output
      sources, to (optionally) wait for their completion and to check
      their execution and exit status.</p>
<p>      All of the global symbols described below are exported
      from the CCL package.</p>
<p>      This implementation is modeled on - and uses some code
      from - similar facilities in CMUCL.</p>
</div>
<a id="examples_in_running-other-programs-as-subprocesses"></a>
<H3>Examples</H3>
<div class="section">
<pre class="source-code">
;;; Capture the output of the "uname" program in a lisp string-stream
;;; and return the generated string (which will contain a trailing
;;; newline.)
? (with-output-to-string (stream)
    (run-program "uname" '("-r") :output stream))
;;; Write a string to *STANDARD-OUTPUT*, the hard way.
? (run-program "cat" () :input (make-string-input-stream "hello") :output t)
;;; Find out that "ls" doesn't expand wildcards.
? (run-program "ls" '("*.lisp") :output t)
;;; Let the shell expand wildcards.
? (run-program "sh" '("-c" "ls *.lisp") :output t)
</pre>
<p>These last examples will only produce output if Clozure CL's
      current directory contains .lisp files, of course.</p>
</div>
<a id="limitations-and-known-bugs_in_running-other-programs-as-subprocesses"></a>
<H3>Limitations and known bugs</H3>
<div class="section">
<ul><li><p>Clozure CL and the external process may get
        confused about who owns which streams when input, output, or
        error are specified as T and wait is specified as
        NIL.</p>
<li><p>External processes that need to talk to a
        terminal device may not work properly; the environment (SLIME,
        ILISP) under which Clozure CL is run can affect
        this.</p>
</ul>
</div>
<a id="external-program-dictionary"></a>
<H3>External-Program Dictionary</H3>
<div class="section">
<a id="f_run-program"></a>
<div class=definition>
<code>run-program</code> <i>program</i> <i>args</i> <code>&amp;key</code>  (<i>wait</i> <i>t</i>) <i>pty</i> <i>sharing</i> <i>input</i> <i>if-input-does-not-exist</i> <i>output</i>  (<i>if-output-exists</i> <i>:error</i>)  (<i>error</i> <i>:output</i>)  (<i>if-error-exists</i> <i>:error</i>) <i>status-hook</i> <i>external-format</i> <i>env</i>  (<i>silently-ignore-catastrophic-failures</i> <i>*silently-ignore-catastrophic-failure-in-run-program*</i>) <span class="definition-kind">[Function]</span><p>Invokes an external program as an OS subprocess
	    of lisp.</p>
<a id="arguments-and-values_in_f_run-program"></a>
<dl><dt><I>program</I></dt>
<dd><p>A string or pathname which denotes an executable file.
		  The PATH environment variable is used to find programs whose
		  name doesn't contain a directory component.</p>
</dd>
<dt><I>args</I></dt>
<dd><p>A list of simple-strings</p>
</dd>
<dt><I>wait</I></dt>
<dd><p>Indicates whether or not run-program should wait for
		  the EXTERNAL-PROCESS to complete or should return
		  immediately.</p>
</dd>
<dt><I>pty</I></dt>
<dd><p>This option is accepted but currently ignored;
		  it's intended to make it easier to run external programs
		  that need to interact with a terminal device.</p>
</dd>
<dt><I>sharing</I></dt>
<dd><p>Sets a specific sharing mode
                  (see <a href="#additional-keywords-for-open-and-make-socket">Additional keywords for OPEN and MAKE-SOCKET</a>) for any streams created
                  within RUN-PROGRAM when INPUT, OUTPUT or ERROR are requested
                  to be a :STREAM.</p>
</dd>
<dt><I>input</I></dt>
<dd><p>Selects the input source used by the EXTERNAL-PROCESS.
		  May be any of the following:</p>
<ul><li><p>NIL Specifies that a null input stream (e.g.,
		      /dev/null) should be used.</p>
<li><p>T Specifies that the EXTERNAL-PROCESS should use
		      the input source with which Clozure CL was invoked.</p>
<li><p>A string or pathname. Specifies that the
		      EXTERNAL-PROCESS should receive its input from the named
		      existing file.</p>
<li><p>:STREAM Creates a Lisp stream opened for character
		      output. Any data written to this stream (accessible as
		      the EXTERNAL-PROCESS-INPUT-STREAM of the
		      EXTERNAL-PROCESS object) appears as input to the
		      external process.</p>
<li><p>A stream. Specifies that the lisp stream should
		      provide input to the EXTERNAL-PROCESS.</p>
</ul>
</dd>
<dt><I>if-input-does-not-exist</I></dt>
<dd><p>If the input argument specifies the name of an
		  existing file, this argument is used as the
		  if-does-not-exist argument to OPEN when that file is opened.</p>
</dd>
<dt><I>output</I></dt>
<dd><p>Specifies where standard output from the external
		  process should be sent. Analogous to input above.</p>
</dd>
<dt><I>if-output-exists</I></dt>
<dd><p>If output is specified as a string or pathname, this
		  argument is used as the if-exists argument to OPEN when that
		  file is opened.</p>
</dd>
<dt><I>error</I></dt>
<dd><p>Specifies where error output from the external process
		  should be sent. In addition to the values allowed for
		  output, the keyword :OUTPUT can be used to indicate that
		  error output should be sent where standard output goes.</p>
</dd>
<dt><I>if-error-exists</I></dt>
<dd><p>Analogous to if-output-exists.</p>
</dd>
<dt><I>status-hook</I></dt>
<dd><p>A user-defined function of one argument (the
		  EXTERNAL-PROCESS structure.) This function is called
		  whenever Clozure CL detects a change in the status of the
		  EXTERNAL-PROCESS.</p>
</dd>
<dt><I>external-format</I></dt>
<dd><p>
		    The external format (see <a href="#external-formats">External Formats</a>) for all of the
		    streams (input, output, and error) used to
		    communicate with the external process.
		  </p>
</dd>
<dt><I>env</I></dt>
<dd><p>
		    New OS environment variable bindings for the
		    external process.  By default the external process
		    inherits the environment of the running Lisp
		    process.  Env is an association list with elements
		    (&lt;Environment Variable
		    Name&gt; . &lt;Value&gt;). Name and
		    value are case sensitive strings. See <a href="#f_setenv"><CODE>setenv</CODE></a>.
		  </p>
</dd>
<dt><I>silently-ignore-catastrophic-failures</I></dt>
<dd><p>
		    If NIL, signal an error if run-program is unable
		    to start the program. If non-NIL, treat failure to
		    start the same as failure from the program itself,
		    by setting the status and exit-code
		    fields. Default is
		    <CODE>ccl::*silently-ignore-catastrophic-failure-in-run-program*</CODE>.
		  </p>
</dd>
</dl>
<a id="description_in_f_run-program"></a>
<p>Runs the specified program in an external (Unix) process,
	    returning an object of type EXTERNAL-PROCESS if successful.</p>
<p>            The implementation involves a lisp process/thread which
            monitors the status of this external process and arranges for
            the standard I/O descriptors for the external process to be
            connected to the specified lisp streams.  Since this may require
            the monitoring thread to do I/O on lisp streams in some cases,
            streams provided as the values of the <CODE>:INPUT</CODE>,
            <CODE>:OUTPUT</CODE>, and <CODE>:ERROR</CODE> arguments
            should not be private to some other lisp thread.</p>
</div>
<a id="f_signal-external-process"></a>
<div class=definition>
<code>signal-external-process</code> <i>proc</i> <i>sig</i> <code>&amp;key</code>  (<i>error-if-exited</i> <i>t</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_signal-external-process"></a>
<p>Sends signal number <I>sig</I> to the external process <I>proc</I> (which would have been returned by <a href="#f_run-program"><CODE>run-program</CODE></a>.
      Typically, it would only be useful to call this function if the
      <I>proc</I> was created with <CODE>:wait nil</CODE>.</p>
<p>      If successful, the function returns <CODE>t</CODE>; otherwise, an error is
      signaled.</p>
<p>      However, if <I>error-if-exited</I> is <CODE>nil</CODE>, and the attempt to
      signal the external process fails because the external process
      has already exited, the function will return nil rather than
      signaling an error.</p>
</div>
<a id="f_external-process-id"></a>
<div class=definition>
<code>external-process-id</code> <i>proc</i> <span class="definition-kind">[Function]</span><a id="description_in_f_external-process-id"></a>
<p>Returns the operating system process ID assigned to the
       external-process object <I>proc</I>.</p>
</div>
<a id="f_external-process-input-stream"></a>
<div class=definition>
<code>external-process-input-stream</code> <i>proc</i> <span class="definition-kind">[Function]</span><a id="description_in_f_external-process-input-stream"></a>
<p>Returns the lisp stream which is used to write input to the
       external-process object <I>proc</I>, if it has one.  This will
       be the stream created when the <CODE>:input</CODE> argument to
       <a href="#f_run-program"><CODE>run-program</CODE></a> is specified as <CODE>:stream</CODE>.</p>
</div>
<a id="f_external-process-output-stream"></a>
<div class=definition>
<code>external-process-output-stream</code> <i>proc</i> <span class="definition-kind">[Function]</span><a id="description_in_f_external-process-output-stream"></a>
<p>Returns the lisp stream which is used to read output from the
      external-process object <I>proc</I>, if there is one.  This is
      the stream created when the <CODE>:output</CODE> argument to <a href="#f_run-program"><CODE>run-program</CODE></a> is specified as <CODE>:stream</CODE>.</p>
</div>
<a id="f_external-process-error-stream"></a>
<div class=definition>
<code>external-process-error-stream</code> <i>proc</i> <span class="definition-kind">[Function]</span><a id="description_in_f_external-process-error-stream"></a>
<p>Returns the stream which is used to read
      error output from a given OS subprocess, if there is one.
      This is the stream created when the <CODE>:error</CODE> argument
      to <a href="#f_run-program"><CODE>run-program</CODE></a> is specified as <CODE>:stream</CODE>.</p>
</div>
<a id="f_external-process-status"></a>
<div class=definition>
<code>external-process-status</code> <i>proc</i> <span class="definition-kind">[Function]</span><a id="description_in_f_external-process-status"></a>
<p>Returns, as multiple values, a keyword denoting the status of
       the external process <I>proc</I> (one of <CODE>:running</CODE>,
       <CODE>:stopped</CODE>, <CODE>signaled</CODE>, or <CODE>exited</CODE>), and the
       exit code or terminating signal if the first value is other
       than <CODE>:running</CODE>.</p>
</div>
</div>
</div>
<a id="streams"></a>
<H2>Streams</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#stream-extensions">
Stream Extensions</a>
<ul style="list-style: none">
<li><a href="#stream-external-format">
Stream External Format</a>
<li><a href="#additional-keywords-for-open-and-make-socket">
Additional keywords for OPEN and MAKE-SOCKET</a>
<li><a href="#basic-versus-fundamental-streams">
Basic Versus Fundamental Streams</a>
<li><a href="#stream-timeouts-and-deadlines">
Stream Timeouts and Deadlines</a>
<li><a href="#open-file-streams">
Open File Streams</a>
<li><a href="#creating-your-own-stream-classes-with-gray-streams">
Creating Your Own Stream Classes with Gray Streams</a>
<li><a href="#lisp-standard-streams-and-os-standard-streams">
Lisp Standard Streams and OS Standard Streams</a>
</ul>
</ul>
<a id="stream-extensions"></a>
<H3>Stream Extensions</H3>
<div class="section">
<a id="stream-external-format"></a>
<H4>Stream External Format</H4>
<div class="section">
<p><CODE>stream-external-format</CODE> can be applied to
    (and may return a non-null result for) open streams that are not
    <CODE>FILE-STREAM</CODE>s.</p>
<p>    <CODE>(setf stream-external-format)</CODE> can be used to
    change the external format of open streams created with <CODE>open</CODE> or <a href="#f_make-socket"><CODE>make-socket</CODE></a>.
    </p>
</div>
<a id="additional-keywords-for-open-and-make-socket"></a>
<H4>Additional keywords for OPEN and MAKE-SOCKET</H4>
<div class="section">
<p><CODE>open</CODE> and
      <a href="#f_make-socket"><CODE>make-socket</CODE></a> have each been extended to take
      the additional keyword arguments: <CODE>:CLASS</CODE>,
      <CODE>:SHARING</CODE>, and
      <CODE>:BASIC</CODE>.</p>
<dl><dt><CODE>:CLASS</CODE></dt>
<dd><p>A symbol that names the desired class of the stream.
	  The specified class must inherit from
	  <CODE>FILE-STREAM</CODE> for
	  <CODE>open</CODE>.</p>
</dd>
<dt><CODE>:SHARING</CODE></dt>
<dd><p>Specifies how a stream can be used by multiple
	  threads.  The possible values are:
	  <CODE>:PRIVATE</CODE>, <CODE>:LOCK</CODE> and
	  <CODE>:EXTERNAL</CODE>. <CODE>:PRIVATE</CODE> is
	  the default.  <CODE>NIL</CODE> is also accepted as a
	  synonym for <CODE>:EXTERNAL</CODE>.</p>
<dl><dt><CODE>:PRIVATE</CODE></dt>
<dd><p>Specifies that the stream can only be accessed
		by the thread that first tries to do I/O to it; that
                thread becomes the "owner" of the stream and
                is not necessarily the same thread as the one which
                created the stream.  This is the default.
		(There was some discussion on openmcl-devel about the
		idea of "transferring ownership" of a stream; this has
		not yet been implemented.)  Attempts to do I/O on a
		stream with :PRIVATE sharing from a thread other than
		the stream's owner yield an error.</p>
</dd>
<dt><CODE>:LOCK</CODE></dt>
<dd><p>Specifies that all access to the stream require
		the calling thread to obtain a lock. There are
		separate "read" and "write" locks for IO streams.
		This makes it possible for instance, for one thread to
		read from such a stream while another thread writes to
		it.  (see also <a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a><a href="#m_with-read-lock"><CODE>with-read-lock</CODE></a><a href="#m_with-write-lock"><CODE>with-write-lock</CODE></a>)</p>
</dd>
<dt><CODE>:EXTERNAL</CODE></dt>
<dd><p>Specifies that I/O primitives enforce no access
		protocol.  This may be appropriate for some types of
		application which can control stream access via
		application-level protocols.  Note that since even the
		act of reading from a stream changes its internal
		state (and simultaneous access from multiple threads
		can therefore lead to corruption of that state), some
		care must be taken in the design of such protocols.</p>
</dd>
</dl>
</dd>
<dt><CODE>:BASIC</CODE></dt>
<dd><p>A boolean that indicates whether or not the stream is
	  a Gray stream, i.e. whether or not the stream is an instance
	  of <CODE>FUNDAMENTAL-STREAM</CODE> or
	  <CODE>CCL::BASIC-STREAM</CODE>(see <a href="#basic-versus-fundamental-streams">Basic Versus Fundamental Streams</a>).  Defaults to
	  <CODE>T</CODE>.</p>
</dd>
</dl>
</div>
<a id="basic-versus-fundamental-streams"></a>
<H4>Basic Versus Fundamental Streams</H4>
<div class="section">
<p>Gray streams (see <a href="#creating-your-own-stream-classes-with-gray-streams">Creating Your Own Stream Classes with Gray Streams</a>)
      all inherit from <CODE>FUNDAMENTAL-STREAM</CODE> whereas
      basic streams inherit from <CODE>CCL::BASIC-STREAM</CODE>.
      The tradeoff between FUNDAMENTAL and BASIC streams is entirely
      between flexibility and performance, potential or actual.  I/O
      primitives can recognize BASIC-STREAMs and exploit knowledge of
      implementation details. FUNDAMENTAL stream classes can be
      subclassed and extended in a standard way (the Gray streams
      protocol).</p>
<p>      For existing stream classes (FILE-STREAMs, SOCKETs, and
      the internal CCL::FD-STREAM classes used to implement file
      streams and sockets), a lot of code can be shared between the
      FUNDAMENTAL and BASIC implementations.  The biggest difference
      should be that that code can be reached from I/O primitives like
      READ-CHAR without going through some steps that're there to
      support generality and extensibility, and skipping those steps
      when that support isn't needed can improve I/O performance.</p>
<p>      The Gray stream method
      <CODE>stream-read-char</CODE> should work on appropriate
      <CODE>BASIC-STREAM</CODE>s.  (There may still be cases
      where such methods are undefined; such cases should be
      considered bugs.)  It is not guaranteed that Gray stream methods
      would ever be called by I/O primitives to read a character from
      a <CODE>BASIC-STREAM</CODE>, though there are still cases
      where this happens.</p>
<p>      A simple loop reading 2M characters from a text file runs
      about 10X faster when the file is opened the new defaults
      <CODE>(:SHARING :PRIVATE :BASIC T)</CODE> than it had
      before these changes were made.  That sounds good, until one
      realizes that the "equivalent" C loop can be about 10X faster
      still ...</p>
</div>
<a id="stream-timeouts-and-deadlines"></a>
<H4>Stream Timeouts and Deadlines</H4>
<div class="section">
<p>A stream that is associated with a file descriptor has
        attributes and accessors:
        <CODE>stream-input-timeout</CODE>,
        <CODE>stream-output-timeout</CODE>, and
        <CODE>stream-deadline</CODE>.  All three accessors have
        corresponding <CODE>setf</CODE> methods.
        <CODE>stream-input-timeout</CODE> and
        <CODE>stream-output-timeout</CODE> are specified in
        seconds and can be any positive real number less than one million.
        When a timeout is set and the corresponding I/O operation takes
        longer than the specified interval, an error is signalled.  The
        error is <CODE>INPUT-TIMEOUT</CODE> for input and
        <CODE>OUTPUT-TIMEOUT</CODE> for output.
        <CODE>STREAM-DEADLINE</CODE> specifies an absolute time in
        internal-time-units.  If an I/O operation on the stream does not
        complete before the deadline then a
        <CODE>COMMUNICATION-DEADLINE-EXPIRED</CODE> error is
        signalled.  A deadline takes precedence over any
        input/output timeouts that may be set.</p>
</div>
<a id="open-file-streams"></a>
<H4>Open File Streams</H4>
<div class="section">
<p>Clozure CL maintains a list of open file streams.  This helps
        to ensure that streams get closed in an orderly manner when
        the lisp exits.  The following thread-safe functions manage
        this list.</p>
<a id="f_open-file-streams"></a>
<div class=definition>
<code>open-file-streams</code> <span class="definition-kind">[Function]</span><a id="description_in_f_open-file-streams"></a>
<p>Returns a fresh list of file streams that are currently open.</p>
</div>
<a id="f_note-open-file-stream"></a>
<div class=definition>
<code>note-open-file-stream</code> <i>file-stream</i> <span class="definition-kind">[Function]</span><a id="description_in_f_note-open-file-stream"></a>
<p>Adds <I>file-stream</I> to the internal list of open file
         streams that is returned by <a href="#f_open-file-streams"><CODE>open-file-streams</CODE></a>.
         This function is thread-safe.  It will usually only be called
         from custom stream code when a file-stream is created.</p>
</div>
<a id="f_remove-open-file-stream"></a>
<div class=definition>
<code>remove-open-file-stream</code> <i>file-stream</i> <span class="definition-kind">[Function]</span><a id="description_in_f_remove-open-file-stream"></a>
<p>Removes <I>file-stream</I> from the internal list of open file
         streams that is returned by <a href="#f_open-file-streams"><CODE>open-file-streams</CODE></a>.
         This function is thread-safe.  It will usually only be called
         from custom stream code when a file-stream is closed.</p>
</div>
</div>
<a id="creating-your-own-stream-classes-with-gray-streams"></a>
<H4>Creating Your Own Stream Classes with Gray Streams</H4>
<div class="section">
<a id="overview_in_creating-your-own-stream-classes-with-gray-streams"></a>
<H5>Overview</H5>
<div class="section">
<p>This section is still being written and revised, because
        it is woefully incomplete.  The dictionary section currently
        only lists a couple functions.  Caveat lector.</p>
<p>        Gray streams are an extension to Common Lisp.  They were
        proposed for standardization by David Gray (the astute reader
        now understands their name) quite some years ago, but not
        accepted, because they had not been tried sufficiently to find
        conceptual problems with them.</p>
<p>        They have since been implemented by quite a few modern
        Lisp implementations.  However, they do indeed have some
        inadequacies, and each implementation has addressed these in
        different ways.  The situation today is that it's difficult to
        even find out how to get started using Gray streams.  This is
        why standards are important.</p>
<p>        Here's a list of some classes which you might wish for
        your new stream class to inherit from:</p>
fundamental-stream
fundamental-input-stream
fundamental-output-stream
fundamental-character-stream
fundamental-binary-stream
fundamental-character-input-stream
fundamental-character-output-stream
fundamental-binary-input-stream
fundamental-binary-output-stream
ccl::buffered-stream-mixin
ccl::buffered-input-stream-mixin
ccl::buffered-output-stream-mixin
ccl::buffered-io-stream-mixin
ccl::buffered-character-input-stream-mixin
ccl::buffered-character-output-stream-mixin
ccl::buffered-character-io-stream-mixin
ccl::buffered-binary-input-stream-mixin
ccl::buffered-binary-output-stream-mixin
ccl::buffered-binary-io-stream-mixin
file-stream
file-input-stream
file-output-stream
file-io-stream
file-character-input-stream
file-character-output-stream
file-character-io-stream
file-binary-input-stream
file-binary-output-stream
file-binary-io-stream
ccl::fd-stream
ccl::fd-input-stream
ccl::fd-output-stream
ccl::fd-io-stream
ccl::fd-character-input-stream
ccl::fd-character-output-stream
ccl::fd-character-io-stream
ccl::fd-binary-input-stream
ccl::fd-binary-output-stream
ccl::fd-binary-io-stream
<p>All of these are defined in ccl/level-1/l1-streams.lisp,
        except for the ccl:file-* ones, which are in
        ccl/level-1/l1-sysio.lisp.</p>
<p>        According to the original Gray streams proposal, you
        should inherit from the most specific of the fundamental-*
        classes which applies.  Using Clozure CL, though, if you want
        buffering for better performance, which, unless you know of some
        reason you wouldn't, you do, you should instead inherit from the
        appropriate ccl::buffered-* class The buffering you get this way
        is exactly the same as the buffering which is used on ordinary,
        non-Gray streams, and force-output will work properly on
        it.</p>
<p>        Notice that -mixin suffix in the names of all the
        ccl::buffered-* classes?  The suffix means that this class is
        not "complete" by itself; you still need to inherit from a
        fundamental-* stream, even if you also inherit from a *-mixin
        stream.  You might consider making your own class like this.
        ....  Except that they do inherit from the fundamental-*
        streams, that's weird.</p>
<p>        If you want to be able to create an instance of your class
        with the :class argument to (open) and (with-open-file), you
        should make it inherit from one of the file-* classes.  If you
        do this, it's not necessary to inherit from any of the other
        classes (though it won't hurt anything), since the file-*
        classes already do.</p>
<p>        When you inherit from the file-* classes, you can use
        (call-next-method) in any of your methods to get the standard
        behavior.  This is especially useful if you want to create a
        class which performs some simple filtering operation, such as
        changing everything to uppercase or to a different character
        encoding.  If you do this, you will definitely need to
        specialize ccl::select-stream-class.  Your method on
        ccl::stream-select-class should accept an instance of the class,
        but pay no attention to its contents, and return a symbol naming
        the class to actually be instantiated.</p>
<p>        If you need to make your functionality generic across all
        the different types of stream, probably the best way to
        implement it is to make it a mixin, define classes with all the
        variants of input, output, io, character, and binary, which
        inherit both from your mixin and from the appropriate other
        class, then define a method on ccl::select-stream-class which
        chooses from among those classes.</p>
<p>        Note that some of these classes are internal to the CCL
        package.  If you try to inherit from those ones without the
        ccl:: prefix, you'll get an error which may confuse you, calling
        them "forward-referenced classes".  That just means you used the
        wrong symbol, so add the prefix.</p>
<p>        Here's a list of some generic functions which you might
        wish to specialize for your new stream class, and which ought to
        be documented at some point.</p>
stream-direction stream =&gt;
stream-device stream direction =&gt;
stream-length stream <CODE>&amp;optional</CODE> new =&gt;
stream-position stream <CODE>&amp;optional</CODE> new =&gt;
streamp stream =&gt; boolean
stream-write-char output-stream char =&gt;
stream-write-entire-string output-stream string =&gt;
stream-read-char input-stream =&gt;
stream-unread-char input-stream char =&gt;
stream-force-output output-stream =&gt; nil
stream-maybe-force-output output-stream =&gt; nil
stream-finish-output output-stream =&gt; nil
stream-clear-output output-stream =&gt; nil
close stream <CODE>&amp;key</CODE> abort =&gt; boolean
stream-fresh-line stream =&gt; t
stream-line-length stream =&gt; length
interactive-stream-p stream =&gt; boolean
stream-clear-input input-stream =&gt; nil
stream-listen input-stream =&gt; boolean
stream-filename stream =&gt; string
ccl::select-stream-class instance in-p out-p char-p =&gt;
	      class
<p>The following functions are standard parts of Common Lisp, but
        behave in special ways with regard to Gray streams.</p>
open-stream-p stream =&gt; generalized-boolean
input-stream-p stream =&gt; generalized-boolean
output-stream-p stream =&gt; generalized-boolean
stream-element-type stream =&gt;
stream-error-stream =&gt;
open
close
with-open-file
<p>Specifically, (open) and (with-open-file) accept a new
        keyword argument, :class, which may be a symbol naming a class;
        the class itself; or an instance of it.  The class so given must
        be a subtype of 'stream, and an instance of it with no
        particular contents will be passed to ccl::select-stream-class
        to determine what class to actually instantiate.</p>
<p>        The following are standard, and do not behave specially
        with regard to Gray streams, but probably should.</p>
stream-external-format
</div>
<a id="extending-read-sequence-and-write-sequence"></a>
<H5>Extending READ-SEQUENCE and WRITE-SEQUENCE</H5>
<div class="section">
<a id="overview_in_extending-read-sequence-and-write-sequence"></a>
<H6>Overview</H6>
<div class="section">
<p>The "Gray Streams" API is based on an informal proposal that was
	      made before ANSI CL adopted the READ-SEQUENCE and WRITE-SEQUENCE
	      functions; as such, there is no "standard" way for the author of a Gray
	      stream class to improve the performance of these functions by exploiting
	      knowledge of the stream's internals (e.g., the buffering mechanism it
	      uses.)</p>
<p>	      In the absence of any such knowledge, READ-SEQUENCE and
	      WRITE-SEQUENCE are effectively just convenient shorthand for a
	      loop which calls READ-CHAR/READ-BYTE/WRITE-CHAR/WRITE-BYTE as
	      appropriate. The mechanism described below allows subclasses
	      of FUNDAMENTAL-STREAM to define more specialized (and
	      presumably more efficient) behavior.</p>
</div>
<a id="notes_in_extending-read-sequence-and-write-sequence"></a>
<H6>Notes</H6>
<div class="section">
<p>READ-SEQUENCE and WRITE-SEQUENCE do a certain amount of
	      sanity-checking and normalization of their arguments before
	      dispatching to one of the methods above. If an individual
	      method can't do anything particularly clever, CALL-NEXT-METHOD
	      can be used to handle the general case.</p>
</div>
<a id="example_in_extending-read-sequence-and-write-sequence"></a>
<H6>Example</H6>
<div class="section">
<pre class="source-code"><p>
(defclass my-string-input-stream (fundamental-character-input-stream)
  ((string :initarg :string :accessor my-string-input-stream-string)
   (index :initform 0 :accessor my-string-input-stream-index)
   (length)))</p>
<p>(defmethod stream-read-vector ((stream my-string-input-stream) vector start end)
  (if (not (typep vector 'simple-base-string))
      (call-next-method)
      (with-slots (string index length)
	      (do* ((outpos start (1+ outpos)))
               ((or (= outpos end)
                    (= index length))
                outpos))
        (setf (schar vector outpos)
              (schar string index))
        (incf index)))))
	    </p>
</pre>
</div>
</div>
<a id="multibyte-i-o"></a>
<H5>Multibyte I/O</H5>
<div class="section">
<p>All heap-allocated objects in Clozure CL that cannot contain
        pointers to lisp objects are represented as
        <EMPH>ivectors</EMPH>. Clozure CL provides low-level
        functions, and , to efficiently transfer data between buffered
        streams and ivectors. There's some overlap in functionality
        between the functions described here and the ANSI CL
        READ-SEQUENCE and WRITE-SEQUENCE functions.</p>
<p>        As used here, the term "octet" means roughly the same
        thing as the term "8-bit byte". The functions described below
        transfer a specified sequence of octets between a buffered
        stream and an ivector, and don't really concern themselves with
        higher-level issues (like whether that octet sequence is within
        bounds or how it relates to the logical contents of the
        ivector.) For these reasons, these functions are generally less
        safe and more flexible than their ANSI counterparts.</p>
</div>
<a id="gray-streams-dictionary"></a>
<H5>Gray Streams Dictionary</H5>
<div class="section">
<a id="f_stream-read-list"></a>
<div class=definition>
<code>stream-read-list</code> <i>stream</i> <i>list</i> <i>count</i> <span class="definition-kind">[Generic Function]</span><p>Should try to read up to count elements from stream
	        into the list <I>list</I>, returning the number of elements
	        actually read (which may be less than count in case of
	        a premature end-of-file.)</p>
<a id="arguments-and-values_in_f_stream-read-list"></a>
<dl><dt><I>stream</I></dt>
<dd><p>a stream, presumably a fundamental-input-stream.</p>
</dd>
<dt><I>list</I></dt>
<dd><p>a list. When a STREAM-READ-LIST method is called by
		          READ-SEQUENCE, this argument is guaranteed to be a proper
		          list.</p>
</dd>
<dt><I>count</I></dt>
<dd><p>a non-negative integer. When a STREAM-READ-LIST method
		          is called by READ-SEQUENCE, this argument is guaranteed not
		          to be greater than the length of the list.</p>
</dd>
</dl>
</div>
<a id="f_stream-write-list"></a>
<div class=definition>
<code>stream-write-list</code> <i>stream</i> <i>list</i> <i>count</i> <span class="definition-kind">[Generic Function]</span><p>Write the first <I>count</I> elements of <I>list</I> to
	        <I>stream</I>. The return value of this method is ignored.</p>
<a id="arguments-and-values_in_f_stream-write-list"></a>
<dl><dt><I>stream</I></dt>
<dd><p>a stream, presumably a fundamental-output-stream.</p>
</dd>
<dt><I>list</I></dt>
<dd><p>a list. When a STREAM-WRITE-LIST method is called by
		          WRITE-SEQUENCE, this argument is guaranteed to be a proper
		          list.</p>
</dd>
<dt><I>count</I></dt>
<dd><p>a non-negative integer. When a STREAM-WRITE-LIST
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed not to be greater than the length of the list.</p>
</dd>
</dl>
</div>
<a id="f_stream-read-vector"></a>
<div class=definition>
<code>stream-read-vector</code> <i>stream</i> <i>vector</i> <i>start</i> <i>end</i> <span class="definition-kind">[Generic Function]</span><p>Read successive elements from stream into <I>vector</I>, starting at element <I>start</I> (inclusive)
	        and continuing through element <I>end</I> (exclusive.) Should return the index of the
	        vector element beyond the last one stored into, which
	        may be less than <I>end</I> in case of premature
	        end-of-file.</p>
<a id="arguments-and-values_in_f_stream-read-vector"></a>
<dl><dt><I>stream</I></dt>
<dd><p>a stream, presumably a fundamental-input-stream</p>
</dd>
<dt><I>vector</I></dt>
<dd><p>a vector. When a STREAM-READ-VECTOR method is called
		          by <CODE>read-sequence</CODE>, this argument is guaranteed to be a simple
		          one-dimensional array.</p>
</dd>
<dt><I>start</I></dt>
<dd><p>a non-negative integer. When a STREAM-READ-VECTOR
		          method is called by READ-SEQUENCE, this argument is
		          guaranteed to be no greater than end and not greater than
		          the length of vector.</p>
</dd>
<dt><I>end</I></dt>
<dd><p>a non-negative integer. When a STREAM-READ-VECTOR
		          method is called by READ-SEQUENCE, this argument is
		          guaranteed to be no less than end and not greater than the
		          length of vector.</p>
</dd>
</dl>
</div>
<a id="f_stream-write-vector"></a>
<div class=definition>
<code>stream-write-vector</code> <i>stream</i> <i>vector</i> <i>start</i> <i>end</i> <span class="definition-kind">[Generic Function]</span><p>should try to write successive elements of <I>vector</I> to <I>stream</I>, starting at element <I>start</I> (inclusive) and continuing through element
                <I>end</I> (exclusive.)</p>
<a id="arguments-and-values_in_f_stream-write-vector"></a>
<dl><dt><I>stream</I></dt>
<dd><p>a stream, presumably a fundamental-output-stream</p>
</dd>
<dt><I>vector</I></dt>
<dd><p>a vector. When a STREAM-WRITE-VECTOR method is called
		          by WRITE-SEQUENCE, this argument is guaranteed to be a
		          simple one-dimensional array.</p>
</dd>
<dt><I>start</I></dt>
<dd><p>a non-negative integer. When a STREAM-WRITE-VECTOR
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed to be no greater than end and not greater than
		          the length of vector.</p>
</dd>
<dt><I>end</I></dt>
<dd><p>a non-negative integer. When a STREAM-WRITE-VECTOR
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed to be no less than end and not greater than the
		          length of vector.</p>
</dd>
</dl>
</div>
<a id="f_stream-device"></a>
<div class=definition>
<code>ccl::stream-device</code> <i>s</i> <i>direction</i> <span class="definition-kind">[Generic Function]</span><p>Returns the OS file descriptor associated with a
	        given lisp stream.</p>
<a id="method-signatures"></a>
<p><CODE><a href="#f_stream-device"><CODE>stream-device</CODE></a>
	        (s stream) direction =&gt; fd</CODE></p>
<a id="arguments-and-values_in_f_stream-device"></a>
<dl><dt><I>s</I></dt>
<dd><p>a stream.</p>
</dd>
<dt><I>direction</I></dt>
<dd><p>either :INPUT or :OUTPUT.</p>
</dd>
<dt><I>fd</I></dt>
<dd><p>a file descriptor, which is a non-negative integer
		          used by the OS to refer to an open file, socket, or similar
		          I/O connection.  NIL if there is no file descriptor associated
		          with <I>s</I> in the direction given by
		          <I>direction</I>.</p>
</dd>
</dl>
<a id="description_in_f_stream-device"></a>
<p>Returns the file descriptor associated with
	        <I>s</I> in the direction given by
	        <I>direction</I>.  It is necessary to specify
	        <I>direction</I> because the input and output
	        file descriptors may be different; the most common case is when
	        one of them has been redirected by the Unix shell.</p>
</div>
<a id="f_stream-read-ivector"></a>
<div class=definition>
<code>stream-read-ivector</code> <i>stream</i> <i>ivector</i> <i>start-octet</i> <i>max-octets</i> <span class="definition-kind">[Generic Function]</span><a id="description_in_f_stream-read-ivector"></a>
<p>Reads up to max-octets octets from stream into ivector,
	        storing them at start-octet. Returns the number of octets actually
	        read.</p>
<a id="arguments_in_f_stream-read-ivector"></a>
<dl><dt><I>stream</I></dt>
<dd><p>An input stream. The method defined on
		          BUFFERED-INPUT-STREAMs requires that the size in octets of
		          an instance of the stream's element type is 1.</p>
</dd>
<dt><I>ivector</I></dt>
<dd><p>Any ivector.</p>
</dd>
<dt><I>start-octet</I></dt>
<dd><p>A non-negative integer.</p>
</dd>
<dt><I>max-octets</I></dt>
<dd><p>A non-negative integer. The return value may be less
		          than the value of this parameter if EOF was encountered.</p>
</dd>
</dl>
</div>
<a id="f_stream-write-ivector"></a>
<div class=definition>
<code>stream-write-ivector</code> <i>stream</i> <i>ivector</i> <i>start-octet</i> <i>max-octets</i> <span class="definition-kind">[Generic Function]</span><a id="description_in_f_stream-write-ivector"></a>
<p>Writes max-octets octets to stream from ivector, starting at
	        start-octet. Returns max-octets.</p>
<a id="arguments_in_f_stream-write-ivector"></a>
<dl><dt><I>stream</I></dt>
<dd><p>An input stream. The method defined on
		          BUFFERED-OUTPUT-STREAMs requires that the size in octets of
		          an instance of the stream's element type is 1.</p>
</dd>
<dt><I>ivector</I></dt>
<dd><p>Any ivector</p>
</dd>
<dt><I>start-octet</I></dt>
<dd><p>A non-negative integer.</p>
</dd>
<dt><I>max-octet</I></dt>
<dd><p>A non-negative integer.</p>
</dd>
</dl>
<a id="examples_in_f_stream-write-ivector"></a>
<pre class="source-code"><p>
;;; Write the contents of a (SIMPLE-ARRAY(UNSIGNED-BYTE 16) 3) 
;;; to a character file stream. Read back the characters.
(let* ((a (make-array 3 
                      :element-type '(unsigned-byte 16)
                      :initial-contents '(26725 27756 28449))))
  (with-open-file (s "junk"
                     :element-type 'character
                     :direction :io
                     :if-does-not-exist :create
                     :if-exists :supersede)
    ;; Write six octets (three elements).
    (stream-write-ivector s a 0 6)
    ;; Rewind, then read a line
    (file-position s 0)
    (read-line s)))</p>
<p>;;; Write a vector of DOUBLE-FLOATs. Note that (to maintain
;;; alignment) there are 4 octets of padding before the 0th 
;;; element of a (VECTOR DOUBLE-FLOAT) on 32-bit platforms.
;;; (Note that (= (- target::misc-dfloat-offset 
;;;                  target::misc-data-offset) 4))
(defun write-double-float-vector
    (stream vector &amp;key (start 0) (end (length vector)))
     (check-type vector (vector double-float))
     (let* ((start-octet (+ (* start 8) 
                            (- target::misc-dfloat-offset
                               target::misc-data-offset)))
	        (num-octets (* 8 (- end start))))
       (stream-write-ivector stream vector start-octet num-octets)))
          </p>
</pre>
</div>
</div>
</div>
<a id="lisp-standard-streams-and-os-standard-streams"></a>
<H4>Lisp Standard Streams and OS Standard Streams</H4>
<div class="section">
<p>In normal interactive usage, the input and output sides of the
     bidirectional stream <CODE>*terminal-io*</CODE> are hooked up to the
     the operating system's standard input and standard output.  The
     lisp streams <CODE>*standard-input*</CODE>, <CODE>*standard-output*</CODE>,
     and <CODE>*error-output*</CODE> are synonym streams for <CODE>*terminal-io*</CODE>.</p>
<p>     In batch mode, this arrangement is modified slightly.  The lisp
     streams <CODE>*standard-input*</CODE>, <CODE>*standard-output*</CODE>, and
     <CODE>*standard-error*</CODE> correspond directly to the operating
     system's standard input, standard output, and standard error.  If
     the lisp can determine that it has access to an operating system
     tty, then <CODE>*terminal-io*</CODE> will be hooked up to that.
     Otherwise, the input and output streams of <CODE>*terminal-io*</CODE>
     will correspond to the operating system's standard input and
     standard output.</p>
</div>
</div>
</div>
<a id="platform-specific-notes"></a>
<H2>Platform-specific notes</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#overview_in_platform-specific-notes">
Overview</a>
<ul style="list-style: none">
<li><a href="#file-system-case">
File-system case</a>
<li><a href="#line-termination-characters">
Line Termination Characters</a>
<li><a href="#single-precision-trig-transcendental-functions">
Single-precision trig &amp; transcendental functions</a>
<li><a href="#shared-libraries">
Shared libraries</a>
</ul>
<li><a href="#cocoa-programming-in-clozure-cl">
Cocoa Programming in Clozure CL</a>
<ul style="list-style: none">
<li><a href="#the-command-line-and-the-window-system">
The Command Line and the Window System</a>
<li><a href="#writing-and-reading-cocoa-code">
Writing (and reading) Cocoa code</a>
<li><a href="#the-application-kit-and-multiple-threads">
The Application Kit and Multiple Threads</a>
<li><a href="#acknowledgement_in_cocoa-programming-in-clozure-cl">
Acknowledgement</a>
</ul>
<li><a href="#building-an-application-bundle">
Building an Application Bundle</a>
<ul style="list-style: none">
</ul>
<li><a href="#recommended-reading_in_platform-specific-notes">
Recommended Reading</a>
<ul style="list-style: none">
</ul>
<li><a href="#operating-system-dictionary">
Operating-System Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="overview_in_platform-specific-notes"></a>
<H3>Overview</H3>
<div class="section">
<p> The documentation and whatever experience you may have in
      using Clozure CL under Linux should also apply to using it under
      Darwin/MacOS X and FreeBSD. There are some differences between
      the platforms, and these differences are sometimes exposed in
      the implementation.</p>
<a id="file-system-case"></a>
<H4>File-system case</H4>
<div class="section">
<p>Darwin and MacOS X use HFS+ file systems by default;
	    HFS+ file systems are usually case-insensitive. Most of
	    Clozure CL's filesystem and pathname code assumes that the
	    underlying filesystem is case-sensitive; this assumption
	    extends to functions like EQUAL, which assumes that #p"FOO"
	    and #p"foo" denote different, un-EQUAL filenames. Since
	    Darwin/MacOS X can also use UFS and NFS filesystems, the
	    opposite assumption would be no more correct than the one
	    that's currently made.</p>
<p>        Whatever the best solution to this problem turns out to
        be, there are some practical considerations. Doing:</p>
<pre class="source-code">
? (save-application "DPPCCL")
	  
</pre>
<p>on 32-bit DarwinPPC has the unfortunate side-effect of
        trying to overwrite the Darwin Clozure CL kernel, "dppccl", on a
        case-insensitive filesystem.</p>
<p>        To work around this, the Darwin Clozure CL kernel expects
        the default heap image file name to be the kernel's own
        filename with the string ".image" appended, so the idiom would
        be:</p>
<pre class="source-code">
? (save-application "dppccl.image")
	  
</pre>
</div>
<a id="line-termination-characters"></a>
<H4>Line Termination Characters</H4>
<div class="section">
<p>MacOSX effectively supports two distinct line-termination
	    conventions. Programs in its Darwin substrate follow the Unix
	    convention of recognizing #\LineFeed as a line terminator; traditional
	    MacOS programs use #\Return for this purpose.  Many modern
	    GUI programs try to support several different line-termination
	    conventions (on the theory that the user shouldn't be too concerned
	    about what conventions are used an that it probably doesn't matter.
	    Sometimes this is true, other times ... not so much.</p>
<p>        Clozure CL follows the Unix convention on both Darwin and
        LinuxPPC, but offers some support for reading and writing
        files that use other conventions (including traditional MacOS
        conventions) as well.</p>
<p>	    This support (and anything like it) is by nature
	    heuristic: it can successfully hide the distinction between
	    newline conventions much of the time, but could mistakenly
	    change the meaning of otherwise correct programs (typically
	    when files contain both #\Return and #\Linefeed characters or
	    when files contain mixtures of text and binary data.) Because
	    of this concern, the default settings of some of the variables
	    that control newline translation and interpretation are
	    somewhat conservative.</p>
<p>	    Although the issue of multiple newline conventions
	    primarily affects MacOSX users, the functionality described
	    here is available under LinuxPPC as well (and may occasionally
	    be useful there.)</p>
<p>	    None of this addresses issues
	    related to the third newline convention ("CRLF") in widespread
	    use (since that convention isn't native to any platform on
	    which Clozure CL currently runs). If Clozure CL is ever ported to
	    such a platform, that issue might be revisited.</p>
<p>	    Note that some MacOS programs (including some versions
	    of commercial MCL) may use HFS file type information to
	    recognize TEXT and other file types and so may fail to
	    recognize files created with Clozure CL or other Darwin
	    applications (regardless of line termination issues.)</p>
<p>	    Unless otherwise noted, the symbols mentioned in this
	    documentation are exported from the CCL package.</p>
</div>
<a id="single-precision-trig-transcendental-functions"></a>
<H4>Single-precision trig &amp; transcendental functions</H4>
<div class="section">
<p>
	    Despite what Darwin's man pages say, early versions of its math library
	    (up to and including at least OSX 10.2 (Jaguar) don't implement
	    single-precision variants of the transcendental and trig functions
	    (#_sinf, #_atanf, etc.) Clozure CL worked around this by coercing
	    single-precision args to double-precision, calling the
	    double-precision version of the math library function, and coercing
	    the result back to a SINGLE-FLOAT. These steps can introduce rounding
	    errors (and potentially overflow conditions) that might not be present
	    or as severe if true 32-bit variants were available.</p>
</div>
<a id="shared-libraries"></a>
<H4>Shared libraries</H4>
<div class="section">
<p>Darwin/MacOS X distinguishes between "shared libraries"
        and "bundles" or "extensions"; Linux and FreeBSD don't. In
        Darwin, "shared libraries" have the file type "dylib" : the
        expectation is that this class of file is linked against when
        executable files are created and loaded by the OS when the
        executable is launched. The latter class -
        "bundles/extensions" - are expected to be loaded into and
        unloaded from a running application, via a mechanism like the
        one used by Clozure CL's OPEN-SHARED-LIBRARY function.</p>
</div>
</div>
<a id="cocoa-programming-in-clozure-cl"></a>
<H3>Cocoa Programming in Clozure CL</H3>
<div class="section">
<p>Cocoa is one of Apple's APIs for GUI programming; for most
      purposes, development is considerably faster with Cocoa than
      with the alternatives.  You should have a little familiarity
      with it, to better understand this section.</p>
<p>      A small sample Cocoa program can be invoked by evaluating
      (REQUIRE 'TINY) and then (CCL::TINY-SETUP). This program
      provides a simple example of using several of the bridge's
      capabilities.</p>
<p>      The Tiny demo creates Cocoa objects dynamically, at
      runtime, which is always an option.  However, for large
      applications, it is usually more convenient to create your
      objects with Apple Interface Builder, and store them in .nib
      files to be loaded when needed.  Both approaches can be freely
      mixed in a single program.</p>
<a id="the-command-line-and-the-window-system"></a>
<H4>The Command Line and the Window System</H4>
<div class="section">
<p>Clozure CL is ordinarily a command-line application (it
        doesn't have a connection to the OSX Window server, doesn't
        have its own menubar or dock icon, etc.) By opening some
        libraries and jumping through some hoops, it's able to sort of
        transform itself into a full-fledged GUI application (while
        retaining its original TTY-based listener.) The general idea
        is that this hybrid environment can be used to test and
        protoype UI ideas and the resulting application can eventually
        be fully transformed into a bundled, double-clickable
        application. This is to some degree possible, but there needs
        to be a bit more infrastructure in place before many people
        would find it easy.</p>
<p>        Cocoa applications use the NSLog function to write
        informational/warning/error messages to the application's
        standard output stream. When launched by the Finder, a GUI
        application's standard output is diverted to a logging
        facility that can be monitored with the Console application
        (found in /Applications/Utilities/Console.app).  In the hybrid
        environment, the application's standard output stream is
        usually the initial listener's standard output stream. With
        two different buffered stream mechanisms trying to write to
        the same underlying Unix file descriptor, it's not uncommon to
        see NSLog output mixed with lisp output on the initial
        listener.</p>
</div>
<a id="writing-and-reading-cocoa-code"></a>
<H4>Writing (and reading) Cocoa code</H4>
<div class="section">
<p>The
	    syntax of the constructs used to define Cocoa classes and
	    methods has changed a bit (it was never documented outside of
	    the source code and never too well documented at all), largely
	    as the result of functionality offered by Randall Beer's
	    bridge; the "standard name-mapping conventions"
	    referenced below are described in his CocoaBridgeDoc.txt file,
	    as are the constructs used to invoke ("send messages
	    to") Cocoa methods.</p>
<p>        All of the symbols described below are currently internal to
        the CCL package.</p>
<a href="#m_class"><CODE>objc:@class</CODE></a>
<a href="#m_selector"><CODE>objc:@selector</CODE></a>
<a href="#m_define-objc-method"><CODE>objc:define-objc-method</CODE></a>
<a href="#m_define-objc-class-method"><CODE>objc:define-objc-class-method</CODE></a>
</div>
<a id="the-application-kit-and-multiple-threads"></a>
<H4>The Application Kit and Multiple Threads</H4>
<div class="section">
<p>The Cocoa API is broken into several pieces.  The
        Application Kit, affectionately called AppKit, is the one
        which deals with window management, drawing, and handling
        events.  AppKit really wants all these things to be done by a
        "distinguished thread".  creation, and drawing to take place
        on a distinguished thread.</p>
<p>        Apple has published some guidelines which discuss these
        issues in some detail; see the Apple Multithreading
        Documentation, and in particular the guidelines on Using the
        Application Kit from Multiple Threads.  The upshot is that
        there can sometimes be unexpected behavior when objects are
        created in threads other than the distinguished event thread;
        eg, the event thread sometimes starts performing operations on
        objects that haven't been fully initialized.</p>
<p>        It's
        certainly more convenient to do certain types of exploratory
        programming by typing things into a listener or evaluating a
        "defun" in an Emacs buffer; it may sometimes be
        necessary to be aware of this issue while doing so.</p>
<p>        Each thread in the Cocoa runtime system is expected to
        maintain a current "autorelease pool" (an instance
        of the NSAutoreleasePool class); newly created objects are
        often added to the current autorelease pool (via the
        -autorelease method), and periodically the current autorelease
        pool is sent a "-release" message, which causes it
        to send "-release" messages to all of the objects
        that have been added to it.</p>
<p>        If the current thread doesn't have a current autorelease
        pool, the attempt to autorelease any object will result in a
        severe-looking warning being written via NSLog. The event
        thread maintains an autorelease pool (it releases the current
        pool after each event is processed and creates a new one for
        the next event), so code that only runs in that thread should
        never provoke any of these severe-looking NSLog
        messages.</p>
<p>        To try to suppress these messages (and
        still participate in the Cocoa memory management scheme), each
        listener thread (the initial listener and any created via the
        "New Listener" command in the IDE) is given a
        default autorelease pool; there are REPL colon-commands for
        manipulating the current listener's "toplevel
        autorelease pool".</p>
<p>        In the current scheme, every time that Cocoa calls lisp
        code, a lisp error handler is established which maps any lisp
        conditions to ObjC exceptions and arranges that this exception
        is raised when the callback to lisp returns. Whenever lisp
        code invokes a Cocoa method, it does so with an ObjC exception
        handler in place; this handler maps ObjC exceptions to lisp
        conditions and signals those conditions.</p>
<p>        Any
        unhandled lisp error or ObjC exception that occurs during the
        execution of the distinguished event thread's event loop
        causes a message to be NSLog'ed and the event loop to (try to)
        continue execution. Any error that occurs in other threads is
        handled at the point of the outermost Cocoa method
        invocation. (Note that the error is not necessarily
        "handled" in the dynamic context in which it
        occurs.)</p>
<p>        Both of these behaviors could possibly be improved; both of them
        seem to be substantial improvements over previous behaviors (where,
        for instance, a misspelled message name typically terminated the
        application.)</p>
</div>
<a id="acknowledgement_in_cocoa-programming-in-clozure-cl"></a>
<H4>Acknowledgement</H4>
<div class="section">
<p>The Cocoa bridge was originally developed, and
        generously contributed by, Randall Beer.</p>
</div>
</div>
<a id="building-an-application-bundle"></a>
<H3>Building an Application Bundle</H3>
<div class="section">
<p>You may have noticed that (require "COCOA") takes a long
      time to load.  It is possible to avoid this by saving a Lisp
      heap image which has everything already loaded.  There is an
      example file which allows you to do this,
      "ccl/examples/cocoa-application.lisp", by producing a
      double-clickable application which runs your program.  First,
      load your own program.  Then, do:</p>
<pre class="source-code">
? (require "COCOA-APPLICATION")
    
</pre>
<p>When it finishes, you should be able to double-click the Clozure CL icon
      in the ccl directory, to quickly start your program.</p>
<p>      The OS may have already decided that Clozure CL.app isn't a valid
      executable bundle, and therefore won't let you double-click it.
      If this happens to you, to force it to reconsider, just update the
      last-modified time of the bundle.  In Terminal:</p>
<pre class="source-code">&gt; touch Clozure CL.app
    
</pre>
<p>When an image which had contained ObjC classes (which are also
      CLOS classes) is re-launched, those classes are "revived": all
      preexisting classes have their addresses updated destructively, so that
      existing subclass/superclass/metaclass relationships are maintained.
      It's not possible (and may never be) to preserve foreign
      instances across SAVE-APPLICATION. (It may be the case that NSArchiver
      and NSCoder and related classes offer some approximation of that.)</p>
</div>
<a id="recommended-reading_in_platform-specific-notes"></a>
<H3>Recommended Reading</H3>
<div class="section">
<dl><dt><a href="http://developer.apple.com/technologies/mac/cocoa.html">Mac OS X - Cocoa</a>
, <a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html">Cocoa Core Competencies
              </a>
, <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html">Cocoa Fundamentals Guide
              </a>
</dt>
<dd><p>
	        These are top-level pages pertaining to Cocoa in Apple's Mac OS X Developer Library.
	        If you are unfamiliar with Cocoa, these links are good places to start.
	      </p>
</dd>
<dt><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html">The Objective-C Programming Language
              </a>
, <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide
              </a>
</dt>
<dd><p>These provide a conceptual overview and programming guide to Objective-C the language and runtime, respectively.</p>
</dd>
<dt><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html">Objective-C Runtime Reference
              </a>
</dt>
<dd><p>
	        This is one of the two most important Cocoa references; it
	        covers all of the basics, except for GUI programming.  This is
	        a reference, not a tutorial.
	      </p>
</dd>
<dt><a href="http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/index.html">Application Kit Framework Reference</a>
</dt>
<dd><p>
	        This is the other very important Cocoa reference; it covers GUI programming with Cocoa / Application Kit Framework
	        in considerable depth.  This is a reference, not a tutorial.
	      </p>
</dd>
<dt><a href="http://developer.apple.com/library/mac/navigation/">Mac OS X Developer Library</a>
</dt>
<dd><p>
	        This is the top page for Mac OS X developer documentation.
	        Go here to find the documentation on any other Mac OS X API.
	        Also go here if you need general guidance about OS X, Carbon,
	        Cocoa, Core Foundation, or Objective-C.
	      </p>
</dd>
<dt><a href="http://developer.apple.com/">Resources for Apple Developers</a>
</dt>
<dd><p>
                This is the top page for all Apple developer documentation.
              </p>
</dd>
</dl>
</div>
<a id="operating-system-dictionary"></a>
<H3>Operating-System Dictionary</H3>
<div class="section">
<a id="m_class"></a>
<div class=definition>
<code>@class</code> <i>class-name</i> <span class="definition-kind">[Macro]</span><a id="arguments-and-values_in_m_class"></a>
<dl><dt><I>class-name</I></dt>
<dd><p>a string which denotes an existing class name, or a
		        symbol which can be mapped to such a string via the standard
		        name-mapping conventions for class names</p>
</dd>
</dl>
<a id="description_in_m_class"></a>
<p>Used to refer to a known ObjC class by name. (Via the use
	      LOAD-TIME-VALUE, the results of a class-name -&gt; class lookup
	      are cached.)</p>
<p>	      <a href="#m_class"><CODE>objc:@class</CODE></a> is obsolete as of late 2004, because
	      find-class now works on ObjC classes.  It is described here
	      only because some old code still uses it.
	    </p>
</div>
<a id="m_selector"></a>
<div class=definition>
<code>@selector</code> <i>string</i> <span class="definition-kind">[Macro]</span><a id="arguments-and-values_in_m_selector"></a>
<dl><dt><I>string</I></dt>
<dd><p>a string constant, used to canonically refer to an
		        ObjC method selector</p>
</dd>
</dl>
<a id="description_in_m_selector"></a>
<p>Used to refer to an ObjC method selector (method name). Uses
	      LOAD-TIME-VALUE to cache the result of a string -&gt; selector
	      lookup.</p>
</div>
<a id="m_defmethod"></a>
<div class=definition>
<code>objc:defmethod</code> <i>name-and-result-type</i> <i>((receiver-arg-and-class)</i> <code>&amp;rest</code> <i>other-args</i>) <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="arguments-and-values_in_m_defmethod"></a>
<dl><dt><I>name-and-result-type</I></dt>
<dd><p>either an Objective-C message name, for methods
                that return a value of type <CODE>:ID</CODE>, or
                a list containing an Objective-C message name and a
                foreign type specifier for methods with a different
                foreign result type.</p>
</dd>
<dt><I>receiver-arg-and-class</I></dt>
<dd><p>a two-element list whose first element is a
                variable name and whose second element is the Lisp
                name of an Objective-C class or metaclass.  The
                receiver variable name can be any bindable lisp
                variable name, but <CODE>SELF</CODE> might be a
                reasonable choice.  The receiver variable is declared
                to be "unsettable"; i.e., it is an error to try to
                change the value of the receiver in the body of the
                method definition.</p>
</dd>
<dt><I>other-args</I></dt>
<dd><p>either variable names (denoting parameters of
            type <CODE>:ID</CODE>) or 2-element lists whose
            first element is a variable name and whose second element
            is a foreign type specifier.</p>
</dd>
</dl>
<a id="description_in_m_defmethod"></a>
<p>Defines an Objective-C-callable method which implements
	        the specified message selector for instances of the existing
	        named Objective-C class.</p>
<p>For a detailed description of the features and
          restrictions of the <CODE>OBJC:DEFMETHOD</CODE> macro,
          see the
          section <a href="#using-objc-defmethod">Using <CODE>objc:defmethod</CODE></a>.</p>
</div>
<a id="m_define-objc-method"></a>
<div class=definition>
<code>define-objc-method</code>  (<i>selector</i> <i>class-name</i>) <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="arguments-and-values_in_m_define-objc-method"></a>
<dl><dt><I>selector</I></dt>
<dd><p>either a string which represents the name of the
		          selector or a list which describes the method's return
		          type, selector components, and argument types (see below.)
		          If the first form is used, then the first form in the body
		          must be a list which describes the selector's argument
		          types and return value type, as per DEFCALLBACK.</p>
</dd>
<dt><I>class-name</I></dt>
<dd><p>either a string which names an existing ObjC class
		          name or a list symbol which can map to such a string via the
		          standard name-mapping conventions for class names. (Note
		          that the "canonical" lisp class name is such a
		          symbol)</p>
</dd>
</dl>
<a id="description_in_m_define-objc-method"></a>
<p>Defines an ObjC-callable method which implements the
	        specified message selector for instances of the existing ObjC
	        class class-name.</p>
</div>
<a id="m_define-objc-class-method"></a>
<div class=definition>
<code>define-objc-class-method</code>  (<i>selector</i> <i>class-name</i>) <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="arguments-and-values_in_m_define-objc-class-method"></a>
<p>As per DEFINE-OBJC-METHOD</p>
<a id="description_in_m_define-objc-class-method"></a>
<p>Like DEFINE-OBJC-METHOD, only used to define methods on the
	        <EMPH>class</EMPH> named by class-name and on its
	        subclasses.</p>
<p>	        For both DEFINE-OBJC-METHOD and DEFINE-OBJC-CLASS-METHOD, the
	        "selector" argument can be a list whose first element is a
	        foreign type specifier for the method's return value type and whose
	        subsequent elements are either:</p>
<ul><li><p>a non-keyword symbol, which can be mapped to a selector string
		        for a parameterless method according to the standard name-mapping
		        conventions for method selectors.</p>
<li><p>a list of alternating keywords and variable/type specifiers,
		        where the set of keywords can be mapped to a selector string for a
		        parameterized method according to the standard name-mapping
		        conventions for method selectors and each variable/type-specifier is
		        either a variable name (denoting a value of type :ID) or a list whose
		        CAR is a variable name and whose CADR is the corresponding
		        argument's foreign type specifier.</p>
</ul>
</div>
<a id="v_alternate-line-terminator"></a>
<div class=definition>
<code>ccl:*alternate-line-terminator*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_alternate-line-terminator"></a>
<p>This variable is currently only used by the standard reader macro
	        function for #\; (single-line comments); that function reads successive
	        characters until EOF, a #\NewLine is read, or a character EQL to the
	        value of *alternate-line-terminator* is read. In Clozure CL for Darwin, the
	        value of this variable is initially #\Return ; in Clozure CL for other OSes,
	        it's initially NIL.</p>
<p>	        Their default treatment by the #\; reader macro is the primary way
	        in which #\Return and #\Linefeed differ syntactically; by extending the
	        #\; reader macro to (conditionally) treat #\Return as a
	        comment-terminator, that distinction is eliminated. This seems to make
	        LOAD and COMPILE-FILE insensitive to line-termination issues in many
	        cases. It could fail in the (hopefully rare) case where a LF-terminated
	        (Unix) text file contains embedded #\Return characters, and this
	        mechanism isn't adequate to handle cases where newlines are embedded
	        in string constants or other tokens (and presumably should be translated
	        from an external convention to the external one) : it doesn't change
	        what READ-CHAR or READ-LINE "see", and that may be necessary to
	        handle some more complicated cases.</p>
</div>
<a id="c_ns-lisp-string"></a>
<div class=definition>
<code>ccl::ns-lisp-string</code> <span class="definition-kind">[Class]</span><a id="superclasses"></a>
<p>NS:NS-STRING</p>
<a id="initargs"></a>
<dl><dt><I>:string</I></dt>
<dd><p>
		          a Lisp string which is to be the content of
		          the newly-created ns-lisp-string.
		        </p>
</dd>
</dl>
<a id="description_in_c_ns-lisp-string"></a>
<p>
	        This class
	        implements the interface of an NSString, which means that it can
	        be passed to any Cocoa or Core Foundation function which expects
	        one.</p>
<p>	        The string itself is stored on the Lisp heap, which
	        means that its memory management is automatic.  However, the
	        ns-lisp-string object itself is a foreign
	        object (that is, it has an objc metaclass), and resides on the
	        foreign heap.  Therefore, it is necessary to explicitly free
	        it, by sending a dealloc message.
	      </p>
<a id="examples_in_c_ns-lisp-string"></a>
<p>
	        You can create an ns-lisp-string with
	        <CODE>make-instance</CODE>, just like
	        any normal Lisp class:
	      </p>
<pre class="source-code">? (defvar *the-string*
     (make-instance 'ccl::ns-lisp-string
                    :string "Hello, Cocoa."))
</pre>
<p>
	        When you are done with the string, you must explicitly
	        deallocate it:
	      </p>
<pre class="source-code">? (ccl::send *the-string* 'dealloc)
</pre>
<p>
	        You may wish to use an <a href="#m_unwind-protect"><CODE>unwind-protect</CODE></a>
	        form to ensure that this happens:
	      </p>
<pre class="source-code">(let (*the-string*)
  (unwind-protect (progn (setq *the-string*
                               (make-instance 'ccl::ns-lisp-string
                                              :string "Hello, Cocoa."))
                         (format t "~&amp;The string is ~D characters long.~%"
                                 (ccl::send *the-string* 'length)))
    (when *the-string*
      (ccl::send *the-string* 'dealloc))))
</pre>
<a id="notes_in_c_ns-lisp-string"></a>
<p>
	        Currently, ns-lisp-string is defined in
	        the file ccl/examples/cocoa-backtrace.lisp, which is a
	        rather awkward place.  It was probably not originally meant
	        as a public utility at all.  It would be good if it were
	        moved someplace else.  Use at your own risk.
	      </p>
</div>
</div>
</div>
<a id="understanding-and-configuring-the-garbage-collector"></a>
<H2>Understanding and Configuring the Garbage Collector</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#heap-space-allocation">
Heap space allocation</a>
<ul style="list-style: none">
</ul>
<li><a href="#ephemeral-gc">
Ephemeral GC</a>
<ul style="list-style: none">
</ul>
<li><a href="#gc-page-reclamation-policy">
GC Page reclamation policy</a>
<ul style="list-style: none">
</ul>
<li><a href="#pure-areas-are-read-only-paged-from-image-file">
"Pure" areas are read-only, paged from image file</a>
<ul style="list-style: none">
</ul>
<li><a href="#weak-references">
Weak References</a>
<ul style="list-style: none">
</ul>
<li><a href="#weak-references-dictionary">
Weak References Dictionary</a>
<ul style="list-style: none">
</ul>
<li><a href="#garbage-collection-dictionary">
Garbage-Collection Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="heap-space-allocation"></a>
<H3>Heap space allocation</H3>
<div class="section">
<p>Release 0.10 or later of Clozure CL uses a different memory
      management scheme than previous versions did. Those earlier
      versions would allocate a block of memory (of specified size) at
      startup and would allocate lisp objects within that block. When
      that block filled with live (non-GCed) objects, the lisp would
      signal a "heap full" condition. The heap size imposed a limit on
      the size of the largest object that could be allocated.</p>
<p>      The new strategy involves reserving a very large (2GB on
      DarwinPPC32, 1GB on LinuxPPC, "very large" on 64-bit
      implementations) block at startup and consuming (and
      relinquishing) its contents as the size of the live lisp heap
      data grows and shrinks. After the initial heap image loads and
      after each full GC, the lisp kernel will try to ensure that a
      specified amount (the "lisp-heap-gc-threshold") of free memory
      is available. The initial value of this kernel variable is 16MB
      on 32-bit implementations and 32MB on 64-bit implementations ;
      it can be manipulated from Lisp (see below.)</p>
<p>      The large reserved memory block consumes very little in
      the way of system resources; memory that's actually committed to
      the lisp heap (live data and the "threshold" area where
      allocation takes place) consumes finite resources (physical
      memory and swap space). The lisp's consumption of those
      resources is proportional to its actual memory usage, which is
      generally a good thing.</p>
<p>      This scheme is much more flexible than the old one, but it
      may also increase the possibility that those resources can
      become exhausted.  Neither the new scheme nor the old handles
      that situation gracefully; under the old scheme, a program that
      consumes lots of memory may have run into an artificial limit on
      heap size before exhausting virtual memory.</p>
<p>      The -R or -heap-reserve command-line option can be
      use to limit the size of the reserved block and therefore bound
      heap expansion. Running</p>
<pre class="source-code">
&gt; openmcl --heap-reserve 8M
</pre>
<p>would provide an execution environment that's very similar to
that provided by earlier Clozure CL versions.</p>
</div>
<a id="ephemeral-gc"></a>
<H3>Ephemeral GC</H3>
<div class="section">
<p>For many programs, the following observations are true to
      a very large degree:</p>
<ol><li><p>Most heap-allocated objects have very short lifetimes ("are
	  ephemeral"): they become inaccessible soon after they're created.</p>
<li><p>Most non-ephemeral objects have very long lifetimes: it's
	  rarely productive for the GC to consider reclaiming them, since
	  it's rarely able to do so. (An object that has survived a large
	  number of GCs is likely to survive the next one. That's not always
	  true of course, but it's a reasonable heuristic.)</p>
<li><p>It's relatively rare for an old object to be destructively
	  modified (via SETF) so that it points to a new one, therefore most
	  references to newly-created objects can be found in the stacks and
	  registers of active threads. It's not generally necessary to scan
	  the entire heap to find references to new objects (or to prove that
	  such references don't exists), though it is necessary to keep
	  track of the (hopefully exceptional) cases where old objects are
	  modified to point at new ones.</p>
</ol>
<p>"Ephemeral" (or "generational") garbage collectors try to
      exploit these observations: by concentrating on frequently
      reclaiming newly-created objects quickly, it's less often
      necessary to do more expensive GCs of the entire heap in order
      to reclaim unreferenced memory.  In some environments, the
      pauses associated with such full GCs can be noticeable and
      disruptive, and minimizing the frequency (and sometimes the
      duration) of these pauses is probably the EGC's primary goal
      (though there may be other benefits, such as increased locality
      of reference and better paging behavior.) The EGC generally
      leads to slightly longer execution times (and slightly higher,
      amortized GC time), but there are cases where it can improve
      overall performance as well; the nature and degree of its impact
      on performance is highly application-dependent.</p>
<p>      Most EGC strategies (including the one employed by
      Clozure CL) logically or physically divide memory into one or more
      areas of relatively young objects ("generations") and one or
      more areas of old objects.  Objects that have survived one or
      more GCs as members of a young generation are promoted (or
      "tenured") into an older generation, where they may or may not
      survive long enough to be promoted to the next generation and
      eventually may become "old" objects that can only be reclaimed
      if a full GC proves that there are no live references to them.
      This filtering process isn't perfect - a certain amount of
      premature tenuring may take place - but it usually works very
      well in practice.</p>
<p>      It's important to note that a GC of the youngest
      generation is typically very fast (perhaps a few milliseconds on
      a modern CPU, depending on various factors), Clozure CL's EGC is
      not concurrent and doesn't offer realtime guarantees.</p>
<p>      Clozure CL's EGC maintains three ephemeral generations; all
      newly created objects are created as members of the youngest
      generation. Each generation has an associated
      <EMPH>threshold</EMPH>, which indicates the number of
      bytes in it and all younger generations that can be allocated
      before a GC is triggered. These GCs will involve the target
      generation and all younger ones (and may therefore cause some
      premature tenuring); since the older generations have larger
      thresholds, they're GCed less frequently and most short-lived
      objects that make it into an older generation tend not to
      survive there very long.</p>
<p>      The EGC can be <EMPH>enabled</EMPH> or
      <EMPH>disabled</EMPH> under program control; under some
      circumstances, it may be enabled but
      <EMPH>inactive</EMPH> (because a full GC is imminent.)
      Since it may be hard to know or predict the consing behavior of
      other threads, the distinction between the "active" and
      "inactive" state isn't very meaningful, especially when native
      threads are involved.</p>
</div>
<a id="gc-page-reclamation-policy"></a>
<H3>GC Page reclamation policy</H3>
<div class="section">
<p>After a full GC finishes, it'll try to ensure that at
      least (LISP-HEAP-GC-THRESHOLD) of virtual memory are available;
      objects will be allocated in this block of memory until it fills
      up, the GC is triggered, and the process repeats itself.</p>
<p>      Many programs reach near stasis in terms of the amount of
      logical memory that's in use after full GC (or run for long
      periods of time in a nearly static state), so the logical
      address range used for consing after the Nth full GC is likely
      to be nearly or entirely identical to the address range used by
      the N+1th full GC.</p>
<p>      By default (and traditionally in Clozure CL), the GC's policy
      is to "release" the pages in this address range: to advise the
      virtual memory system that the pages contain garbage and any
      physical pages associated with them don't need to be swapped out
      to disk before being reused and to (re-)map the logical address
      range so that the pages will be zero-filled by the virtual
      memory system when they're next accessed.  This policy is
      intended to reduce the load on the VM system and keep Clozure CL's
      working set to a minimum.</p>
<p>      For some programs (especially those that cons at a very
      high rate), the default policy may be less than ideal: releasing
      pages that are going to be needed almost immediately - and
      zero-fill-faulting them back in, lazily - incurs unnecessary
      overhead. (There's a false economy associated with minimizing
      the size of the working set if it's just going to shoot back up
      again until the next GC.) A policy of "retaining" pages between
      GCs might work better in such an environment.</p>
<p>      Functions described below give the user some control over
      this behavior. An adaptive, feedback-mediated approach might
      yield a better solution.</p>
</div>
<a id="pure-areas-are-read-only-paged-from-image-file"></a>
<H3>"Pure" areas are read-only, paged from image file</H3>
<div class="section">
<p>SAVE-APPLICATION identifies code vectors and the pnames of
      interned symbols and copies these objects to a "pure" area of
      the image file it creates. (The "pure" area accounts for most of
      what the ROOM function reports as "static" space.)</p>
<p>      When the resulting image file is loaded, the pure area of
      the file is now memory-mapped with read-only access. Code and
      pure data are paged in from the image file as needed (and don't
      compete for global virtual memory resources with other memory
      areas.)</p>
<p>      Code-vectors and interned symbol pnames are immutable : it
      is an error to try to change the contents of such an
      object. Previously, that error would have manifested itself in
      some random way. In the new scheme, it'll manifest itself as an
      "unhandled exception" error in the Lisp kernel. The kernel could
      probably be made to detect a spurious, accidental write to
      read-only space and signal a lisp error in that case, but it
      doesn't yet do so.</p>
<p>      The image file should be opened and/or mapped in some mode
      which disallows writing to the memory-mapped regions of the file
      from other processes. I'm not sure of how to do that; writing to
      the file when it's mapped by Clozure CL can have unpredictable and
      unpleasant results.  SAVE-APPLICATION will delete its output
      file's directory entry and create a new file; one may need to
      exercise care when using file system utilities (like tar, for
      instance) that might overwrite an existing image file.</p>
</div>
<a id="weak-references"></a>
<H3>Weak References</H3>
<div class="section">
<p>In general, a "weak reference" is a reference to an object
      which does not prevent the object from being garbage-collected.
      For example, suppose that you want to keep a list of all the
      objects of a certain type.  If you don't take special steps, the
      fact that you have a list of them will mean that the objects are
      always "live", because you can always reference them through the
      list.  Therefore, they will never be garbage-collected, and
      their memory will never be reclaimed, even if they are
      referenced nowhere else in the program.  If you don't want this
      behavior, you need weak references.</p>
<p>      Clozure CL supports weak references with two kinds of objects:
      weak hash tables and populations.</p>
<p>      Weak hash tables are created with the standard Common Lisp
      function <CODE>make-hash-table</CODE>, which is extended
      to accept the keyword argument <CODE>:weak</CODE>.  Hash
      tables may be weak with respect to either their keys or their
      values.  To make a hash table with weak keys, invoke
      <CODE>make-hash-table</CODE> with the option :weak t, or,
      equivalently, :weak :key.  To make one with weak values, use
      :weak :value.  When the key is weak, the equality test must be
      #'eq (because it wouldn't make sense otherwise).</p>
<p>      When garbage-collection occurs, key-value pairs are
      removed from the hash table if there are no non-weak references to
      the weak element of the pair (key or value).</p>
<p>      In general, weak-key hash tables are useful when you want
      to use the hash to store some extra information about the
      objects you look up in it, while weak-value hash tables are
      useful when you want to use the hash as an index for looking up
      objects.</p>
<p>      A population encapsulates an object, causing certain
      reference from the object to be considered weak.  Clozure CL supports
      two kinds of populations: lists, in which case the encapsulated
      object is a list of elements, which are spliced out of the list
      when there are no non-weak references to the element; and alists,
      in which case the encapsulated object is a list of conses which
      are spliced out of the list if there are no non-weak references
      to the car of the cons.</p>
<p>      If you are experimenting with weak references
      interactively, remember that an object is not dead if it was
      returned by one of the last three interactively-evaluated
      expressions, because of the variables <CODE>*</CODE>,
      <CODE>**</CODE>, and <CODE>***</CODE>.  The easy
      workaround is to evaluate some meaningless expression before
      invoking <CODE>gc</CODE>, to get the object out of the
      REPL variables.</p>
</div>
<a id="weak-references-dictionary"></a>
<H3>Weak References Dictionary</H3>
<div class="section">
<a id="f_make-population"></a>
<div class=definition>
<code>make-population</code> <code>&amp;key</code> <i>type</i> <i>initial-contents</i> <span class="definition-kind">[Function]</span><a id="arguments-and-values_in_f_make-population"></a>
<dl><dt><I>type</I></dt>
<dd><p>The type of population, one of <CODE>:LIST</CODE> (the default) or <CODE>:ALIST</CODE></p>
</dd>
<dt><I>initial-contents</I></dt>
<dd><p> A sequence of elements (or conses, for <CODE>:alist</CODE>) to be used to initialize the
              population. The sequence itself (and the conses in case of an
              alist) is not stored in the population, a new list or alist is created to hold the elements.</p>
</dd>
</dl>
<a id="description_in_f_make-population"></a>
<p>Creates a new population of the specified type.</p>
</div>
<a id="f_population-type"></a>
<div class=definition>
<code>population-type</code> <i>population</i> <span class="definition-kind">[Function]</span><a id="description_in_f_population-type"></a>
<p>returns the type of <CODE>population</CODE>, one of <CODE>:LIST</CODE> or <CODE>:ALIST</CODE></p>
</div>
<a id="f_population-contents"></a>
<div class=definition>
<code>population-contents</code> <i>population</i> <span class="definition-kind">[Function]</span><a id="description_in_f_population-contents"></a>
<p>returns the list encapsulated in <CODE>population</CODE>.
        Note that as long as there is a direct (non-weak) reference to this
        list, it will not be modified by the garbage collector.  Therefore it is
        safe to traverse the list, and even modify it, no different from any
        other list. If you want the elements to become garbage-collectable
        again, you must stop refering to the list directly.</p>
</div>
<a id="f_setf_population-contents"></a>
<div class=definition>
<code>(setf</code>  (<i></i> <i>population-contents</i> <i>population</i>) <i>contents</i>) <span class="definition-kind">[Function]</span><a id="description_in_f_setf_population-contents"></a>
<p>Sets the list encapsulated in <CODE>population</CODE> to
        <CODE>contents</CODE>.  <CODE>Contents</CODE> is not copied,
        it is used directly.</p>
</div>
</div>
<a id="garbage-collection-dictionary"></a>
<H3>Garbage-Collection Dictionary</H3>
<div class="section">
<a id="f_gc"></a>
<div class=definition>
<code>gc</code> <span class="definition-kind">[Function]</span><a id="description_in_f_gc"></a>
<p>Causes a full GC to occur as soon as possible. Returns NIL.</p>
</div>
<a id="f_lisp-heap-gc-threshold"></a>
<div class=definition>
<code>lisp-heap-gc-threshold</code> <span class="definition-kind">[Function]</span><a id="description_in_f_lisp-heap-gc-threshold"></a>
<p>Returns the value of the kernel variable that specifies the
	  amount of free space to leave in the heap after full GC.</p>
</div>
<a id="f_set-lisp-heap-gc-threshold"></a>
<div class=definition>
<code>set-lisp-heap-gc-threshold</code> <i>new-threshold</i> <span class="definition-kind">[Function]</span><a id="arguments-and-values_in_f_set-lisp-heap-gc-threshold"></a>
<dl><dt><I>new-threshold</I></dt>
<dd><p>The requested new lisp-heap-gc-threshold.</p>
</dd>
</dl>
<a id="description_in_f_set-lisp-heap-gc-threshold"></a>
<p>Sets the value of the kernel variable that specifies the
	  amount of free space to leave in the heap after full GC to
	  new-value, which should be a non-negative fixnum. Returns the
	  value of that kernel variable (which may be somewhat larger than
	  what was specified).</p>
</div>
<a id="f_use-lisp-heap-gc-threshold"></a>
<div class=definition>
<code>use-lisp-heap-gc-threshold</code> <span class="definition-kind">[Function]</span><a id="description_in_f_use-lisp-heap-gc-threshold"></a>
<p>Tries to grow or shrink lisp's heap space, so that the
	  free space is (approximately) equal to the current heap threshold.
	  Returns NIL</p>
</div>
<a id="f_egc"></a>
<div class=definition>
<code>egc</code> <i>arg</i> <span class="definition-kind">[Function]</span><a id="arguments-and-values_in_f_egc"></a>
<dl><dt><I>arg</I></dt>
<dd><p>a generalized boolean</p>
</dd>
</dl>
<a id="description_in_f_egc"></a>
<p>Enables the EGC if arg is non-nil, disables the EGC
	  otherwise. Returns the previous enabled status. Although this
	  function is thread-safe (in the sense that calls to it are
	  serialized), it doesn't make a whole lot of sense to be
	  turning the EGC on and off from multiple threads ...</p>
</div>
<a id="f_egc-enabled-p"></a>
<div class=definition>
<code>egc-enabled-p</code> <span class="definition-kind">[Function]</span><a id="description_in_f_egc-enabled-p"></a>
<p>Returns T if the EGC was enabled at the time of the call,
	  NIL otherwise.</p>
</div>
<a id="f_egc-active-p"></a>
<div class=definition>
<code>egc-active-p</code> <span class="definition-kind">[Function]</span><a id="description_in_f_egc-active-p"></a>
<p>Returns T if the EGC was active at the time of the call, NIL
	  otherwise. Since this is generally a volatile piece of
	  information, it's not clear whether this function serves a
	  useful purpose when native threads are involved.</p>
</div>
<a id="f_egc-configuration"></a>
<div class=definition>
<code>egc-configuration</code> <span class="definition-kind">[Function]</span><a id="description_in_f_egc-configuration"></a>
<p>Returns, as multiple values, the sizes in kilobytes of the
	  thresholds associated with the youngest ephemeral generation, the
	  middle ephemeral generation, and the oldest ephemeral generation</p>
</div>
<a id="f_configure-egc"></a>
<div class=definition>
<code>configure-egc</code> <i>generation-0-size</i> <i>generation-1-size</i> <i>generation-2-size</i> <span class="definition-kind">[Function]</span><a id="arguments-and-values_in_f_configure-egc"></a>
<dl><dt><I>generation-0-size</I></dt>
<dd><p>the requested threshold size of the youngest
		generation, in kilobytes</p>
</dd>
<dt><I>generation-1-size</I></dt>
<dd><p>the requested threshold size of the middle generation,
		in kilobytes</p>
</dd>
<dt><I>generation-2-size</I></dt>
<dd><p>the requested threshold size of the oldest generation,
		in kilobytes</p>
</dd>
</dl>
<a id="description_in_f_configure-egc"></a>
<p>Puts the indicated threshold sizes in effect.
          Each threshold indicates the total size that may be allocated
          in that and all younger generations before a GC is triggered.
          Disables EGC while setting the values.
	  (The provided threshold sizes are rounded up to a multiple of
	  64Kbytes in Clozure CL 0.14 and to a multiple of 32KBytes in earlier
	  versions.)</p>
</div>
<a id="f_gc-retain-pages"></a>
<div class=definition>
<code>gc-retain-pages</code> <i>arg</i> <span class="definition-kind">[Function]</span><a id="arguments-and-values_in_f_gc-retain-pages"></a>
<dl><dt><I>arg</I></dt>
<dd><p>a generalized boolean</p>
</dd>
</dl>
<a id="description_in_f_gc-retain-pages"></a>
<p>Tries to influence the GC to retain/recycle the pages
	  allocated between GCs if arg is true, and to release them
	  otherwise. This is generally a tradeoff between paging and other
	  VM considerations.</p>
</div>
<a id="f_gc-retaining-pages"></a>
<div class=definition>
<code>gc-retaining-pages</code> <span class="definition-kind">[Function]</span><a id="description_in_f_gc-retaining-pages"></a>
<p>Returns T if the GC tries to retain pages between full GCs
	  and NIL if it's trying to release them to improve VM paging
	  performance.</p>
</div>
</div>
</div>
<a id="implementation-limits"></a>
<H2>Implementation Limits</H2>
<div class="section">
<ul style="list-style: none">
</ul>
<p>Fixnums on 32-bit systems are 30 bits long, and cover the interval
 (-536870912, 536870911).  Fixnums on 64-bit systems are 61 bits
 long, and cover the interval (-1152921504606846976, 1152921504606846975)
 (see <a href="#tagging-scheme">Tagging scheme</a>).</p>
<p> Because  64-bit systems have large fixnums,
 <CODE>internal-time-units-per-second</CODE> is 1000000 on 64-bit
 systems. It remains 1000 on 32-bit systems.  This enables much finer
 grained timing on 64-bit systems.</p>
</div>
<a id="implementation-details-of-clozure-cl"></a>
<H2>Implementation Details of Clozure CL</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#threads-and-exceptions">
Threads and exceptions</a>
<ul style="list-style: none">
<li><a href="#the-thread-context-record">
The Thread Context Record</a>
<li><a href="#exception-contexts-and-exception-handling-in-general">
Exception contexts, and exception-handling in general</a>
<li><a href="#threads-exceptions-and-the-gc">
Threads, exceptions, and the GC</a>
<li><a href="#pc-lusering">
PC-lusering</a>
</ul>
<li><a href="#register-usage-and-tagging">
Register usage and tagging</a>
<ul style="list-style: none">
<li><a href="#overview_in_register-usage-and-tagging">
Overview</a>
<li><a href="#pc-locatives-on-the-ppc">
pc-locatives on the PPC</a>
<li><a href="#register-and-stack-usage-conventions">
Register and stack usage conventions</a>
<li><a href="#tagging-scheme">
Tagging scheme</a>
</ul>
<li><a href="#heap-allocation">
Heap Allocation</a>
<ul style="list-style: none">
<li><a href="#per-thread-object-allocation">
Per-thread object allocation</a>
<li><a href="#allocation-of-reserved-heap-segments">
Allocation of reserved heap segments</a>
<li><a href="#heap-growth">
Heap growth</a>
</ul>
<li><a href="#gc-details">
GC details</a>
<ul style="list-style: none">
<li><a href="#mark-phase">
Mark phase</a>
<li><a href="#relocation-phase">
Relocation phase</a>
<li><a href="#forwarding-phase">
Forwarding phase</a>
<li><a href="#compact-phase">
Compact phase</a>
</ul>
<li><a href="#the-ephemeral-gc">
The ephemeral GC</a>
<ul style="list-style: none">
</ul>
<li><a href="#fasl-files">
Fasl files</a>
<ul style="list-style: none">
</ul>
<li><a href="#the-objective-c-bridge_in_implementation-details-of-clozure-cl">
The Objective-C Bridge</a>
<ul style="list-style: none">
<li><a href="#how-clozure-cl-recognizes-objective-c-objects">
How Clozure CL Recognizes Objective-C Objects</a>
<li><a href="#recommended-reading_in_the-objective-c-bridge">
Recommended Reading</a>
</ul>
</ul>
<p>This chapter describes many aspects of OpenMCL's
    implementation as of (roughly) version 1.1. Details vary a bit
    between the three architectures (PPC32, PPC64, and x86-64)
    currently supported and those details change over time, so the
    definitive reference is the source code (especially some files in
    the ccl/compiler/ directory whose names contain the string "arch"
    and some files in the ccl/lisp-kernel/ directory whose names
    contain the string "constants".) Hopefully, this chapter will make
    it easier for someone who's interested to read and understand the
    contents of those files.</p>
<a id="threads-and-exceptions"></a>
<H3>Threads and exceptions</H3>
<div class="section">
<p>Clozure CL's threads are "native" (meaning that they're
        scheduled and controlled by the operating system.)  Most of the
        implications of this are discussed elsewhere; this section tries
        to describe how threads look from the lisp kernel's perspective
        (and especially from the GC's point of view.)</p>
<p>        Clozure CL's runtime system tries to use machine-level
        exception mechanisms (conditional traps when available,
        illegal instructions, memory access protection in some cases)
        to detect and handle exceptional situations.  These situations
        include some TYPE-ERRORs and PROGRAM-ERRORS (notably
        wrong-number-of-args errors), and also include cases like "not
        being able to allocate memory without GCing or obtaining more
        memory from the OS."  The general idea is that it's usually
        faster to pay (very occasional) exception-processing overhead
        and figure out what's going on in an exception handler than it
        is to maintain enough state and context to handle an
        exceptional case via a lighter-weight mechanism when that
        exceptional case (by definition) rarely occurs.</p>
<p>        Some emulated execution environments (the Rosetta PPC
        emulator on x86 versions of Mac OS X) don't provide accurate
        exception information to exception handling functions. Clozure CL
        can't run in such environments.</p>
<a id="the-thread-context-record"></a>
<H4>The Thread Context Record</H4>
<div class="section">
<p>When a lisp thread is first created (or when a thread
          created by foreign code first calls back to lisp), a data
          structure called a Thread Context Record (or TCR) is
          allocated and initialized.  On modern versions of Linux and
          FreeBSD, the allocation actually happens via a set of
          thread-local-storage ABI extensions, so a thread's TCR is
          created when the thread is created and dies when the thread
          dies.  (The World's Most Advanced Operating System-as
          Apple's marketing literature refers to Darwin-is not
          very advanced in this regard, and I know of no reason to
          assume that advances will be made in this area anytime
          soon.)</p>
<p>          A TCR contains a few dozen fields (and is therefore a
          few hundred bytes in size.)  The fields are mostly
          thread-specific information about the thread's stacks'
          locations and sizes, information about the underlying (POSIX)
          thread, and information about the thread's dynamic binding
          history and pending CATCH/UNWIND-PROTECTs.  Some of this
          information could be kept in individual machine registers
          while the thread is running (and the PPC - which has more
          registers available - keeps a few things in registers that the
          X86-64 has to access via the TCR), but it's important to
          remember that the information is thread-specific and can't
          (for instance) be kept in a fixed global memory
          location.</p>
<p>          When lisp code is running, the current thread's TCR is
          kept in a register.  On PPC platforms, a general purpose
          register is used; on x86-64, an (otherwise nearly useless)
          segment register works well (prevents the expenditure of a
          more generally useful general- purpose register for this
          purpose.)</p>
<p>          The address of a TCR is aligned in memory in such a way
          that a FIXNUM can be used to represent it.  The lisp function
          CCL::%CURRENT-TCR returns the calling thread's TCR as a
          fixnum; actual value of the TCR's address is 4 or 8 times the
          value of this fixnum.</p>
<p>          When the lisp kernel initializes a new TCR, it's added
          to a global list maintained by the kernel; when a thread
          exits, its TCR is removed from this list.</p>
<p>          When a thread calls foreign code, lisp stack pointers
          are saved in its TCR, lisp registers (at least those whose
          value should be preserved across the call) are saved on the
          thread's value stack, and (on x86-64) RSP is switched to the
          control stack.  A field in the TCR (tcr.valence) is then set
          to indicate that the thread is running foreign code, foreign
          argument registers are loaded from a frame on the foreign
          stack, and the foreign function is called. (That's a little
          oversimplified and possibly inaccurate, but the important
          things to note are that the thread "stops following lisp
          stack and register usage conventions" and that it advertises
          the fact that it's done so.  Similar transitions in a
          thread's state ("valence") occur when it enters or exits an
          exception handler (which is sort of an OS/hardware-mandated
          foreign function call where the OS thoughtfully saves the
          thread's register state for it beforehand.)</p>
</div>
<a id="exception-contexts-and-exception-handling-in-general"></a>
<H4>Exception contexts, and exception-handling in general</H4>
<div class="section">
<p>Unix-like OSes tend to refer to exceptions as "signals";
          the same general mechanism ("signal handling") is used to
          process both asynchronous OS-level events (such as the result
          of the keyboard driver noticing that ^C or ^Z has been
          pressed) and synchronous hardware-level events (like trying to
          execute an illegal instruction or access protected memory.)
          It makes some sense to defer ("block") handling of
          asynchronous signals so that some critical code sequences
          complete without interruption; since it's generally not
          possible for a thread to proceed after a synchronous exception
          unless and until its state is modified by an exception
          handler, it makes no sense to talk about blocking synchronous
          signals (though some OSes will let you do so and doing so can
          have mysterious effects.)</p>
<p>          On OSX/Darwin, the POSIX signal handling facilities
          coexist with lower-level Mach-based exception handling
          facilities.  Unfortunately, the way that this is implemented
          interacts poorly with debugging tools: GDB will generally stop
          whenever the target program encounters a Mach-level exception
          and offers no way to proceed from that point (and let the
          program's POSIX signal handler try to handle the exception);
          Apple's CrashReporter program has had a similar issue and,
          depending on how it's configured, may bombard the user with
          alert dialogs which falsely claim that an application has
          crashed (when in fact the application in question has
          routinely handled a routine exception.)  On Darwin/OSX,
          Clozure CL uses Mach thread-level exception handling facilities
          which run before GDB or CrashReporter get a chance to confuse
          themselves; Clozure CL's Mach exception handling tries to force
          the thread which received a synchronous exception to invoke a
          signal handling function ("as if" signal handling worked more
          usefully under Darwin.)  Mach exception handlers run in a
          dedicated thread (which basically does nothing but wait for
          exception messages from the lisp kernel, obtain and modify
          information about the state of threads in which exceptions
          have occurred, and reply to the exception messages with an
          indication that the exception has been handled.  The reply
          from a thread-level exception handler keeps the exception from
          being reported to GDB or CrashReporter and avoids the problems
          related to those programs.  Since Clozure CL's Mach exception
          handler doesn't claim to handle debugging-related exceptions
          (from breakpoints or single-step operations), it's possible to
          use GDB to debug Clozure CL.</p>
<p>          On platforms where signal handling and debugging don't
          get in each other's way, a signal handler is entered with
          all signals blocked.  (This behavior is specified in the
          call to the sigaction() function which established the
          signal handler.)  The signal handler receives three
          arguments from the OS kernel; the first is an integer that
          identifies the signal, the second is a pointer to an object
          of type "siginfo_t", which may or may not contain a few
          fields that would help to identify the cause of the
          exception, and the third argument is a pointer to a data
          structure (called a "ucontext" or something similar), which
          contains machine-dependent information about the state of
          the thread at the time that the exception/signal occurred.
          While asynchronous signals are blocked, the signal handler
          stores the pointer to its third argument (the "signal
          context") in a field in the current thread's TCR, sets some
          bits in another TCR field to indicate that the thread is now
          waiting to handle an exception, unblocks asynchronous
          signals, and waits for a global exception lock that
          serializes exception processing.</p>
<p>          On Darwin, the Mach exception thread creates a signal
          context (and maybe a siginfo_t structure), stores the signal
          context in the thread's TCR, sets the TCR field which describes
          the thread's state, and arranges that the thread resume
          execution at its signal handling function (with a signal
          handler, possibly NULL siginfo_t, and signal context as
          arguments.  When the thread resumes, it waits for the global
          exception lock.</p>
<p>          On x86-64 platforms where signal handing can be used to
          handle synchronous exceptions, there's an additional
          complication: the OS kernel ordinarily allocates the signal
          context and siginfo structures on the stack of the thread
          that received the signal; in practice, that means "wherever
          RSP is pointing."  Clozure CL's
          <a href="#register-and-stack-usage-conventions">Register and stack usage conventions</a>
          require that the thread's value stack-where RSP is
          usually pointing while lisp code is running-contain
          only "nodes" (properly tagged lisp objects), and scribbling
          a signal context all over the value stack would violate this
          requirement.  To maintain consistency, the sigaltstack()
          mechanism is used to cause the signal to be delivered on
          (and the signal context and siginfo to be allocated on) a
          special stack area (the last few pages of the thread's
          control stack, in practice).  When the signal handler runs,
          it (carefully) copies the signal context and siginfo to the
          thread's control stack and makes RSP point into that stack
          before invoking the "real" signal handler. The effect of
          this hack is that the "real" signal handler always runs on
          the thread's control stack.</p>
<p>          Once the exception handler has obtained the global
          exception lock, it uses the values of the signal number,
          siginfo_t, and signal context arguments to determine the
          (logical) cause of the exception.  Some exceptions may be
          caused by factors that should generate lisp errors or other
          serious conditions (stack overflow); if this is the case, the
          kernel code may release the global exception lock and call out
          to lisp code.  (The lisp code in question may need to repeat
          some of the exception decoding process; in particular, it
          needs to be able to interpret register values in the signal
          context that it receives as an argument.)</p>
<p>          In some cases, the lisp kernel exception handler may not
          be able to recover from the exception (this is currently true
          of some types of memory-access fault and is also true of traps
          or illegal instructions that occur during foreign code
          execution.  In such cases, the kernel exception handler
          reports the exception as "unhandled", and the kernel debugger
          is invoked.</p>
<p>          If the kernel exception handler identifies the
          exception's cause as being a transient out-of-memory condition
          (indicating that the current thread needs more memory to cons
          in), it tries to make that memory available.  In some cases,
          doing so involves invoking the GC.</p>
</div>
<a id="threads-exceptions-and-the-gc"></a>
<H4>Threads, exceptions, and the GC</H4>
<div class="section">
<p>Clozure CL's GC is not concurrent: when the GC is invoked in
          response to an exception in a particular thread, all other
          lisp threads must stop until the GC's work is done.  The
          thread that triggered the GC iterates over the global TCR
          list, sending each other thread a distinguished "suspend"
          signal, then iterates over the list again, waiting for a
          per-thread semaphore that indicates that the thread has
          received the "suspend" signal and responded appropriately.
          Once all other threads have acknowledged the request to
          suspend themselves, the GC thread can run the GC proper (after
          doing any necessary <a href="#pc-lusering">PC-lusering</a>.)  Once the
          GC's completed its work, the thread that invoked the GC
          iterates over the global TCR list, raising a per-thread
          "resume" semaphore for each other thread.</p>
<p>          The signal handler for the asynchronous "suspend" signal
          is entered with all asynchronous signals blocked.  It saves
          its signal-context argument in a TCR slot, raises the tcr's
          "suspend" semaphore, then waits on the TCR's "resume"
          semaphore.</p>
<p>          The GC thread has access to the signal contexts of all
          TCRs (including its own) at the time when the thread received
          an exception or acknowledged a request to suspend itself.
          This information (and information about stack areas in the TCR
          itself) allows the GC to identify the "stack locations and
          register contents" that are elements of the GC's root
          set.</p>
</div>
<a id="pc-lusering"></a>
<H4>PC-lusering</H4>
<div class="section">
<p>It's not quite accurate to say that Clozure CL's compiler
          and runtime follow precise stack and register usage
          conventions at all times; there are a few exceptions:</p>
<ul><li><p>On both PPC and x86-64 platforms, consing isn't
	          fully atomic.It takes at least a few instructions to
	          allocate an object in memory(and slap a header on it if
	          necessary); if a thread is interrupted in the middle of
	          that instruction sequence, the new object may or may
	          not have been created or fully initialized at the point in
	          time that the interrupt occurred.  (There are actually a
	          few different states of partial initialization)</p>
<li><p>On the PPC, the common act of building a lisp
	          control stack frame involves allocating a four-word frame
	          and storing three register values into that frame.  (The
	          fourth word - the back pointer to the previous frame - is
	          automatically set when the frame is allocated.)  The
	          previous contents of those three words are unknown (there
	          might have been a foreign stack frame at the same address a
	          few instructions earlier),so interrupting a thread that's
	          in the process of initializing a PPC control stack frame
	          isn't GC-safe.</p>
<li><p>There are similar problems with the initialization
	          of temp stackframes on the PPC.  (Allocation and
	          initialization doesn't happen atomically, and the newly
	          allocated stack memory may have undefined contents.)</p>
<li><p><a href="#the-ephemeral-gc">The ephemeral GC</a>'s write barrier
	          has to be implemented atomically (i.e.,both an
	          intergenerational store and the update of a
	          corresponding reference bit has to happen without
	          interruption, or neither of these events can
	          happen.)</p>
<li><p>There are a few more similar cases.</p>
</ul>
<p>Fortunately, the number of these non-atomic instruction
          sequences is small, and fortunately it's fairly easy for the
          interrupting thread to recognize when the interrupted thread
          is in the middle of such a sequence.  When this is detected,
          the interrupting thread modifies the state of the interrupted
          thread (modifying its PC and other registers) so that it is no
          longer in the middle of such a sequence (it's either backed
          out of it or the remaining instructions are emulated.)</p>
<p>          This works because (a) many of the troublesome
          instruction sequences are PPC-specific and it's relatively
          easy to partially disassemble the instructions surrounding the
          interrupted thread's PC on the PPC and (b) those instruction
          sequences are heavily stylized and intended to be easily
          recognized.</p>
</div>
</div>
<a id="register-usage-and-tagging"></a>
<H3>Register usage and tagging</H3>
<div class="section">
<a id="overview_in_register-usage-and-tagging"></a>
<H4>Overview</H4>
<div class="section">
<p>Regardless of other details of its implementation, a
	      garbage collector's job is to partition the set of all
	      heap-allocated lisp objects (CONSes, STRINGs, INSTANCEs, etc.)
	      into two subsets.  The first subset contains all objects that
	      are transitively referenced from a small set of "root" objects
	      (the contents of the stacks and registers of all active
	      threads at the time the GC occurs and the values of some
	      global variables.)  The second subset contains everything
	      else: those lisp objects that are not transitively reachable
	      from the roots are garbage, and the memory occupied by garbage
	      objects can be reclaimed (since the GC has just proven that
 	      it's impossible to reference them.)</p>
<p>          The set of live, reachable lisp objects basically form
          the nodes of a (usually large) graph, with edges from each
          node A to any other objects (nodes) that object A
          references.</p>
<p>          Some nodes in this graph can never have outgoing edges:
          an array with a specialized numeric or character type usually
          represents its elements in some (possibly more compact)
          specialized way.  Some nodes may refer to lisp objects that
          are never allocated in memory (FIXNUMs, CHARACTERs,
          SINGLE-FLOATs on 64-bit platforms ..)  This latter class of
          objects are sometimes called "immediates", but that's a little
          confusing because the term "immediate" is sometimes used to
          refer to things that can never be part of the big connectivity
          graph (e.g., the "raw" bits that make up a floating-point
          value, foreign address, or numeric value that needs to be used
          - at least fleetingly - in compiled code.)</p>
<p>          For the GC to be able to build the connectivity graph
          reliably, it's necessary for it to be able to reliably tell
          (a) whether or not a "potential root" - the contents of a
          machine register or stack location - is in fact a node and (b)
          for any node, whether it may have components that refer to
          other nodes.</p>
<p>          There's no reliable way to answer the first question on
          stock hardware.  (If everything was a node, as might be the
          case on specially microcoded "lisp machine" hardware, it
          wouldn't even need to be asked.)  Since there's no way to just
          look at a machine word (the contents of a machine register or
          stack location) and tell whether or not it's a node or just
          some random non-node value, we have to either adopt and
          enforce strict conventions on register and stack usage or
          tolerate ambiguity.</p>
<p>          "Tolerating ambiguity" is an approach taken by some
          ("conservative") GC schemes; by contrast, Clozure CL's GC is
          "precise", which in this case means that it believes that the
          contents of certain machine registers and stack locations are
          always nodes and that other registers and stack locations are
          never nodes and that these conventions are never violated by
          the compiler or runtime system.  The fact that threads are
          preemptively scheduled means that a GC could occur (because of
          activity in some other thread) on any instruction boundary,
          which in turn means that the compiler and runtime system must
          follow precise <a href="#register-and-stack-usage-conventions">Register and stack usage conventions</a> at all
          times.</p>
<p>          Once we've decided that a given machine word is a node,
          a <a href="#tagging-scheme">Tagging scheme</a> describes how the node's
          value and type are encoded in that machine word.</p>
<p>          Most of this discussion-so far-has treated
          things from the GC's very low-level perspective. From a much
          higher point of view, lisp functions accept nodes as
          arguments, return nodes as values, and (usually) perform
          some operations on those arguments in order to produce those
          results.  (In many cases, the operations in question involve
          raw non-node values.)  Higher-level parts of the lisp type
          system (functions like TYPE-OF and CLASS-OF, etc.) depend on
          the <a href="#tagging-scheme">Tagging scheme</a>.</p>
</div>
<a id="pc-locatives-on-the-ppc"></a>
<H4>pc-locatives on the PPC</H4>
<div class="section">
<p>On the PPC, there's a third case (besides "node" and
          "immediate" values).  As discussed below, a node that denotes
          a memory-allocated lisp object is a biased (tagged) pointer
          -to- that object; it's not generally possible to point -into-
          some composite (multi-element) object (such a pointer would
          not be a node, and the GC would have no way to update the
          pointer if it were to move the underlying object.)</p>
<p>          Such a pointer ("into" the interior of a heap-allocated
          object) is often called a <EMPH>locative</EMPH>; the
          cases where locatives are allowed in Clozure CL mostly involve
          the behavior of function call and return instructions.  (To be
          technically accurate, the other case also arises on x86-64, but
          that case isn't as user-visible.)</p>
<p>          On the PowerPC (both PPC32 and PPC64), all machine
          instructions are 32 bits wide and all instruction words are
          allocated on 32-bit boundaries.  In PPC Clozure CL, a CODE-VECTOR
          is a specialized type of vector-like object; its elements
          are 32-bit PPC machine instructions.  A CODE-VECTOR is an
          attribute of a FUNCTION object; a function call involves
          accessing the function's code-vector and jumping to the
          address of its first instruction.</p>
<p>          As each instruction in the code vector sequentially
          executes, the hardware program counter (PC) register advances
          to the address of the next instruction (a locative into the
          code vector); since PPC instructions are always 32 bits wide
          and aligned on 32-bit boundaries, the low two bits of the PC
          are always 0.  If the function executes a call (simple call
          instructions have the mnemonic "bl" on the PPC, which stands
          for "branch and link"), the address of the next instruction
          (also a word-aligned locative into a code-vector) is copied
          into the special- purpose PPC "link register" (lr); a function
          returns to its caller via a "branch to link register" (blr)
          instruction.  Some cases of function call and return might
          also use the PPC's "count register" (ctr), and if either the
          lr or ctr needs to be stored in memory it needs to first be
          copied to a general-purpose register.</p>
<p>          Clozure CL's GC understands that certain registers contain
          these special "pc-locatives" (locatives that point into
          CODE-VECTOR objects); it contains special support for
          finding the containing CODE-VECTOR object and for adjusting
          all of these "pc-locatives" if the containing object is
          moved in memory.  The first part of that
          operation-finding the containing object-is
          possible and practical on the PPC because of architectural
          artifacts (fixed-width instructions and arcana of
          instruction encoding.)  It's not possible on x86-64, but
          fortunately not necessary either (though the second part -
          adjusting the PC/RIP when the containing object moves) is
          both necessary and simple.</p>
</div>
<a id="register-and-stack-usage-conventions"></a>
<H4>Register and stack usage conventions</H4>
<div class="section">
<a id="stack-conventions"></a>
<H5>Stack conventions</H5>
<div class="section">
<p>On both PPC and X86 platforms, each lisp thread uses 3
            stacks; the ways in which these stacks are used differs
            between the PPC and X86.</p>
<p>Each thread has:</p>
<ul><li><p>A "control stack".  On both platforms, this is
	            "the stack" used by foreign code.  On the PPC, it
	            consists of a linked list of frames where the first word
	            in each frame points to the first word in the previous
	            frame (and the outermost frame points to 0.)  Some
	            frames on a PPC control stack are lisp frames; lisp
	            frames are always 4 words in size and contain (in
	            addition to the back pointer to the previous frame) the
	            calling function (a node), the return address (a
	            "locative" into the calling function's code-vector), and
	            the value to which the value-stack pointer (see below)
	            should be restored on function exit.  On the PPC, the GC
	            has to look at control-stack frames, identify which of
	            those frames are lisp frames, and treat the contents of
	            the saved function slot as a node (and handle the return
	            address locative specially.)  On x86-64, the control
	            stack is used for dynamic-extent allocation of immediate
	            objects.  Since the control stack never contains nodes
	            on x86-64, the GC ignores it on that platform.
	            Alignment of the control stack follows the ABI
	            conventions of the platform (at least at any point in
	            time where foreign code could run.)  On PPC, the r1
	            register always points to the top of the current
	            thread's control stack; on x86-64, the RSP register
	            points to the top of the current thread's control stack
	            when the thread is running foreign code and the address
	            of the top of the control stack is kept in the thread's
	            TCR (see <a href="#the-thread-context-record">The Thread Context Record</a>
	            when not running foreign code.  The control stack "grows
	            down."</p>
<li><p>A "value stack".  On both platforms, all values on
	            the value stack are nodes (including "tagged return
	            addresses" on x86-64.)  The value stack is always
	            aligned to the native word size; objects are always
	            pushed on the value stack using atomic instructions
	            ("stwu"/"stdu" on PPC, "push" on x86-64), so the
	            contents of the value stack between its bottom and top
	            are always unambiguously nodes; the compiler usually
	            tries to pop or discard nodes from the value stack as
	            soon as possible after their last use (as soon as they
	            may have become garbage.)  On x86-64, the RSP register
	            addresses the top of the value stack when running lisp
	            code; that address is saved in the TCR when running
	            foreign code.  On the PPC, a dedicated register (VSP,
	            currently r15) is used to address the top of the value
	            stack when running lisp code, and the VSP value is saved
	            in the TCR when running foreign code.  The value stack
	            grows down.</p>
<li><p>A "temp stack".  The temp stack consists of a
	            linked list of frames, each of which points to the
	            previous temp stack frame.  The number of native
	            machine words in each temp stack frame is always even,
	            so the temp stack is aligned on a two-word (64- or
	            128-bit) boundary.  The temp stack is used for
	            dynamic-extent objects on both platforms; on the PPC,
	            it's used for essentially all such objects (regardless
	            of whether or not the objects contain nodes); on the
	            x86-64, immediate dynamic-extent objects (strings,
	            foreign pointers, etc.)  are allocated on the control
	            stack and only node-containing dynamic-extent objects
	            are allocated on the temp stack.  Data structures used
	            to implement CATCH and UNWIND-PROTECT are stored on
	            the temp stack on both ppc and x86-64.  Temp stack
	            frames are always doublenode aligned and objects
	            within a temp stack frame are aligned on doublenode
	            boundaries.  The first word in each frame contains a
	            back pointer to the previous frame; on the PPC, the
	            second word is used to indicate to the GC whether the
	            remaining objects are nodes (if the second word is 0)
	            or immediate (otherwise.)  On x86-64, where temp stack
	            frames always contain nodes, the second word is always
	            0.  The temp stack grows down.  It usually takes
	            several instructions to allocate and safely initialize
	            a temp stack frame that's intended to contain nodes,
	            and the GC has to recognize the case where a thread is
	            in the process of allocating and initializing a temp
	            stack frame and take care not to interpret any
	            uninitialized words in the frame as nodes. The PPC
	            keeps the current top of the temp stack in a dedicated
	            register (TSP, currently r12) when running lisp code
	            and saves this register's value in the TCR when
	            running foreign code.  The x86-64 keeps the address of
	            the top of each thread's temp stack in the thread's
	            TCR.</p>
</ul>
</div>
<a id="register-conventions"></a>
<H5>Register conventions</H5>
<div class="section">
<p>If there are a "reasonable" (for some value of
            "reasonable") number of general-purpose registers and the
            instruction set is "reasonably" orthogonal (most
            instructions that operate on GPRs can operate on any GPR),
            then it's possible to statically partition the GPRs into at
            least two sets: "immediate registers" never contain nodes,
            and "node registers" always contain nodes.  (On the PPC, a
            few registers are members of a third set of "PC locatives",
            and on both platforms some registers may have dedicated
            roles as stack or heap pointers; the latter class is treated
            as immediates by the GC proper but may be used to help
            determine the bounds of stack and heap memory areas.)</p>
<p>            The ultimate definition of register partitioning is
            hardwired into the GC in functions like "mark_xp()" and
            "forward_xp()", which process the values of some of the
            registers in an exception frame as nodes and may give some
            sort of special treatment to other register values they
            encounter there.)</p>
<p>On x86-64, the static register partitioning scheme involves:</p>
<ul><li><p>(only) three "immediate" registers.</p>
<p>	            The RAX, RCX, and RDX registers are used as the
	            implicit operands and results of some extended-precision
	            multiply and divide instructions which generally involve
	            non-node values; since their use in these instructions
	            means that they can't be guaranteed to contain node
	            values at all times, it's natural to put these registers
	            in the "immediate" set. RAX is generally given the
	            symbolic name "imm0", RDX is given the symbolic name
	            "imm1" and RCX is given the symbolic name "imm2"; you
	            may see these names in disassembled code, usually in
	            operations involving type checking, array indexing, and
	            foreign memory and function access.</p>
<li><p>(only) two "dedicated" registers.</p>
<p>	            RSP and RBP have
	            dedicated functionality dictated by the hardware and
	            calling conventions.</p>
<li><p>11 "node" registers.</p>
<p>	            All other registers (RBX, RSI, RDI, and R8-R15)
	            are asserted to contain node values at (almost) all
	            times; legacy "string" operations that implicitly use RSI
	            and/or RDI are not used.</p>
</ul>
<p>
		On 32-bit x86, the default register partitioning scheme
		involves:
	      </p>
<ul><li><p>
		  A single "immediate" register.</p>
<p>		    The EAX register is given the symbolic name
		    "imm0".
		  </p>
<li><p>
		    There are two "dedicated" registers.</p>
<p>		    ESP and EBP have dedicated functionality dictated by the
		    hardware and calling conventions.
		  </p>
<li><p>
		    5 "node" registers.</p>
<p>		    The remaining registers, (EBX, ECX, EDX, ESI, EDI) normally
		    contain node values.  As on x86-64, string instructions
		    that implicity use ESI and EDI are not used.
		  </p>
</ul>
<p>
		There are times when this default partitioning scheme is
		inadequate.  As mentioned in the x86-64 section, there are
		instructions like the extended-precision MUL and DIV which
		require the use of EAX and EDX.  We therefore need a way to
		change this partitioning at run-time.</p>
<p>		Two schemes are employed.  The first uses a mask in the TCR
		that contains a bit for each register.  If the bit is set,
		the register is interpreted by the GC as a node register; if it's
		clear, the register is treated as an immediate register.  The
		second scheme uses the direction flag in the EFLAGS register.
		If DF is set, EDX is treated as an immediate register.
		(We don't use the string instructions, so DF isn't otherwise
		used.)</p>
<p>            On the PPC, the static register partitioning scheme
            involves:</p>
<ul><li><p>6 "immediate" registers.</p>
<p>	            Registers r3-r8 are given
	            the symbolic names imm0-imm5.  As a RISC architecture
	            with simpler addressing modes, the PPC probably
	            uses immediate registers a bit more often than the CISC
	            x86-64 does, but they're generally used for the same sort
	            of things (type checking, array indexing, FFI,
	            etc.)</p>
<li><p>9 dedicated registers
	            </p>
<ul><li><p>r0 (symbolic name rzero) always contains the
		              value 0 when running lisp code.  Its value is
		              sometimes read as 0 when it's used as the base
		              register in a memory address; keeping the value 0
		              there is sometimes convenient and avoids
		              asymmetry.</p>
<li><p>r1 (symbolic name sp) is the control stack
		              pointer, by PPC convention.</p>
<li><p>r2 is used to hold the current thread's TCR on
		              ppc64 systems; it's not used on ppc32.</p>
<li><p>r9 and r10 (symbolic names allocptr and
		              allocbase) are used to do per-thread memory
		              allocation</p>
<li><p>r11 (symbolic name nargs) contains the number
		              of function arguments on entry and the number of
		              return values in multiple-value returning
		              constructs.  It's not used more generally as either
		              a node or immediate register because of the way that
		              certain trap instruction encodings are
		              interpreted.</p>
<li><p>r12 (symbolic name tsp) holds the top of the
		              current thread's temp stack.</p>
<li><p>r13 is used to hold the TCR on PPC32 systems;
		              it's not used on PPC64.</p>
<li><p>r14 (symbolic name loc-pc) is used to copy
		              "pc-locative" values between main memory and
		              special-purpose PPC registers (LR and CTR) used in
		              function-call and return instructions.</p>
<li><p>r15 (symbolic name vsp) addresses the top of
		              the current thread's value stack.</p>
<li><p>lr and ctr are PPC branch-unit registers used
		              in function call and return instructions; they're
		              always treated as "pc-locatives", which precludes
		              the use of the ctr in some PPC looping
		              constructs.</p>
</ul>
<li><p>17 "node" registers</p>
<p>	            r15-r31 are always treated as node
	            registers</p>
</ul>
</div>
</div>
<a id="tagging-scheme"></a>
<H4>Tagging scheme</H4>
<div class="section">
<p>Clozure CL always allocates lisp objects on double-node
          (64-bit for 32-bit platforms, 128-bit for 64-bit platforms)
          boundaries; this mean that the low 3 bits (32-bit lisp) or 4
          bits (64-bit lisp) are always 0 and are therefore redundant
          (we only really need to know the upper 29 or 60 bits in order
          to identify the aligned object address.)  The extra bits in a
          lisp node can be used to encode at least some information
          about the node's type, and the other 29/60 bits represent
          either an immediate value or a doublenode-aligned memory
          address.  The low 3 or 4 bits of a node are called the node's
          "tag bits", and the conventions used to encode type
          information in those tag bits are called a "tagging
          scheme."</p>
<p>          It might be possible to use the same tagging scheme on
          all platforms (at least on all platforms with the same word
          size and/or the same number of available tag bits), but there
          are often some strong reasons for not doing so.  These
          arguments tend to be very machine-specific: sometimes, there
          are fairly obvious machine-dependent tricks that can be
          exploited to make common operations on some types of tagged
          objects faster; other times, there are architectural
          restrictions that make it impractical to use certain tags for
          certain types.  (On PPC64, the "ld" (load doubleword) and
          "std" (store doubleword) instructions - which load and store a
          GPR operand at the effective address formed by adding the
          value of another GPR operand and a 16-bit constant operand -
          require that the low two bits of that constant operand be 0.
          Since such instructions would typically be used to access the
          fields of things like CONS cells and structures, it's
          desirable that that the tags chosen for CONS cells and
          structures allow the use of these instructions as opposed to
          more expensive alternatives.)</p>
<p>          One architecture-dependent tagging trick that works well
          on all architectures is to use a tag of 0 for FIXNUMs: a
          fixnum basically encodes its value shifted left a few bits
          and keeps those low bits clear. FIXNUM addition,
          subtraction, and binary logical operations can operate
          directly on the node operands, addition and subtraction can
          exploit hardware-based overflow detection, and (in the
          absence of overflow) the hardware result of those operations
          is a node (fixnum).  Some other slightly-less-common
          operations may require a few extra instructions, but
          arithmetic operations on FIXNUMs should be as cheap as
          possible and using a tag of zero for FIXNUMs helps to ensure
          that it will be.</p>
<p>	      If we have N available tag bits (N = 3 for 32-bit Clozure CL
	      and N = 4 for 64-bit Clozure CL), this way of representing
	      fixnums with the low M bits forced to 0 works as long as M
	      &lt;= N.  The smaller we make M, the larger the values of
	      MOST-POSITIVE-FIXNUM and MOST-NEGATIVE become; the larger we
	      make N, the more distinct non-FIXNUM tags become available.
	      A reasonable compromise is to choose M = N-1; this basically
	      yields two distinct FIXNUM tags (one for even fixnums, one
	      for odd fixnums), gives 30-bit fixnums on 32-bit platforms
	      and 61-bit fixnums on 64-bit platforms, and leaves us with 6
	      or 14 tags to encoded other types.</p>
<p>          Once we get past the assignment of FIXNUM tags, things
          quickly devolve into machine-dependencies.  We can fairly
          easily see that we can't directly tag all other primitive
          lisp object types with only 6 or 14 available tag values;
          the details of how types are encoded vary between the ppc32,
          ppc64, and x86-64 implementations, but there are some
          general common principles:</p>
<ul><li><p>CONS cells always contain exactly 2 elements and are
	          usually fairly common.It therefore makes sense to give
	          CONS cells their own tag.  Unlike the fixnum case -
	          where a tag value of 0 had positive implications - there
	          doesn't seem to be any advantage to using any particular
	          value.  (A longtime ago - in the case of 68K MCL - the
	          CONS tag and the order of CAR and CDR in memory were
	          chosen to allow smaller, cheaper addressing modes to be
	          used to "cdr down a list."  That's not a factor on ppc
	          or x86-64, but all versions of Clozure CL still store the CDR
	          of a CONS cell first in memory.  It doesn't matter, but
	          doing it the way that the host system did made
	          boostrapping to a new target system a little easier.)
	        </p>
<li><p>Any way you look at it, NIL is a bit
	          ... unusual. NIL is both a SYMBOL and a LIST (as well as
	          being a canonical truth value and probably a few other
	          things.)  Its role as a LIST is probably much more
	          important to most programs than its role as a SYMBOL is:
	          LISTP has to be true of NIL and primitives like CAR and
	          CDR do LISTP implicitly when safe and want that
	          operation to be fast. There are several possible
	          approaches to this problem; Clozure CL uses two of them. On
	          PPC32 and X86-64, NIL is basically a weird CONS cell
	          that straddles two doublenodes; the tag of NIL is unique
	          and congruent modulo 4 (modulo 8 on 64-bit) with the tag
	          used for CONS cells.  LISTP is therefore true of any
	          node whose low 2 (or 3) bits contain the appropriate tag
	          value (it's not otherwise necessary to special-case
	          NIL.)  SYMBOL accessors (SYMBOL-NAME, SYMBOL-VALUE,
	          SYMBOL-PLIST ..) -do- have to special-case NIL (and
	          access the components of an internal proxy symbol.) On
	          PPC64 (where architectural restrictions dictate the set
	          of tags that can be used to access fixed components of
	          an object), that approach wasn't practical.  NIL is just
	          a distinguished SYMBOL,and it just happens to be the
	          case that its pname slot and values slot are at the same
	          offsets from a tagged pointer as a CONS cell's CDR and
	          CAR would be.  NIL's pname is set to NIL (SYMBOL-NAME
	          checks for this and returns the string "NIL"), and LISTP
	          (and therefore safe CAR and CDR) has to check for (OR
	          NULL CONSP). At least in the case of CAR and CDR, the
	          fact that the PPC has multiple condition-code fields
	          keeps that extra test from being prohibitively
	          expensive.  On IA-32, we can't afford to dedicate a tag to
		  NIL. NIL is therefore just a distinguished CONS
		  cell, and we have to explicitly check for a NIL argument
		  in CONSP/RPLACA/RPLACD.
		</p>
<li><p>Some objects are immediate (but not FIXNUMs). This
	          is true of CHARACTERs and, on 64-bit platforms,
	          SINGLE-FLOATs. It's also true of some nodes used in the
	          runtime system (special values used to indicate unbound
	          variables and slots, for instance.) On 64-bit platforms,
	          SINGLE-FLOATs have their own unique tag (making them a
	          little easier to recognize; on all platforms, CHARACTERs
	          share a tag with other immediate objects (unbound
	          markers) but are easy to recognize (by looking at
	          several of their low bits.)  The GC treats any node with
	          an immediate tag (and any node with a fixnum tag) as a
	          leaf.</p>
<li><p>There are some advantages to treating everything
	          else-memory-allocated objects that aren't CONS
	          cells-uniformly.There are some disadvantages to
	          that uniform treatment as well, and the treatment of
	          "memory-allocated non-CONS objects" isn't entirely
	          uniform across all Clozure CL implementations.  Let's first
	          pretend that the treatment is uniform, then discuss the
	          ways in which it isn't.The "uniform approach" is to
	          treat all memory-allocated non-CONS objects as if they
	          were vectors; this use of the term is a little looser
	          than what's implied by the CL VECTOR type.  Clozure CL
	          actually uses the term "uvector" to mean "a
	          memory-allocated lisp object other than a CONS cell,
	          whose first word is a header that describes the object's
	          type and the number of elements that it contains."  In
	          this view, a SYMBOL is a UVECTOR, as is a STRING, a
	          STANDARD-INSTANCE, a CL array or vector, a FUNCTION, and
	          even a DOUBLE-FLOAT. In the PPC implementations (where
	          things are a little more ... uniform), a single tag
	          value is used to denote any uvector; in order to
	          determine something more specific about the type of the
	          object in question, it's necessary to fetch the low byte
	          of the header word from memory.  On the x86-64 platform,
	          certain types of uvectors - SYMBOLs and FUNCTIONs -are
	          given their own unique tags.  The good news about the
	          x86-64 approach is that SYMBOLs and FUNCTIONs can be
	          recognized without referencing memory; the slightly bad
	          news is that primitive operations that work on
	          UVECTOR-tagged objects-like the function
	          CCL:UVREF-don't work on SYMBOLs or FUNCTIONs on
	          x86-64 (but -do- work on those types of objects in the
	          PPC ports.) The header word that precedes a UVECTOR's
	          data in memory contains 8 bits of type information in
	          the low byte and either 24 or 56 bits of "element-count"
	          information in the rest of the word.  (This is where the
	          sometimes-limiting value of 2^24 for
	          ARRAY-TOTAL-SIZE-LIMIT on 32-bit platforms comes from.)
	          The low byte of the header-sometimes called the
	          uvector's subtag-is itself tagged (which means
	          that the header is tagged.)  The (3 or 4) tag bits in
	          the subtag are used to determine whether the uvector's
	          elements are nodes or immediates. (A UVECTOR whose
	          elements are nodes is called a GVECTOR; a UVECTOR whose
	          elements are immediates is called an IVECTOR.  This
	          terminology came from Spice Lisp, which was a
	          predecessor of CMUCL.)  Even though a uvector header is
	          tagged, a header is not a node.  There's no (supported)
	          way to get your hands on one in lisp and doing so could
	          be dangerous.  (If the value of a header wound up in a
	          lisp node register and that register wound up getting
	          pushed on a thread's value stack, the GC might
	          misinterpret that situation to mean that there was a
	          stack-allocated UVECTOR on the value stack.)</p>
</ul>
</div>
</div>
<a id="heap-allocation"></a>
<H3>Heap Allocation</H3>
<div class="section">
<p>When the Clozure CL kernel first
        starts up, a large contiguous chunk of the process's address
        space is mapped as "anonymous, no access" memory. ("Large"
        means different things in different contexts; on LinuxPPC32,
        it means "about 1 gigabyte", on DarwinPPC32, it means "about 2
        gigabytes", and on current 64-bit platforms it ranges from 128
        to 512 gigabytes, depending on OS. These values are both
        defaults and upper limits;
        the <CODE>--heap-reserve</CODE> argument can be used to
        try to reserve less than the default.)</p>
<p>        Reserving address space that can't (yet) be read or
        written to doesn't cost much; in particular, it doesn't require
        that corresponding swap space or physical memory be available.
        Marking the address range as being "mapped" helps to ensure that
        other things (results from random calls to malloc(), dynamically
        loaded shared libraries) won't be allocated in this region that
        lisp has reserved for its own heap growth.</p>
<p>        A small portion (around 1/32 on 32-bit platforms and 1/64
        on 64-bit platforms) of that large chunk of address space is
        reserved for GC data structures.  Memory pages reserved for
        these data structures are mapped read-write as pages are made
        writable in the main portion of the heap.</p>
<p>        The initial heap image is mapped into this reserved
        address space and an additional (LISP-HEAP-GC-THRESHOLD) bytes
        are mapped read-write.  GC data structures grow to match the
        amount of GC-able memory in the initial image plus the gc
        threshold, and control is transferred to lisp code.
        Inevitably, that code spoils everything and starts consing;
        there are basically three layers of memory allocation that can
        go on.</p>
<a id="per-thread-object-allocation"></a>
<H4>Per-thread object allocation</H4>
<div class="section">
<p>Each lisp thread has a private "reserved memory
          segment"; when a thread starts up, its reserved memory segment
          is empty.  PPC ports maintain the highest unallocated address
          and the lowest allocatable address in the current segment in
          registers when running lisp code; on x86-664, these values are
          maintained in the current threads's TCR.  (An "empty" heap
          segment is one whose high pointer and low pointer are equal.)
          When a thread is not in the middle of allocating something, the
          low 3 or 4 bits of the high and low pointers are clear (the
          pointers are doublenode-aligned.)</p>
<p>          A thread tries to allocate an object whose physical size
          in bytes is X and whose tag is Y by:</p>
<ol><li><p>decrementing the "high" pointer by (- X Y)</p>
<li><p>trapping if the high pointer is less than the low
	          pointer</p>
<li><p>using the (tagged) high pointer to initialize the
	          object, if necessary</p>
<li><p>clearing the low bits of the high pointer</p>
</ol>
<p>On PPC32, where the size of a CONS cell is 8 bytes and
          the tag of a CONS cell is 1, machine code which sets the arg_z
          register to the result of doing (CONS arg_y arg_z) looks
          like:</p>
<pre class="source-code">
  (SUBI ALLOCPTR ALLOCPTR 7)    ; decrement the high pointer by (- 8 1)
  (TWLLT ALLOCPTR ALLOCBASE)    ; trap if the high pointer is below the base
  (STW ARG_Z -1 ALLOCPTR)       ; set the CDR of the tagged high pointer
  (STW ARG_Y 3 ALLOCPTR)        ; set the CAR
  (MR ARG_Z ALLOCPTR)           ; arg_z is the new CONS cell
  (RLWINM ALLOCPTR ALLOCPTR 0 0 28)     ; clear tag bits
	    
</pre>
<p>On x86-64, the idea's similar but the implementation is
          different.  The high and low pointers to the current thread's
          reserved segment are kept in the TCR, which is addressed by
          the gs segment register. An x86-64 CONS cell is 16 bytes wide
          and has a tag of 3; we canonically use the temp0 register to
          initialize the object</p>
<pre class="source-code">
  (subq ($ 13) ((% gs) 216))    ; decrement allocptr
  (movq ((% gs) 216) (% temp0)) ; load allocptr into temp0
  (cmpq ((% gs) 224) (% temp0)) ; compare to allocabase
  (jg L1)                       ; skip trap
  (uuo-alloc)                   ; uh, don't skip trap
L1
  (andb ($ 240) ((% gs) 216))   ; untag allocptr in the tcr
  (movq (% arg_y) (5 (% temp0))) ; set the car
  (movq (% arg_z) (-3 (% temp0))); set the cdr
  (movq (% temp0) (% arg_z))    ; return the cons
	    
</pre>
<p>If we don't take the trap (if allocating 8-16 bytes
          doesn't exhaust the thread's reserved memory segment), that's
          a fairly short and simple instruction sequence.  If we do take
          the trap, we'll have to do some additional work in order to
          get a new segment for the current thread.</p>
</div>
<a id="allocation-of-reserved-heap-segments"></a>
<H4>Allocation of reserved heap segments</H4>
<div class="section">
<p>After the lisp image is first mapped into memory - and after
          each full GC - the lisp kernel ensures that
          (LISP-HEAP-GC-TRESHOLD) additional bytes beyond the current
          end of the heap are mapped read-write.</p>
<p>          If a thread traps while trying to allocate memory, the
          thread goes through the usual exception-handling protocol (to
          ensure that any other thread that GCs "sees" the state of the
          trapping thread and to serialize exception handling.)  When
          the exception handler runs, it determines the nature and size
          of the failed allocation and tries to complete the allocation
          on the thread's behalf (and leave it with a reasonably large
          thread-specific memory segment so that the next small
          allocation is unlikely to trap.</p>
<p>          Depending on the size of the requested segment
          allocation, the number of segment allocations that have
          occurred since the last GC, and the EGC and GC thresholds, the
          segment allocation trap handler may invoke a full or ephemeral
          GC before returning a new segment.  It's worth noting that the
          [E]GC is triggered based on the number of and size of these
          segments that have been allocated since the last GC; it doesn't
          have much to do with how "full" each of those per-thread
          segments are.  It's possible for a large number of threads to
          do fairly incidental memory allocation and trigger the GC as a
          result; avoiding this involves tuning the per-thread
          allocation quantum and the GC/EGC thresholds
          appropriately.</p>
</div>
<a id="heap-growth"></a>
<H4>Heap growth</H4>
<div class="section">
<p>All OSes on which Clozure CL currently runs use an
          "overcommit" memory allocation strategy by default (though
          some of them provide ways of overriding that default.)  What
          this means in general is that the OS doesn't necessarily
          ensure that backing store is available when asked to map pages
          as read-write; it'll often return a success indicator from the
          mapping attempt (mapping the pages as "zero-fill,
          copy-on-write"), and only try to allocate the backing store
          (swap space and/or physical memory) when non-zero contents are
          written to the pages.</p>
<p>          It -sounds- like it'd be better to have the mmap() call
          fail immediately, but it's actually a complicated issue.
          (It's possible that other applications will stop using some
          backing store before lisp code actually touches the pages that
          need it, for instance.)  It's also not guaranteed that lisp
          code would be able to "cleanly" signal an out-of-memory
          condition if lisp is ... out of memory</p>
<p>	      I don't know that I've ever seen an abrupt out-of-memory
	      failure that wasn't preceded by several minutes of excessive
	      paging activity.  The most expedient course in cases like this
	      is to either (a) use less memory or (b) get more memory; it's
	      generally hard to use memory that you don't have.</p>
</div>
</div>
<a id="gc-details"></a>
<H3>GC details</H3>
<div class="section">
<p>The GC uses a Mark/Compact algorithm; its
        execution time is essentially a factor of the amount of live
        data in the heap. (The somewhat better-known Mark/Sweep
        algorithms don't compact the live data but instead traverse the
        garbage to rebuild free-lists; their execution time is therefore
        a factor of the total heap size.)</p>
<p>        As mentioned in <a href="#heap-allocation">Heap Allocation</a>, two
        auxiliary data structures (proportional to the size of the lisp
        heap) are maintained. These are</p>
<ol><li><p>the markbits bitvector, which contains a bit for
	        every doublenode in the dynamic heap (plus a few extra words
	        for alignment and so that sub-bitvectors can start on word
	        boundaries.)</p>
<li><p>the relocation table, which contains a native word for
	        every 32 or 64 doublenodes in the dynamic heap, plus an
	        extra word used to keep track of the end of the heap.</p>
</ol>
<p>The total GC space overhead is therefore on the order of
        3% (2/64 or 1/32).</p>
<p>The general algorithm proceeds as follows:</p>
<a id="mark-phase"></a>
<H4>Mark phase</H4>
<div class="section">
<p>Each doublenode in the dynamic heap has a corresponding
          bit in the markbits vector. (For any doublenode in the heap,
          the index of its mark bit is determined by subtracting the
          address of the start of the heap from the address of the
          object and dividing the result by 8 or 16.) The GC knows the
          markbit index of the free pointer, so determining that the
          markbit index of a doubleword address is between the start of
          the heap and the free pointer can be done with a single
          unsigned comparison.</p>
<p>          The markbits of all doublenodes in the dynamic heap are
          zeroed before the mark phase begins. An object is
          <EMPH>marked</EMPH> if the markbits of all of its
          constituent doublewords are set and unmarked otherwise;
          setting an object's markbits involves setting the corresponding
          markbits of all constituent doublenodes in the object.</p>
<p>          The mark phase traverses each root. If the tag of the
          value of the root indicates that it's a non-immediate node
          whose address lies in the lisp heap, then:</p>
<ol><li><p>If the object is already marked, do nothing.</p>
<li><p>Set the object's markbit(s).</p>
<li><p>If the object is an ivector, do nothing further.</p>
<li><p>If the object is a cons cell, recursively mark its
	          car and cdr.</p>
<li><p>Otherwise, the object is a gvector. Recursively mark
	          its elements.</p>
</ol>
<p>Marking an object thus involves ensuring that its mark
          bits are set and then recursively marking any pointers
          contained within the object if the object was originally
          unmarked. If this recursive step was implemented in the
          obvious manner, marking an object would take stack space
          proportional to the length of the pointer chain from some root
          to that object. Rather than storing that pointer chain
          implicitly on the stack (in a series of recursive calls to the
          mark subroutine), the Clozure CL marker uses mixture of recursion
          and a technique called <EMPH>link inversion</EMPH> to
          store the pointer chain in the objects themselves.  (Recursion
          tends to be simpler and faster; if a recursive step notes that
          stack space is becoming limited, the link-inversion technique
          is used.)</p>
<p>Certain types of objects are treated a little specially:</p>
<ol><li><p>To support a feature called <EMPH>GCTWA</EMPH>
                (an acronym that I believe comes from MACLISP,
		            where it stood for "Garbage Collection of Truly
		            Worthless Atoms"),
                   the vector that contains the internal
	          symbols of the current package is marked on entry to the
	          mark phase, but the symbols themselves are not marked at
	          this time. Near the end of the mark phase, symbols
	          referenced from this vector which are not otherwise
	          marked are marked if and only if they're somehow
	          distinguishable from newly created symbols (by virtue of
	          their having function bindings, value bindings, plists,
	          or other attributes.)</p>
<li><p>Pools have their first element set to NIL before any
	          other elements are marked.</p>
<li><p>All hash tables have certain fields (used to cache
	          previous results) invalidated.</p>
<li><p>Weak Hash Tables and other weak objects are put on a
	          linkedlist as they're encountered; their contents are only
	          retained if there are other (non-weak) references to
	          them.</p>
</ol>
<p>At the end of the mark phase, the markbits of all
          objects that are transitively reachable from the roots are
          set and all other markbits are clear.</p>
</div>
<a id="relocation-phase"></a>
<H4>Relocation phase</H4>
<div class="section">
<p>The <EMPH>forwarding address</EMPH> of a
	      doublenode in the dynamic heap is (&lt;its current address&gt; -
	      (size_of_doublenode * &lt;the number of unmarked markbits that
	      precede it&gt;)) or alternately (&lt;the base of the heap&gt; +
	      (size_of_doublenode * &lt;the number of marked markbits that
	      precede it &gt;)). Rather than count the number of preceding
	      markbits each time, the relocation table is used to precompute
	      an approximation of the forwarding addresses for all
	      doublewords. Given this approximate address and a pointer into
	      the markbits vector, it's relatively easy to compute the exact
	      forwarding address.</p>
<p>	      The relocation table contains the forwarding addresses
	      of each <EMPH>pagelet</EMPH>, where a pagelet is 256
	      bytes (or 32 doublenodes). The forwarding address of the first
	      pagelet is the base of the heap. The forwarding address of the
	      second pagelet is the sum of the forwarding address of the
	      first and 8 bytes for each mark bit set in the first 32-bit
	      word in the markbits table. The last entry in the relocation
	      table contains the forwarding address that the freepointer
	      would have, e.g., the new value of the freepointer after
	      compaction.</p>
<p>	      In many programs, old objects rarely become garbage and
	      new objects often do. When building the relocation table, the
	      relocation phase notes the address of the first unmarked
	      object in the dynamic heap. Only the area of the heap between
	      the first unmarked object and the freepointer needs to be
	      compacted; only pointers to this area will need to be
	      forwarded (the forwarding address of all other pointers to the
	      dynamic heap is the address of that pointer.)  Often, the
	      first unmarked object is much nearer the free pointer than it
	      is to the base of the heap.</p>
</div>
<a id="forwarding-phase"></a>
<H4>Forwarding phase</H4>
<div class="section">
<p>The forwarding phase traverses all roots and the "old"
          part of the dynamic heap (the part between the base of the
          heap and the first unmarked object.) All references to objects
          whose address is between the first unmarked object and the
          free pointer are updated to point to the address the object
          will have after compaction by using the relocation table and
          the markbits vector and interpolating.</p>
<p>	      The relocation table entry for the pagelet nearest the
	      object is found. If the pagelet's address is less than the
	      object's address, the number of set markbits that precede
	      the object on the pagelet is used to determine the object's
	      address; otherwise, the number of set markbits that follow
	      the object on the pagelet is used.</p>
<p>          Since forwarding views the heap as a set of doublewords,
          locatives are (mostly) treated like any other pointers. (The
          basic difference is that locatives may appear to be tagged as
          fixnums, in which case they're treated as word-aligned
          pointers into the object.)</p>
<p>          If the forward phase changes the address of any hash
          table key in a hash table that hashes by address (e.g., an EQ
          hash table), it sets a bit in the hash table's header. The
          hash table code will rehash the hash table's contents if it
          tries to do a lookup on a key in such a table.</p>
<p>          Profiling reveals that about half of the total time
          spent in the GC is spent in the subroutine which determines a
          pointer's forwarding address. Exploiting GCC-specific idioms,
          hand-coding the routine, and inlining calls to it could all be
          expected to improve GC performance.</p>
</div>
<a id="compact-phase"></a>
<H4>Compact phase</H4>
<div class="section">
<p>The compact phase compacts the area between the first
          unmarked object and the freepointer so that it contains only
          marked objects.  While doing so, it forwards any pointers it
          finds in the objects it copies.</p>
<p>          When the compact phase is finished, so is the GC (more
          or less): the free pointer and some other data structures are
          updated and control returns to the exception handler that
          invoked the GC. If sufficient memory has been freed to satisfy
          any allocation request that may have triggered the GC, the
          exception handler returns; otherwise, a "seriously low on
          memory" condition is signaled, possibly after releasing a
          small emergency pool of memory.</p>
</div>
</div>
<a id="the-ephemeral-gc"></a>
<H3>The ephemeral GC</H3>
<div class="section">
<p>In the Clozure CL memory management scheme, the relative age
        of two objects in the dynamic heap can be determined by their
        addresses: if addresses X and Y are both addresses in the
        dynamic heap, X is younger than Y (X was created more recently
        than Y) if it is nearer to the free pointer (and farther from
        the base of the heap) than Y.</p>
<p>        Ephemeral (or generational) garbage collectors attempt to
        exploit the following assumptions:</p>
<ul><li><p>most newly created objects become garbage soon after
	        they'recreated.</p>
<li><p>most objects that have already survived several GCs
	        are unlikely to ever become garbage.</p>
<li><p>old objects can only point to newer objects as the
	        result of a destructive modification (e.g., via
	        SETF.)</p>
</ul>
<p>By concentrating its efforts on (frequently and quickly)
        reclaiming newly created garbage, an ephemeral collector hopes
        to postpone the more costly full GC as long as possible. It's
        important to note that most programs create some long-lived
        garbage, so an EGC can't typically eliminate the need for full
        GC.</p>
<p>        An EGC views each object in the heap as belonging to
        exactly one <EMPH>generation</EMPH>; generations are
        sets of objects that are related to each other by age: some
        generation is the youngest, some the oldest, and there's an age
        relationship between any intervening generations. Objects are
        typically assigned to the youngest generation when first
        allocated; any object that has survived some number of GCs in
        its current generation is promoted (or
        <EMPH>tenured</EMPH>) into an older generation.</p>
<p>        When a generation is GCed, the roots consist of the
        stacks, registers, and global variables as always and also of
        any pointers to objects in that generation from other
        generations. To avoid the need to scan those (often large) other
        generations looking for such intergenerational references, the
        runtime system must note all such intergenerational references
        at the point where they're created (via Setf). (This is
            sometimes called "The Write Barrier": all assignments which
            might result in intergenerational references must be noted, as
            if the other generations were write-protected). The
        set of pointers that may contain intergenerational references is
        sometimes called <EMPH>the remembered set</EMPH>.</p>
<p>        In Clozure CL's EGC, the heap is organized exactly the same
        as otherwise; "generations" are merely structures which contain
        pointers to regions of the heap (which is already ordered by
        age.) When a generation needs to be GCed, any younger generation
        is incorporated into it; all objects which survive a GC of a
        given generation are promoted into the next older
        generation. The only intergenerational references that can exist
        are therefore those where an old object is modified to contain a
        pointer to a new object.</p>
<p>        The EGC uses exactly the same code as the full GC. When a
        given GC is "ephemeral",</p>
<ul><li><p>the "base of the heap" used to determine an object's
	        markbit address is the base of the generation
	        being collected;</p>
<li><p>the markbits vector is actually a pointer into the
	        middle of the global markbits table; preceding entries in
	        this table are used to note doubleword addresses in older
	        generations that (may) contain intergenerational
	        references;</p>
<li><p>some steps (notably GCTWA and the handling of weak
	        objects) are not performed;</p>
<li><p>the intergenerational references table is used to
	        find additional roots for the mark and forward phases. If a
	        bit is set in the intergenerational references table, that
	        means that the corresponding doubleword (in some "old"
	        generation, in some "earlier" part of the heap) may have had
	        a pointer to an object in a younger generation stored into
	        it.</p>
</ul>
<p>With one exception (the implicit setfs that occur on entry
        to and exit from the binding of a special variable), all setfs
        that might introduce an intergenerational reference must be
        memoized.
        Note that the implicit setfs that occur when
        initializing an object - as in the case of a call to cons or
        vector - can't introduce intergenerational references, since
        the newly created object is always younger than the objects
        used to initialize it. It's always safe to
        push any cons cell or gvector locative onto the memo stack;
        it's never safe to push anything else.</p>
<p>        Typically, the intergenerational references bitvector is
        sparse: a relatively small number of old locations are stored
        into, although some of them may have been stored into many
        times. The routine that scans the memoization buffer does a lot
        of work and usually does it fairly often; it uses a simple,
        brute-force method but might run faster if it was smarter about
        recognizing addresses that it'd already seen.</p>
<p>        When the EGC mark and forward phases scan the
        intergenerational reference bits, they can clear any bits that
        denote doublewords that definitely do not contain
        intergenerational references.
      </p>
</div>
<a id="fasl-files"></a>
<H3>Fasl files</H3>
<div class="section">
<p>Saving and loading of Fasl files is implemented in
        xdump/faslenv.lisp, level-0/nfasload.lisp, and lib/nfcomp.lisp.
        The information here is only an overview, which might help when
        reading the source.</p>
<p>        The Clozure CL Fasl format is forked from the old MCL Fasl
        format; there are a few differences, but they are minor.  The
        name "nfasload" comes from the fact that this is the so-called
        "new" Fasl system, which was true in 1986 or so.  </p>
<p>        A Fasl file begins with a "file header", which contains
        version information and a count of the following "blocks".
        There's typically only one "block" per Fasl file.  The blocks
        are part of a mechanism for combining multiple logical files
        into a single physical file, in order to simplify the
        distribution of precompiled programs. </p>
<p>        Each block begins with a header for itself, which just
        describes the size of the data that follows.</p>
<p>        The data in each block is treated as a simple stream of
        bytes, which define a bytecode program.  The actual bytecodes,
        "fasl operators", are defined in xdump/faslenv.lisp.  The
        descriptions in the source file are terse, but, according to
        Gary, "probably accurate".</p>
<p>        Some of the operators are used to create a per-block
        "object table", which is a vector used to keep track of
        previously-loaded objects and simplify references to them.  When
        the table is created, an index associated with it is set to
        zero; this is analogous to an array fill-pointer, and allows the
        table to be treated like a stack.</p>
<p>        The low seven bits of each bytecode are used to specify
        the fasl operator; currently, about fifty operators are defined.
        The high byte, when set, indicates that the result of the
        operation should be pushed onto the object table.</p>
<p>        Most bytecodes are followed by operands; the operand data
        is byte-aligned.  How many operands there are, and their type,
        depend on the bytecode.  Operands can be indices into the object
        table, immediate values, or some combination of these.</p>
<p>        An exception is the bytecode #xFF, which has the symbolic
        name ccl::$faslend; it is used to mark the end of the
        block.</p>
</div>
<a id="the-objective-c-bridge_in_implementation-details-of-clozure-cl"></a>
<H3>The Objective-C Bridge</H3>
<div class="section">
<a id="how-clozure-cl-recognizes-objective-c-objects"></a>
<H4>How Clozure CL Recognizes Objective-C Objects</H4>
<div class="section">
<p>In most cases, pointers to instances of Objective-C
          classes are recognized as such; the recognition is (and
          probably always will be) slightly heuristic. Basically, any
          pointer that passes basic sanity checks and whose first word
          is a pointer to a known ObjC class is considered to be an
          instance of that class; the Objective-C runtime system would
          reach the same conclusion.</p>
<p>          It's certainly possible that a random pointer to an
          arbitrary memory address could look enough like an ObjC
          instance to fool the lisp runtime system, and it's possible
          that pointers could have their contents change so that
          something that had either been a true ObjC instance (or had
          looked a lot like one) is changed (possibly by virtue of
          having been deallocated.)</p>
<p>          In the first case, we can improve the heuristics
          substantially: we can make stronger assertions that a
          particular pointer is really "of type :ID" when it's a
          parameter to a function declared to take such a pointer as an
          argument or a similarly declared function result; we can be
          more confident of something we obtained via SLOT-VALUE of a
          slot defined to be of type :ID than if we just dug a pointer
          out of memory somewhere.</p>
<p>          The second case is a little more subtle: ObjC memory
          management is based on a reference-counting scheme, and it's
          possible for an object to ... cease to be an object while lisp
          is still referencing it.  If we don't want to deal with this
          possibility (and we don't), we'll basically have to ensure
          that the object is not deallocated while lisp is still
          thinking of it as a first-class object. There's some support
          for this in the case of objects created with MAKE-INSTANCE,
          but we may need to give similar treatment to foreign objects
          that are introduced to the lisp runtime in other ways (as
          function arguments, return values, SLOT-VALUE results, etc. as
          well as those instances that are created under lisp
          control.)</p>
<p>          This doesn't all work yet (in fact, not much of it works
          yet); in practice, this has not yet been as much of a problem
          as anticipated, but that may be because existing Cocoa code
          deals primarily with relatively long-lived objects such as
          windows, views, menus, etc.</p>
</div>
<a id="recommended-reading_in_the-objective-c-bridge"></a>
<H4>Recommended Reading</H4>
<div class="section">
<dl><dt><a href="http://developer.apple.com/documentation/Cocoa/">Cocoa Documentation</a>
</dt>
<dd><p>
	            This is the top page for all of Apple's documentation on
	            Cocoa.  If you are unfamiliar with Cocoa, it is a good
	            place to start.
	          </p>
</dd>
<dt><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html">Foundation Reference for Objective-C</a>
</dt>
<dd><p>
	            This is one of the two most important Cocoa references; it
	            covers all of the basics, except for GUI programming.  This is
	            a reference, not a tutorial.
	          </p>
</dd>
</dl>
</div>
</div>
</div>
<a id="modifying-clozure-cl"></a>
<H2>Modifying Clozure CL</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#contributing-code-back-to-the-clozure-cl-project">
Contributing Code Back to the Clozure CL Project</a>
<ul style="list-style: none">
</ul>
<li><a href="#using-clozure-cl-in-development-and-in-user-mode">
Using Clozure CL in "development" and in  "user" mode</a>
<ul style="list-style: none">
</ul>
<li><a href="#the-kernel-debugger">
The Kernel Debugger</a>
<ul style="list-style: none">
</ul>
<li><a href="#using-altivec-in-clozure-cl-lap-functions">
Using AltiVec in Clozure CL LAP functions</a>
<ul style="list-style: none">
<li><a href="#overview_in_using-altivec-in-clozure-cl-lap-functions">
Overview</a>
<li><a href="#register-usage-conventions">
Register usage conventions</a>
</ul>
<li><a href="#development-mode-dictionary">
Development-Mode Dictionary</a>
<ul style="list-style: none">
</ul>
</ul>
<a id="contributing-code-back-to-the-clozure-cl-project"></a>
<H3>Contributing Code Back to the Clozure CL Project</H3>
<div class="section">
<p>This section is a placeholder, added as of August 2004.  The
      full text is being written, and will be added as soon as it is
      available.</p>
</div>
<a id="using-clozure-cl-in-development-and-in-user-mode"></a>
<H3>Using Clozure CL in "development" and in  "user" mode</H3>
<div class="section">
<p>As it's distributed, Clozure CL starts up with *PACKAGE* set to
      the CL-USER package and with most predefined functions and
      methods protected against accidental redefinition.  The package
      setting is of course a requirement of ANSI CL, and the
      protection of predefined functions and methods is intended to
      catch certain types of programming errors (accidentally
      redefining a CL or CCL function) before those errors have a
      chance to do much damage.</p>
<p>      These settings may make using Clozure CL to develop Clozure CL a bit
      awkward, because much of that process assumes you are working in
      the CCL package is current, and a primary purpose of Clozure CL
      development is to redefine some predefined, builtin functions.
      The standard, "routine" ways of building Clozure CL from sources (see
      ) - COMPILE-CCL, XCOMPILE-CCL, and XLOAD-LEVEL-0 - bind
      *PACKAGE* to the "CCL" package and enable the redefinition of
      predefined functions; the symbols COMPILE-CCL, XCOMPILE-CCL, and
      XLOAD-LEVEL-0 are additionally now exported from the "CCL"
      package.</p>
<p>      Some other (more ad-hoc) ways of doing development on
      Clozure CL-compiling and/or loading individual files,
      incrementally redefining individual functions-may be
      awkward unless one reverts to the mode of operation which was
      traditionally offered in Clozure CL. Some Clozure CL source files -
      especially those that comprise the bootstrapping image sources
      and the first few files in the "cold load" sequence - are
      compiled and loaded in the "CCL" package but don't contain
      (IN-PACKAGE "CCL") forms, since IN-PACKAGE doesn't work until
      later in the cold load sequence.</p>
<p>      The somewhat bizarre behavior of both SET-USER-ENVIRONMENT
      and SET-DEVELOPMENT-ENVIRONMENT with respect to the special
      variables they affect is intended to allow those constructs to
      take effect when the read-eval-print loop next returns to a
      top-level '? ' prompt; the constructs can meaningfully be used
      inside LOAD, for instance (recall that LOAD binds *PACKAGE*),
      though using both constructs within the same LOAD call would
      likely be pretty confusing.</p>
<p>      "user" and "development" are otherwise very generic terms;
      here they're intended to enforce the distinction between "using"
      Clozure CL and "developing" it.</p>
<p>      The initial environment from which Clozure CL images are
      saved is one where (SET-USER-ENVIRONMENT T) has just been
      called; in previous versions, it was effectively as if
      (SET-DEVELOPMENT-ENVIRONMENT T) had just been called.</p>
<p>      Hopefully, most users of Clozure CL can safely ignore these
      issues most of the time. Note that doing (SET-USER-ENVIRONMENT
      T) after loading one's own code (or 3rd-party code) into Clozure CL
      would protect that code (as well as Clozure CL's) from accidental
      redefinition; that may be useful in some cases.</p>
</div>
<a id="the-kernel-debugger"></a>
<H3>The Kernel Debugger</H3>
<div class="section">
<p> In a perfect world, something like this couldn't
      happen:</p>
<pre class="source-code"><p>
Welcome to Clozure CL Version x.y!
? (defun foo (x)
    (declare (cons x))
    (cdr x))
FOO</p>
<p>? (foo -1) ;Oops. Too late ...
Unhandled exception 11 at 0x300e90c8, context-&gt;regs at #x7ffff6b8
Continue/Debugger/eXit &lt;enter&gt;?
    </p>
</pre>
<p>As you may have noticed, it's not a perfect world; it's rare
      that the cause (attempting to reference the CDR of -1, and therefore
      accessing unmapped memory near location 0) of this effect (an
      "Unhandled exception ..." message) is so obvious.</p>
<p>      The addresses printed in the message above aren't very useful
      unless you're debugging the kernel with GDB (and they're often
      very useful if you are.)</p>
<p>      Aside from causing an exception that the lisp kernel doesn't
      know how to handle, one can also enter the kernel debugger (more)
      deliberately:</p>
<pre class="source-code"><p>
? (defun classify (n)
    (cond ((&gt; n 0) "Greater")
          ((&lt; n 0) "Less")
          (t
           ;; Sheesh ! What else could it be ?
           (ccl::bug "I give up. How could this happen ?"))))
CLASSIFY</p>
<p>? (classify 0)
Bug in Clozure CL system code:
I give up. How could this happen ?
? for help
[12345] Clozure CL kernel debugger:
    </p>
</pre>
<p>CCL::BUG isn't quite the right tool for this example (a
      call to BREAK or PRINT might do a better job of clearing up the
      mystery), but it's sometimes helpful when those other tools
      can't be used.  The lisp error system notices, for instance, if
      attempts to signal errors themselves cause errors to be
      signaled; this sort of thing can happen if CLOS or the I/O
      system are broken or missing. After some small number of
      recursive errors, the error system gives up and calls
      CCL::BUG.</p>
<p>      If one enters a '?' at the kernel debugger prompt, one
      will see output like:</p>
<pre class="source-code">
(S)  Find and describe symbol matching specified name
(B)  Show backtrace
(X)  Exit from this debugger, asserting that any exception was handled
(K)  Kill Clozure CL process
(?)  Show this help
    
</pre>
<p>CCL::BUG just does an FF-CALL into the lisp kernel.  If
      the kernel debugger was invoked because of an unhandled
      exception (such as an illegal memory reference) the OS kernel
      saves the machine state ("context") in a data structure for us,
      and in that case some additional options can be used to display
      the contents of the registers at the point of the
      exception. Another function-CCL::DBG-causes a special
      exception to be generated and enters the lisp kernel debugger
      with a non-null "context":</p>
<pre class="source-code"><p>
? (defun classify2 (n)
    (cond ((&gt; n 0) "Greater")
          ((&lt; n 0) "Less")
          (t (dbg n))))
CLASSIFY2</p>
<p>? (classify2 0)
Lisp Breakpoint
While executing: #&lt;Function CLASSIFY2 #x08476cfe&gt;
? for help
[12345] Clozure CL kernel debugger: ?
(G)  Set specified GPR to new value
(A)  Advance the program counter by one instruction (use with caution!)
(D)  Describe the current exception in greater detail
(R)  Show raw GPR/SPR register values
(L)  Show Lisp values of tagged registers
(F)  Show FPU registers
(S)  Find and describe symbol matching specified name
(B)  Show backtrace
(X)  Exit from this debugger, asserting that any exception was handled
(P)  Propagate the exception to another handler (debugger or OS)
(K)  Kill Clozure CL process
(?)  Show this help
    </p>
</pre>
<p>CCL::DBG takes an argument, whose value is copied into the register
      that Clozure CL uses to return a function's primary value (arg_z, which
      is r23 on the PowerPC). If we were to choose the (L) option at this point,
      we'd see a dislay like:</p>
<pre class="source-code">
rnil = 0x01836015
nargs = 0
r16 (fn) = #&lt;Function CLASSIFY2 #x30379386&gt;
r23 (arg_z) = 0
r22 (arg_y) = 0
r21 (arg_x) = 0
r20 (temp0) = #&lt;26-element vector subtag = 2F @#x303793ee&gt;
r19 (temp1/next_method_context) = 6393788
r18 (temp2/nfn) = #&lt;Function CLASSIFY2 #x30379386&gt;
r17 (temp3/fname) = CLASSIFY2
r31 (save0) = 0
r30 (save1) = *TERMINAL-IO*
r29 (save2) = 0
r28 (save3) = (#&lt;RESTART @#x01867f2e&gt; #&lt;RESTART @#x01867f56&gt;)
r27 (save4) = ()
r26 (save5) = ()
r25 (save6) = ()
r24 (save7) = ()
    
</pre>
<p>From this we can conclude that the problematic argument to CLASSIFY2
      was 0 (see r23/arg_z), and that I need to work on a better example.</p>
<p>      The R option shows the values of the ALU (and PPC branch unit)
      registers in hex; the F option shows the values of the FPU registers.</p>
<p>      The (B) option shows a raw stack backtrace; it'll try to
      identify foreign functions as well as lisp functions. (Foreign function
      names are guesses based on the nearest preceding exported symbol.)</p>
<p>      If you ever unexpectedly find yourself in the "lisp kernel
      debugger", the output of the (L) and (B) options are often the most
      helpful things to include in a bug report.</p>
</div>
<a id="using-altivec-in-clozure-cl-lap-functions"></a>
<H3>Using AltiVec in Clozure CL LAP functions</H3>
<div class="section">
<a id="overview_in_using-altivec-in-clozure-cl-lap-functions"></a>
<H4>Overview</H4>
<div class="section">
<p>It's now possible to use AltiVec instructions in PPC LAP
        (assembler) functions.</p>
<p>        The lisp kernel detects the presence or absence of
        AltiVec and preserves AltiVec state on lisp thread switch and
        in response to exceptions, but the implementation doesn't
        otherwise use vector operations.</p>
<p>        This document doesn't document PPC LAP programming in
        general.  Ideally, there would be some document that
        did.</p>
<p>        This document does explain AltiVec register-usage
        conventions in Clozure CL and explains the use of some lap macros
        that help to enforce those conventions.</p>
<p>        All of the global symbols described below are exported
        from the CCL package. Note that lap macro names, ppc
        instruction names, and (in most cases) register names are
        treated as strings, so this only applies to functions and
        global variable names.</p>
<p>        Much of the Clozure CL support for AltiVec LAP programming
        is based on work contributed to MCL by Shannon Spires.</p>
</div>
<a id="register-usage-conventions"></a>
<H4>Register usage conventions</H4>
<div class="section">
<p>Clozure CL LAP functions that use AltiVec instructions must
        interoperate with each other and with C functions; that fact
        suggests that they follow C AltiVec register usage
        conventions. (vr0-vr1 scratch, vr2-vr13 parameters/return
        value, vr14-vr19 temporaries, vr20-vr31 callee-save
        non-volatile registers.)</p>
<p>        The EABI (Embedded Application Binary Interface) used in
        LinuxPPC doesn't ascribe particular significance to the vrsave
        special-purpose register; on other platforms (notably MacOS),
        it's used as a bitmap which indicates to system-level code
        which vector registers contain meaningful values.</p>
<p>        The WITH-ALTIVEC-REGISTERS lap macro generates code that
        saves, updates, and restores VRSAVE on platforms where this is
        required (as indicated by the value of the special variable
        that controls this behavior) and ignores VRSAVE on platforms
        that don't require it to be maintained.</p>
<p>        On all PPC platforms, it's necessary to save any non-volatile
        vector registers (vr20 .. vr31) before assigning to them and to restore
        such registers before returning to the caller.</p>
<p>        On platforms that require that VRSAVE be maintained, it's
        not necessary to mention the "use" of vector registers that
        are used as incoming parameters. It's not incorrect to mention
        their use in a WITH-ALTIVEC-REGISTERS form, but it may be
        unnecessary in many interesting cases. One can likewise assume
        that the caller of any function that returns a vector value in
        vr2 has already set the appropriate bit in VRSAVE to indicate
        that this register is live. One could therefore write a leaf
        function that added the bytes in vr3 and vr2 and returned the
        result in vr2 as:</p>
<pre class="source-code">
(defppclapfunction vaddubs ((y vr3) (z vr2))
  (vaddubs z y z)
  (blr))
      
</pre>
<p>When vector registers that aren't incoming parameters are used
        in a LAP function, WITH-ALTIVEC-REGISTERS takes care of maintaining VRSAVE
        and of saving/restoring any non-volatile vector registers:</p>
<pre class="source-code">
(defppclapfunction load-array ((n arg_z))
  (check-nargs 1)
  (with-altivec-registers (vr1 vr2 vr3 vr27) ; Clobbers imm0
    (li imm0 arch::misc-data-offset)
    (lvx vr1 arg_z imm0)                ; load MSQ
    (lvsl vr27 arg_z imm0)              ; set the permute vector
    (addi imm0 imm0 16)                 ; address of LSQ
    (lvx vr2 arg_z imm0)                ; load LSQ
    (vperm vr3 vr1 vr2 vr27)           ; aligned result appears in VR3
    (dbg t))                         ; Look at result in some debugger
  (blr))
      
</pre>
<p>AltiVec registers are not preserved by CATCH and UNWIND-PROTECT.
        Since AltiVec is only accessible from LAP in Clozure CL and since LAP
        functions rarely use high-level control structures, this should rarely be
        a problem in practice.</p>
<p>        LAP functions that use non-volatile vector registers and
        that call (Lisp ?) code which may use CATCH or UNWIND-PROTECT
        should save those vector registers before such a call and
        restore them on return. This is one of the intended uses of
        the WITH-VECTOR-BUFFER lap macro.</p>
</div>
</div>
<a id="development-mode-dictionary"></a>
<H3>Development-Mode Dictionary</H3>
<div class="section">
<a id="v_warn-if-redefine-kernel"></a>
<div class=definition>
<code>*warn-if-redefine-kernel*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_warn-if-redefine-kernel"></a>
<p>When true, attempts to redefine (via DEFUN or DEFMETHOD)
	      functions and methods that are marked as being
	      "predefined" signal continuable errors.</p>
<p>	      Note that these are CERRORs, not warnings, and that
	      no lisp functions or methods have been defined in the kernel
	      in MCL or Clozure CL since 1987 or so.</p>
</div>
<a id="f_set-development-environment"></a>
<div class=definition>
<code>set-development-environment</code> <code>&amp;optional</code> <i>unmark-builtin-functions</i> <span class="definition-kind">[Function]</span><a id="description_in_f_set-development-environment"></a>
<p>Arranges that the outermost special bindings of *PACKAGE*
	      and *WARN-IF-REDEFINE-KERNEL* restore values of the "CCL"
	      package and NIL to these variables, respectively. If the optional
	      argument is true, marks all globally defined functions and methods
	      as being "not predefined" (this is a fairly expensive
	      operation.)</p>
</div>
<a id="f_set-user-environment"></a>
<div class=definition>
<code>set-user-environment</code> <code>&amp;optional</code> <i>mark-builtin-functions</i> <span class="definition-kind">[Function]</span><a id="description_in_f_set-user-environment"></a>
<p>Arranges that the outermost special bindings of *PACKAGE*
	      and *WARN-IF-REDEFINE-KERNEL* restore values of the
	      "CL-USER" package and T to these variables, respectively.
	      If the optional argument is true, marks all globally defined
	      functions and methods as being "predefined" (this is a
	      fairly expensive operation.)</p>
</div>
<a id="v_altivec-available"></a>
<div class=definition>
<code>*altivec-available*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_altivec-available"></a>
<p>This variable is initialized each time an Clozure CL session
	      starts based on information provided by the lisp kernel. Its value
	      is true if AltiVec is present and false otherwise. This variable
	      shouldn't be set by user code.</p>
</div>
<a id="f_altivec-available-p"></a>
<div class=definition>
<code>altivec-available-p</code> <span class="definition-kind">[Function]</span><a id="description_in_f_altivec-available-p"></a>
<p>Returns non-NIL if AltiVec is available.</p>
</div>
<a id="v_altivec-lapmacros-maintain-vrsave-p"></a>
<div class=definition>
<code>*altivec-lapmacros-maintain-vrsave-p*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_altivec-lapmacros-maintain-vrsave-p"></a>
<p>Intended to control the expansion of certain lap macros.
	      Initialized to NIL on LinuxPPC; initialized to T on platforms
	      (such as MacOS X/Darwin) that require that the VRSAVE SPR contain
	      a bitmask of active vector registers at all times.</p>
</div>
<a id="f_with-altivec-registers"></a>
<div class=definition>
<code>with-altivec-registers</code> <i>reglist</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Lap Macro]</span><p>Specify the test of Altivec registers used in the body.</p>
<a id="arguments-and-values_in_f_with-altivec-registers"></a>
<dl><dt><I>reglist</I></dt>
<dd><p>A list of vector register names (vr0 .. vr31).</p>
</dd>
<dt><I>body</I></dt>
<dd><p>A sequence of PPC LAP instructions.</p>
</dd>
</dl>
<a id="description_in_f_with-altivec-registers"></a>
<p>Specifies the set of AltiVec registers used in body. If
	      *altivec-lapmacros-maintain-vrsave-p* is true when the macro is
	      expanded, generates code to save the VRSAVE SPR and updates VRSAVE
	      to include a bitmask generated from the specified register list.
	      Generates code which saves any non-volatile vector registers which
	      appear in the register list, executes body, and restores the saved
	      non-volatile vector registers (and, if
	      *altivec-lapmacros-maintain-vrsave-p* is true, restores VRSAVE as
	      well. Uses the IMM0 register (r3) as a temporary.</p>
</div>
<a id="f_with-vector-buffer"></a>
<div class=definition>
<code>with-vector-buffer</code> <i>base</i> <i>n</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Lap Macro]</span><p>Make space for saved Altivec registers.</p>
<a id="arguments-and-values_in_f_with-vector-buffer"></a>
<dl><dt><I>base</I></dt>
<dd><p>Any available general-purpose register.</p>
</dd>
<dt><I>n</I></dt>
<dd><p>An integer between 1 and 254, inclusive. (Should
		        typically be much, much closer to 1.) Specifies the size of
		        the buffer, in 16-byte units.</p>
</dd>
<dt><I>body</I></dt>
<dd><p>A sequence of PPC LAP instructions.</p>
</dd>
</dl>
<a id="description_in_f_with-vector-buffer"></a>
<p>Generates code which allocates a 16-byte aligned buffer
	      large enough to contain N vector registers; the GPR base points to
	      the lowest address of this buffer. After processing body, the
	      buffer will be deallocated. The body should preserve the value of
	      base as long as it needs to reference the buffer. It's
	      intended that base be used as a base register in stvx and lvx
	      instructions within the body.</p>
</div>
</div>
</div>
<a id="profiling"></a>
<H2>Profiling</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#using-the-linux-oprofile-system-level-profiler">
Using the Linux oprofile system-level profiler</a>
<ul style="list-style: none">
<li><a href="#generating-a-lisp-image-for-use-with-oprofile">
Generating a lisp image for use with oprofile</a>
<li><a href="#prerequisites_in_using-the-linux-oprofile-system-level-profiler">
Prerequisites</a>
<li><a href="#generating-elf-symbols-for-lisp-functions">
Generating ELF symbols for Lisp functions</a>
<li><a href="#example_in_using-the-linux-oprofile-system-level-profiler">
Example</a>
<li><a href="#issues">
Issues</a>
</ul>
<li><a href="#using-apple-s-chud-metering-tools">
Using Apple's CHUD metering tools</a>
<ul style="list-style: none">
<li><a href="#prerequisites_in_using-apple-s-chud-metering-tools">
Prerequisites</a>
<li><a href="#generating-a-lisp-image-for-use-with-shark">
Generating a lisp image for use with Shark</a>
<li><a href="#usage-synopsis">
Usage synopsis</a>
<li><a href="#profiling-configurations">
Profiling "configurations"</a>
<li><a href="#reference">
Reference</a>
<li><a href="#acknowledgement_in_using-apple-s-chud-metering-tools">
Acknowledgement</a>
</ul>
</ul>
<a id="using-the-linux-oprofile-system-level-profiler"></a>
<H3>Using the Linux oprofile system-level profiler</H3>
<div class="section">
<p><a href="http://oprofile.sourceforge.net"><CODE>oprofile</CODE></a>
 is a
    system-level profiler that's available for most modern Linux
    distributions.</p>
<p>    Use of oprofile and its companion programs isn't really documented
    here; what is described is a way of generating symbolic information that
    enables profiling summaries generated by the <CODE>opreport</CODE> program
    to identify lisp functions meaningfully.</p>
<a id="generating-a-lisp-image-for-use-with-oprofile"></a>
<H4>Generating a lisp image for use with oprofile</H4>
<div class="section">
<p>Modern Linux uses the 'ELF" (Executable and Linking Format) object
      file format; the oprofile tools can associate symbolic names with
      addresses in a memory-mapped file if that file appears to be an ELF
      object file and if it contains ELF symbol information that describes
      those memory regions. So, the general idea is to make a lisp heap image
      that looks enough like an ELF shared library to fool the
      <CODE>oprofile</CODE> tools (we don't actually load heap images via ELF
      dynamic linking technology, but we can make it look like we did.)</p>
</div>
<a id="prerequisites_in_using-the-linux-oprofile-system-level-profiler"></a>
<H4>Prerequisites</H4>
<div class="section">
<ul><li><p><CODE>oprofile</CODE> itself, which is almost certainly
          available via your distribution's package management system if not
          already preinstalled.</p>
<li><p><CODE>libelf</CODE>, which provides utilities for reading and
          writing ELF files (and is likewise likely preinstalled or readily
          installable.) Somewhat confusingly, there are two libelf
          implementations in widespread use on Linux, and different
          distributions refer to them by different names (they may be
          available as part of an 'elfutils' package.) The oprofile insterface
          was designed to work with a libelf implementation whose version
          number is currently around 147; the other (incompatible) libelf
          implementation has a version number around 0.8. It may be necessary
          to install the corresponding development package (-dev or -devel,
          usuallly) in order to actually be able to use the libelf shared
          library.</p>
</ul>
</div>
<a id="generating-elf-symbols-for-lisp-functions"></a>
<H4>Generating ELF symbols for Lisp functions</H4>
<div class="section">
<p>In order to create a lisp heap image which can be used for
      <CODE>oprofile</CODE>- based profiling, we need to:</p>
<ol><li><p>load any code that we want to profile</p>
<li><p>generate a file that contains ELF symbol information
          describing the names and addresses of all lisp functions.</p>
<p>This step involves doing (from within Clozure CL)</p>
<pre class="source-code"><p>
? (require "ELF")
"ELF"
("ELF")</p>
<p>? (ccl::write-elf-symbols-to-file "home:elf-symbols")
	    </p>
</pre>
<p>The argument to CCL::WRITE-ELF-SYMBOLS-TO-FILE can be any
          writable pathname. The function will do whatever's necessary to nail
          lisp functions down in memory (so that they aren't moved by GC),
          then write an ELF object file to the indicated pathname. This
          typically takes a few seconds.</p>
<li><p>Generate a lisp heap image in which the ELF symbols generated
          in the previous step are prepended.</p>
<p>          The function CCL:SAVE-APPLICATION provides a :PREPEND-KERNEL
          argument, which is ordinarily used to save a standalone application
          in which the kernel and heap image occupy a single file.
          :PREPEND-KERNEL doesn't really care what it's prepending to the
          image, and we can just as easily ask it to prepend the ELF symbol
          file generated in the previous step.</p>
<pre class="source-code">
? (save-application "somewhere/image-for-profiling"
    :prepend-kernel "home:elf-symbols")
	    
</pre>
<p>If you then run</p>
<pre class="source-code">
shell&gt; ccl64 somewhare/image-for-profiling
	    
</pre>
<p>any lisp code sampled by oprofile in that image will be
          identified "symbolically" by <CODE>opreport</CODE>.</p>
</ol>
</div>
<a id="example_in_using-the-linux-oprofile-system-level-profiler"></a>
<H4>Example</H4>
<div class="section">
<pre class="source-code"><p>
;;; Define some lisp functions that we want to profile and save
;;; a profiling-enabled image.  In this case, we just want to 
;;; define the FACTORIAL funcion, to keep things simple.
? (defun fact (n) (if (zerop n) 1 (* n (fact (1- n)))))
FACT
? (require "ELF")
"ELF"
("ELF")
? (ccl::write-elf-symbols-to-file "home:elf-symbols")
"home:elf-symbols"
? (save-application "home:profiled-ccl" :prepend-kernel "home:elf-symbols")</p>
<p>;;; Setup oprofile with (mostly) default arguments.  This example was
;;; run on a Fedora 8 system where an uncompressed 'vmlinux' kernel
;;; image isn't readily available.</p>
<p>;;; Note that use of 'opcontrol' generally requires root access, e.g.,
;;; 'sudo' or equivalent:</p>
<p>[~] gb@rinpoche&gt; sudo opcontrol --no-vmlinux --setup</p>
<p>;;; Start the profiler</p>
<p>[~] gb@rinpoche&gt; sudo opcontrol --start
Using 2.6+ OProfile kernel interface.
Using log file /var/lib/oprofile/samples/oprofiled.log
Daemon started.
Profiler running.</p>
<p>;;; Start CCL with the "profiled-ccl" image created above.
;;; Invoke "(FACT 10000)"</p>
<p>[~] gb@rinpoche&gt; ccl64 profiled-ccl 
Welcome to Clozure Common Lisp Version 1.2-r9198M-trunk  (LinuxX8664)!
? (null (fact 10000))
NIL
? (quit)</p>
<p>;;; We could stop the profiler (opcontrol --stop) here; instead,
;;; we simply flush profiling data to disk, where 'opreport' can
;;; find it.
</p>
<p>
[~] gb@rinpoche&gt; sudo opcontrol --dump</p>
<p>;;; Ask opreport to show us where we were spending time in the
;;; 'profiled-ccl' image.</p>
<p>[~] gb@rinpoche&gt; opreport -l profiled-ccl | head
CPU: Core 2, speed 1596 MHz (estimated)
Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (Unhalted core cycles) count 100000
samples  %        symbol name
6417     65.2466  &lt;Compiled-function.(:INTERNAL.MULTIPLY-UNSIGNED-BIGNUM-AND-1-DIGIT-FIXNUM.MULTIPLY-BIGNUM-AND-FIXNUM).(Non-Global)..0x30004002453F&gt;
3211     32.6487  &lt;Compiled-function.%MULTIPLY-AND-ADD4.0x300040000AAF&gt;
17        0.1729  &lt;Compiled-function.%%ONE-ARG-DCODE.0x3000401740AF&gt;
11        0.1118  &lt;Compiled-function.%UNLOCK-RECURSIVE-LOCK-OBJECT.0x30004007F7DF&gt;
10        0.1017  &lt;Compiled-function.AUTO-FLUSH-INTERACTIVE-STREAMS.0x3000404ED6AF&gt;
7         0.0712  &lt;Compiled-function.%NANOSLEEP.0x30004040385F&gt;
7         0.0712  &lt;Compiled-function.%ZERO-TRAILING-SIGN-DIGITS.0x300040030F3F&gt;
	</p>
</pre>
</div>
<a id="issues"></a>
<H4>Issues</H4>
<div class="section">
<p>CCL::WRITE-ELF-SYMBOLS-TO-FILE currently only works on x86-64; it
      certainly -could- be made to work on ppc32/ppc64 as well.</p>
<p>      So far, no one has been able to make oprofile/opreport options
      that're supposed to generate call-stack info generate meaningful
      call-stack info.</p>
<p>      As of a few months ago, there was an attempt to provide symbol
      info for oprofile/opreport "on the fly", e.g., for use in JIT
      compilation or other incremental compilation scenarios. That's obviously
      more nearly The Right Thing, but it might be awhile before that
      experimental code makes it into widespread use.</p>
</div>
</div>
<a id="using-apple-s-chud-metering-tools"></a>
<H3>Using Apple's CHUD metering tools</H3>
<div class="section">
<p>Apple's CHUD package provides libraries, kernel extensions, and a
    set of graphical and command-line programs that can be used to measure
    many aspects of application and system performance.</p>
<p>    One of these programs is the Shark application (often installed in
    "/Developer/Applications/Performance Tools/Shark.app"), which provides a
    graphical user interface for exploring and analyzing profiling results and
    provides tools for creating "sampling configurations" (see below), among
    other things. Use of Shark isn't really documented here (a Shark manual is
    available at "Developer/Documentation/CHUD/Shark/ SharkUserGuide.pdf");
    what is described is a way of providing information about Lisp function
    names and addresses so that Shark can meaningly identify those functions
    in its output.</p>
<a id="prerequisites_in_using-apple-s-chud-metering-tools"></a>
<H4>Prerequisites</H4>
<div class="section">
<p>Apple's CHUD tools have been distributed with the last several
      XCode releases. One way to determine whether or not the tools are
      installed is to run:</p>
<pre class="source-code">$ /usr/bin/shark -v
</pre>
<p>in a terminal or Emacs shell buffer. If that returns output
      like</p>
<pre class="source-code">shark 4.7.3 (365)
</pre>
<p>then the CHUD package is installed. Output like</p>
<pre class="source-code">shark: Command not found.
</pre>
<p>strongly suggests that it isn't ...</p>
</div>
<a id="generating-a-lisp-image-for-use-with-shark"></a>
<H4>Generating a lisp image for use with Shark</H4>
<div class="section">
<p>Shark can only properly identify functions that're defined in a
      shared library that's loaded by the target application. (Any other
      functions will be identified by a hex address described as being in an
      "Unknown Library"; the hex address is generally somewhat near the actual
      function, but it's determined heuristically and isn't always
      accurate.)</p>
<p>      For those reasons, it's desirable to load the code that you wish
      to profile in one lisp session, save a native (Mach-O library) image,
      and invoke Shark in a new session which uses that native image. (It may
      also be useful to load the CHUD-METERING module, which defines
      CHUD:METER and friends.</p>
<p></p>
</div>
<a id="usage-synopsis"></a>
<H4>Usage synopsis</H4>
<div class="section">
<pre class="source-code">[src/ccl-dev] gb@antinomial&gt; ccl64
Welcome to Clozure Common Lisp Version 1.7-dev-r14624M-trunk  (DarwinX8664)!
? (defun fact(n) (if (zerop n) 1 (* n (fact (1- n)))))
FACT
? (require "CHUD-METERING")
"CHUD-METERING"
("CHUD-METERING")
? (save-application "ccl:dx86cl64.dylib" :native t)
[src/ccl-dev] gb@antinomial&gt; ccl64 -I dx86cl64.dylib
Welcome to Clozure Common Lisp Version 1.7-dev-r14624M-trunk  (DarwinX8664)!
? (chud:meter (dotimes (i 1000) (fact 1000)))
;;; Waiting for shark to process samples ...done.
NIL
</pre>
<p>and, a few seconds after the result is returned, a file whose name
      is of the form "session_nnn.mshark" will open in Shark.app.</p>
<p></p>
<p>The fist time that CHUD:METER is used in a lisp session, it'll do
      a few things to prepare subsequent profiling sessions. Those things
      include:</p>
<ul><li><p>creating a directory to store files that are related to using
          the CHUD tools in this lisp session. This directory is created in
          the user's home directory and has a name of the form:</p>
<pre class="source-code">
profiling-session-&lt;lisp-kernel&gt;-&lt;pid&gt;_&lt;mm&gt;-&lt;dd&gt;-&lt;yyyy&gt;_&lt;h&gt;.&lt;m&gt;.&lt;s&gt;
	      
</pre>
<li><p>run the shark program ("/usr/bin/shark") and wait until it's
          ready to receive signals that control its operation.</p>
</ul>
<p>This startup activity typically takes a few seconds; after it's
      been completed, subsequent use of CHUD:METER doesn't involve that
      overhead. (See the discussion of :RESET below.)</p>
<p>      After any startup activity is complete, CHUD:METER arranges to
      send a "start profiling" signal to the running shark program, executes
      the form, sends a "stop profiling" signal to the shark program, and
      reads its diagnostic output, looking for the name of the ".mshark" file
      it produces. If it's able to find this filename, it arranges for
      "Shark.app" to open it.</p>
</div>
<a id="profiling-configurations"></a>
<H4>Profiling "configurations"</H4>
<div class="section">
<p>By default, a shark profiling session will:</p>
<ul><li><p>use "time based" sampling, to periodically interrupt the lisp
          process and note the value of the program counter and at least a few
          levels of call history.</p>
<li><p>do this sampling once every millisecond</p>
<li><p>run for up to 30 seconds, unless told to stop earlier.</p>
</ul>
<p>This is known as "the default configuration"; it's possible to use
      items on the "Config" menu in the Shark application to create alternate
      configurations which provide different kinds of profiling parameters and
      to save these configurations in files for subsequent reuse. (The set of
      things that CHUD knows how to monitor is large and interesting.)</p>
<p>      You use alternate profiling configurations (created and "exported"
      via Shark.app) with CHUD:METER, but the interface is a little
      awkward.</p>
</div>
<a id="reference"></a>
<H4>Reference</H4>
<div class="section">
<a id="v_shark-config-file"></a>
<div class=definition>
<code>chud:*shark-config-file*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_shark-config-file"></a>
<p>When non-null, this should be the pathname of an alternate
      profiling configuration file created by the "Config Editor" in
      Shark.app.</p>
</div>
<a id="m_meter"></a>
<div class=definition>
<code>chud:meter</code> <i>form</i> <code>&amp;key</code>  (<i>reset</i> <i>nil</i>)  (<i>debug-output</i> <i>nil</i>) <span class="definition-kind">[Macro]</span><a id="description_in_m_meter"></a>
<p>Executes FORM (an arbitrary lisp form) and returns whatever
      result(s) it returns, with CHUD profiling enabled during the form's
      execution. Tries to determine the name of the session file (*.mshark) to
      which the shark program wrote profiling data and opens this file in the
      Shark application.</p>
<p>Arguments:</p>
<dl><dt><I>debug-output</I></dt>
<dd><p>when non-nil, causes output generated by the shark program
            to be echoed to *TERMINAL-IO*. For debugging.</p>
</dd>
<dt><I>reset</I></dt>
<dd><p>when non-nil, terminates any running instance of the shark
            program created by previous invocations of CHUD:METER in this lisp
            session, generates a new .spatch file (describing the names and
            addresses of lisp functions), and starts a new instance of the
            shark program; if CHUD:*SHARK-CONFIG-FILE* is non-NIL when this
            new instance is started, that instance is told to use the
            specified config file for profiling (in lieu of the default
            profiling configuration.)</p>
</dd>
</dl>
</div>
</div>
<a id="acknowledgement_in_using-apple-s-chud-metering-tools"></a>
<H4>Acknowledgement</H4>
<div class="section">
<p>Both Dan Knapp and Hamilton Link have posted similar CHUD
      interfaces to openmcl-devel in the past; Hamilton's also reported bugs
      in the spatch mechanism to CHUD developers (and gotten those bugs
      fixed.)</p>
</div>
</div>
</div>
<a id="clos-metaobject-protocol"></a>
<H2>CLOS Metaobject Protocol</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#concurrency-issues">
Concurrency issues</a>
<ul style="list-style: none">
</ul>
</ul>
<p>Clozure CL supports most of the semi-standard
  metaobject protocol (MOP) for CLOS, as defined in chapters 5 and 6
  of “The Art Of The Metaobject Protocol”,
  (Kiczales et al, MIT Press 1991, ISBN 0-262-61074-4); this
  specification is also available online at <a href="http://www.alu.org/mop/index.html">http://www.alu.org/mop/index.html</a>
.</p>
<p>  Notably absent is support for the generic function invocation protocol.</p>
<p>  The keyword :openmcl-partial-mop is on <CODE>*features*</CODE> to
  indicate the presence of this functionality.</p>
<p>  All of the symbols defined in the MOP specification
  (whether implemented or not) are exported from the <CODE>ccl</CODE>
  package and from the <CODE>openmcl-mop</CODE> package.</p>
<a id="tab_mop-implementation-status"></a>
<table>
<caption>MOP Implementation Status</caption>
<tr><td>construct
<td>status
</tr>
<tr><td>accessor-method-slot-definition
<td>+
</tr>
<tr><td>add-dependent
<td>+
</tr>
<tr><td>add-direct-method
<td>+
</tr>
<tr><td>add-direct-subclass
<td>+
</tr>
<tr><td>add-method
<td>+
</tr>
<tr><td>class-default-initargs
<td>+
</tr>
<tr><td>class-direct-default-initargs
<td>+
</tr>
<tr><td>class-direct-slots
<td>+
</tr>
<tr><td>class-direct-subclasses
<td>+
</tr>
<tr><td>class-direct-superclasses
<td>+
</tr>
<tr><td>class-finalized-p
<td>+
</tr>
<tr><td>class-prototype
<td>+
</tr>
<tr><td>class-slots
<td>+
</tr>
<tr><td>compute-applicable-methods
<td>-
</tr>
<tr><td>compute-applicable-methods-using-classes
<td>-
</tr>
<tr><td>compute-class-precedence-list
<td>+
</tr>
<tr><td>compute-direct-initargs
<td>+
</tr>
<tr><td>compute-discriminating-function
<td>-
</tr>
<tr><td>compute-effective-method
<td>+
</tr>
<tr><td>compute-effective-slot-definition
<td>+
</tr>
<tr><td>compute-slots
<td>+
</tr>
<tr><td>direct-slot-definition-class
<td>+
</tr>
<tr><td>effective-slot-definition-class
<td>+
</tr>
<tr><td>ensure-class
<td>+
</tr>
<tr><td>ensure-class-using-class
<td>+
</tr>
<tr><td>ensure-generic-function-using-class
<td>+
</tr>
<tr><td>eql-specializer-object
<td>+
</tr>
<tr><td>extract-lambda-list
<td>+
</tr>
<tr><td>extract-specializer-names
<td>+
</tr>
<tr><td>finalize-inheritance
<td>+
</tr>
<tr><td>find-method-combination
<td>+
</tr>
<tr><td>funcallable-standard-instance-access
<td>+
</tr>
<tr><td>generic-function-argument-precedence-order
<td>+
</tr>
<tr><td>generic-function-declarations
<td>+
</tr>
<tr><td>generic-function-lambda-list
<td>+
</tr>
<tr><td>generic-function-method-class
<td>+
</tr>
<tr><td>generic-function-method-combination
<td>+
</tr>
<tr><td>generic-function-methods
<td>+
</tr>
<tr><td>generic-function-name
<td>+
</tr>
<tr><td>intern-eql-specializer
<td>+
</tr>
<tr><td>make-method-lambda
<td>-
</tr>
<tr><td>map-dependents
<td>+
</tr>
<tr><td>method-function
<td>+
</tr>
<tr><td>method-generic-function
<td>+
</tr>
<tr><td>method-lambda-list
<td>+
</tr>
<tr><td>method-qualifiers
<td>+
</tr>
<tr><td>method-specializers
<td>+
</tr>
<tr><td>reader-method-class
<td>+
</tr>
<tr><td>remove-dependent
<td>+
</tr>
<tr><td>remove-direct-method
<td>+
</tr>
<tr><td>remove-direct-subclass
<td>+
</tr>
<tr><td>remove-method
<td>+
</tr>
<tr><td>set-funcallable-instance-function
<td>-
</tr>
<tr><td>slot-boundp-using-class
<td>+
</tr>
<tr><td>slot-definition-allocation
<td>+
</tr>
<tr><td>slot-definition-initargs
<td>+
</tr>
<tr><td>slot-definition-initform
<td>+
</tr>
<tr><td>slot-definition-initfunction
<td>+
</tr>
<tr><td>slot-definition-location
<td>+
</tr>
<tr><td>slot-definition-name
<td>+
</tr>
<tr><td>slot-definition-readers
<td>+
</tr>
<tr><td>slot-definition-type
<td>+
</tr>
<tr><td>slot-definition-writers
<td>+
</tr>
<tr><td>slot-makunbound-using-class
<td>+
</tr>
<tr><td>slot-value-using-class
<td>+
</tr>
<tr><td>specializer-direct-generic-functions
<td>+
</tr>
<tr><td>specializer-direct-methods
<td>+
</tr>
<tr><td>standard-instance-access
<td>+
</tr>
<tr><td>update-dependent
<td>+
</tr>
<tr><td>validate-superclass
<td>+
</tr>
<tr><td>writer-method-class
<td>+
</tr>
</table>
<p>Note that those generic functions whose status is “-” in
      the table above deal with the internals of generic function
      dispatch and method invocation (the “generic function invocation
      protocol”). Method functions are implemented a bit differently
      in Clozure CL from what the MOP expects, and it's not yet clear if
      or how this subprotocol can be well-supported.</p>
<p>      Those constructs that are marked as “+” in the table above
      are nominally implemented as the MOP document specifies
      (deviations from the specification should be considered bugs;
      please report them as such.) Note that some CLOS implementations
      in widespread use (e.g., PCL) implement some things
      (ENSURE-CLASS-USING-CLASS comes to mind) a bit differently from
      what the MOP specifies.</p>
<a id="concurrency-issues"></a>
<H3>Concurrency issues</H3>
<div class="section">
<p>The entire CLOS class and generic function hierarchy is
      effectively a (large, complicated) shared data structure; it's
      not generally practical for a thread to request exclusive access
      to all of CLOS, and the effects of volitional modification of
      the CLOS hierarchy (via class redefinition, <CODE>change-class</CODE>,
      etc.) in a multithreaded environment aren't always tractable.</p>
<p>      Native threads exacerbate this problem (in that they
      increase the opportunities for concurrent modification and
      access.) The implementation should try to ensure that a thread's
      view of any subset of the CLOS hierarchy is consistent (to the
      extent that that's possible) and should try to ensure that
      incidental modifications of the hierarchy (cache updates, etc.)
      happen atomically; it's not generally possible for the
      implementation to guarantee that a thread's view of things is
      correct and current.</p>
<p>      If you are loading code and defining classes in the most
      usual way, which is to say, via the compiler, using only a
      single thread, these issues are probably not going to affect you
      much.</p>
<p>      If, however, you are making finicky changes to the class
      hierarchy while you're running multiple threads which manipulate
      objects related to each other, more care is required.  Before
      doing such a thing, you should know what you're doing and
      already be aware of what precautions to take, without being
      told.  That said, if you do it, you should seriously consider
      what your application's critical data is, and use locks for
      critical code sections.</p>
</div>
</div>
<a id="the-objective-c-bridge"></a>
<H2>The Objective-C Bridge</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#changes-in-1.2">
Changes in 1.2</a>
<ul style="list-style: none">
</ul>
<li><a href="#using-objective-c-classes">
Using Objective-C Classes</a>
<ul style="list-style: none">
</ul>
<li><a href="#instantiating-objective-c-objects">
Instantiating Objective-C Objects</a>
<ul style="list-style: none">
</ul>
<li><a href="#calling-objective-c-methods">
Calling Objective-C Methods</a>
<ul style="list-style: none">
<li><a href="#type-coercion-for-objective-c-method-calls">
Type Coercion for Objective-C Method Calls</a>
<li><a href="#methods-which-return-structures">
Methods which Return Structures</a>
<li><a href="#variable-arity-messages">
Variable-Arity Messages</a>
<li><a href="#optimization">
Optimization</a>
</ul>
<li><a href="#defining-objective-c-classes">
Defining Objective-C Classes</a>
<ul style="list-style: none">
<li><a href="#defining-classes-with-foreign-slots">
Defining classes with foreign slots</a>
<li><a href="#defining-classes-with-lisp-slots">
Defining classes with Lisp slots</a>
</ul>
<li><a href="#defining-objective-c-methods">
Defining Objective-C Methods</a>
<ul style="list-style: none">
<li><a href="#using-define-objc-method">
Using define-objc-method</a>
<li><a href="#using-objc-defmethod">
Using objc:defmethod</a>
<li><a href="#method-redefinition-constraints">
Method Redefinition Constraints</a>
</ul>
<li><a href="#loading-frameworks">
Loading Frameworks</a>
<ul style="list-style: none">
</ul>
<li><a href="#how-objective-c-names-are-mapped-to-lisp-symbols">
How Objective-C Names are Mapped to Lisp Symbols</a>
<ul style="list-style: none">
</ul>
</ul>
<p>Mac OS X APIs use a language called Objective-C, which is
    approximately C with some object-oriented extensions modeled on
    Smalltalk.  The Objective-C bridge makes it possible to work with
    Objective-C objects and classes from Lisp, and to define classes
    in Lisp which can be used by Objective-C.</p>
<p>    The ultimate purpose of the Objective-C and Cocoa bridges is
    to make Cocoa (the standard user-interface framework on Mac OS X)
    as easy as possible to use from Clozure CL, in order to support the
    development of GUI applications and IDEs on Mac OS X (and on any
    platform that supports Objective-C, such as GNUStep).  The
    eventual goal, which is much closer than it used to be, is
    complete integration of Cocoa into CLOS.</p>
<p>    The current release provides Lisp-like syntax and naming
    conventions for the basic Objective-C operations, with automatic type
    processing and messages checked for validity at compile-time.  It
    also provides some convenience facilities for working with
    Cocoa.</p>
<a id="changes-in-1.2"></a>
<H3>Changes in 1.2</H3>
<div class="section">
<p>Version 1.2 of Clozure CL exports most of the useful symbols
    described in this chapter; in previous releases, most of them were
    private in the <CODE>CCL</CODE> package.</p>
<p>There are several new reader macros that make it much more
    convenient than before to refer to several classes of symbols used
    with the Objective-C bridge. For a full description of these
    reader-macros, see
    the <a href="#the-foreign-function-interface-dictionary">Foreign-Function-Interface Dictionary</a>, especially the entries at the beginning,
    describing reader macros.</p>
<p>As in previous releases, 32-bit versions of Clozure CL use 32-bit
    floats and integers in data structures that describe geometry,
    font sizes and metrics, and so on. 64-bit versions of Clozure CL use
    64-bit values where appropriate.</p>
<p>      The Objective-C bridge defines the
      type <CODE>NS:CGFLOAT</CODE> as the Lisp type of the preferred
      floating-point type on the current platform, and defines the
      constant <CODE>NS:+CGFLOAT+</CODE>.  On DarwinPPC32, the foreign
      types <CODE>:cgfloat</CODE>, <CODE>:&lt;NSUI&gt;nteger</CODE>,
      and
      <CODE>:&lt;NSI&gt;nteger</CODE> are defined by the Objective-C
      bridge (as 32-bit float, 32-bit unsigned integer, and 32-bit
      signed integer, respectively); these types are defined as 64-bit
      variants in the 64-bit interfaces.</p>
<p>Every Objective-C class is now properly named, either with a
      name exported from the <CODE>NS</CODE> package (in the case of a
      predefined class declared in the interface files) or with the
      name provided in the <CODE>DEFCLASS</CODE> form (with <CODE>:METACLASS</CODE><CODE>NS:+NS-OBJECT</CODE>) which defines the class from Lisp.
      The class's Lisp name is now proclaimed to be a "static"
      variable (as if by <CODE>DEFSTATIC</CODE>, as described in the
      <a href="#static-variables">"Static Variables" section</a>) and given the class object as its value.  In
      other words:</p>
<pre class="source-code">
(send (find-class 'ns:ns-application) 'shared-application)
    
</pre>
<p>and</p>
<pre class="source-code">
(send ns:ns-application 'shared-application)
    
</pre>
<p>are equivalent.  (Since it's not legal to bind a "static"
  variable, it may be necessary to rename some things so that
  unrelated variables whose names coincidentally conflict with
  Objective-C class names don't do so.)</p>
</div>
<a id="using-objective-c-classes"></a>
<H3>Using Objective-C Classes</H3>
<div class="section">
<p>The class of most standard CLOS classes is named
      STANDARD-CLASS. In the Objective-C object model, each class is
      an instance of a (usually unique) metaclass, which is itself an
      instance of a "base" metaclass (often the metaclass of the class
      named "NSObject".) So, the Objective-C class named "NSWindow"
      and the Objective-C class "NSArray" are (sole) instances of
      their distinct metaclasses whose names are also "NSWindow" and
      "NSArray", respectively. (In the Objective-C world, it's much
      more common and useful to specialize class behavior such as
      instance allocation.)</p>
<p>      When Clozure CL first loads foreign libraries containing
      Objective-C classes, it identifies the classes they contain. The
      foreign class name, such as "NSWindow", is mapped to an external
      symbol in the "NS" package via the bridge's translation rules,
      such as NS:NS-WINDOW.  A similar transformation happens to the
      metaclass name, with a "+" prepended, yielding something like
      NS:+NS-WINDOW.</p>
<p>      These classes are integrated into CLOS such that the
      metaclass is an instance of the class OBJC:OBJC-METACLASS and
      the class
      is an instance of the metaclass. SLOT-DESCRIPTION metaobjects are
      created for each instance variable, and the class and metaclass go
      through something very similar to the "standard" CLOS class
      initialization protocol (with a difference being that these classes
      have already been allocated.)</p>
<p>      Performing all this initialization, which is done when you
      (require "COCOA"), currently takes several
      seconds; it could conceivably be sped up some, but it's never likely
      to be fast.</p>
<p>      When the process is complete, CLOS is aware of several hundred
      new Objective-C classes and their metaclasses. Clozure CL's runtime system can
      reliably recognize MACPTRs to Objective-C classes as being CLASS objects, and
      can (fairly reliably but heuristically) recognize instances of those
      classes (though there are complicating factors here; see below.)
      SLOT-VALUE can be used to access (and, with care, set) instance
      variables in Objective-C instances. To see this, do:</p>
<pre class="source-code">
      ? (require "COCOA")
    
</pre>
<p>and, after waiting a bit longer for a Cocoa listener window to
      appear, activate that Cocoa listener and do:</p>
<pre class="source-code">? (describe (ccl::send ccl::*NSApp* 'key-window))
    
</pre>
<p>This sends a message asking for the key window, which is the window
      that has the input focus (often the frontmost), and then describes
      it. As we can see, NS:NS-WINDOWs have lots of interesting slots.</p>
</div>
<a id="instantiating-objective-c-objects"></a>
<H3>Instantiating Objective-C Objects</H3>
<div class="section">
<p>Making an instance of an Objective-C class (whether the class in
      question is predefined or defined by the application) involves
      calling MAKE-INSTANCE with the class and a set of initargs as
      arguments.  As with STANDARD-CLASS, making an instance involves
      initializing (with INITIALIZE-INSTANCE) an object allocated with
      ALLOCATE-INSTANCE.</p>
<p>For example, you can create an ns:ns-number like this:</p>
<pre class="source-code">
      ? (make-instance 'ns:ns-number :init-with-int 42)
      #&lt;NS-CF-NUMBER 42 (#x85962210)&gt;
    
</pre>
<p>It's worth looking at how this would be done if you were
      writing in Objective C:</p>
<pre class="source-code">
      [[NSNumber alloc] initWithInt: 42]
    
</pre>
<p>Allocating an instance of an Objective-C class involves sending the
      class an "alloc" message, and then using those initargs that
      <EMPH>don't</EMPH> correspond to slot initargs as the
      "init" message to be sent to the newly-allocated instance.  So, the
      example above could have been done more verbosely as:</p>
<pre class="source-code"><p>
      ? (defvar *n* (ccl::send (find-class 'ns:ns-number) 'alloc))
      *N*</p>
<p>      ? (setq *n* (ccl::send *n* :init-with-int 42))
      #&lt;NS-CF-NUMBER 42 (#x16D340)&gt;
    </p>
</pre>
<p>That setq is important; this is a case where init
      decides to replace the object and return the new one, instead
      of modifying the existing one.
      In fact, if you leave out the setq and
      then try to view the value of *N*, Clozure CL will freeze.  There's
      little reason to ever do it this way; this is just to show
      what's going on.</p>
<p>      You've seen that an Objective-C initialization method doesn't have to
      return the same object it was passed.  In fact, it doesn't have
      to return any object at all; in this case, the initialization fails
      and make-instance returns nil.</p>
<p>      In some special cases, such as loading an ns:ns-window-controller
      from a .nib file, it may be necessary for you to pass the
      instance itself as one of the parameters to the initialization
      method.  It goes like this:</p>
<pre class="source-code"><p>
      ? (defvar *controller*
      (make-instance 'ns:ns-window-controller))
      *CONTROLLER*</p>
<p>      ? (setq *controller*
      (ccl::send *controller*
      :init-with-window-nib-name #@"DataWindow"
      :owner *controller*))
      #&lt;NS-WINDOW-CONTROLLER &lt;NSWindowController: 0x1fb520&gt; (#x1FB520)&gt;
    </p>
</pre>
<p>This example calls (make-instance) with no initargs.  When you
      do this, the object is only allocated, and not initialized.  It
      then sends the "init" message to do the initialization by hand.</p>
<p>      There is an alternative API for instantiating Objective-C
      classes. You can
      call <CODE>OBJC:MAKE-OBJC-INSTANCE</CODE>, passing it the
      name of the Objective-C class as a string. In previous
      releases, <CODE>OBJC:MAKE-OBJC-INSTANCE</CODE> could be
      more efficient than <CODE>OBJC:MAKE-INSTANCE</CODE> in
      cases where the class did not define any Lisp slots; this is no
      longer the case. You can now
      regard <CODE>OBJC:MAKE-OBJC-INSTANCE</CODE> as completely
      equivalent to <CODE>OBJC:MAKE-INSTANCE</CODE>, except that
      you can pass a string for the classname, which may be convenient
      in the case that the classname is in some way unusual.</p>
</div>
<a id="calling-objective-c-methods"></a>
<H3>Calling Objective-C Methods</H3>
<div class="section">
<p>In Objective-C, methods are called "messages", and there's
      a special syntax to send a message to an object:</p>
<pre class="source-code">
      [w alphaValue]
      [w setAlphaValue: 0.5]
      [v mouse: p inRect: r]
    
</pre>
<p>The first line sends the method "alphaValue" to the object
      <CODE>w</CODE>, with no parameters.  The second line sends
      the method "setAlphaValue", with the parameter 0.5.  The third
      line sends the method "mouse:inRect:" - yes, all one long word -
      with the parameters <CODE>p</CODE> and
      <CODE>r</CODE>.</p>
<p>In Lisp, these same three lines are:</p>
<pre class="source-code">
      (send w 'alpha-value)
      (send w :set-alpha-value 0.5)
      (send v :mouse p :in-rect r)
    
</pre>
<p>Notice that when a method has no parameters, its name is an ordinary
      symbol (it doesn't matter what package the symbol is in, as
      only its name is checked).  When a method has parameters,
      each part of its name is a keyword, and the keywords alternate
      with the values.</p>
<p>      These two lines break those rules, and both  will
      result in error messages:</p>
<pre class="source-code">
      (send w :alpha-value)
      (send w 'set-alpha-value 0.5)
    
</pre>
<p>Instead of (send), you can also invoke (send-super), with the
      same interface.  It has roughly the same purpose as CLOS's
      (call-next-method); when you use (send-super), the message is
      handled by the superclass.  This can be used to get at the
      original implementation of a method when it is shadowed by a
      method in your subclass.</p>
<a id="type-coercion-for-objective-c-method-calls"></a>
<H4>Type Coercion for Objective-C Method Calls</H4>
<div class="section">
<p>Clozure CL's FFI handles many common conversions between
        Lisp and foreign data, such as unboxing floating-point args
        and boxing floating-point results.  The bridge adds a few more
        automatic conversions:</p>
<p>        NIL is equivalent to (%NULL-PTR) for any message
        argument that requires a pointer.</p>
<p>T/NIL are equivalent to #$YES/#$NO for any boolean argument.</p>
<p>        A #$YES/#$NO returned by any method that returns BOOL
        will be automatically converted to T/NIL.</p>
</div>
<a id="methods-which-return-structures"></a>
<H4>Methods which Return Structures</H4>
<div class="section">
<p>Some Cocoa methods return small structures, such as
        those used to represent points, rects, sizes and ranges. When
        writing in Objective C, the compiler hides the implementation
        details.  Unfortunately, in Lisp we must be slightly more
        aware of them.</p>
<p>        Methods which return structures are called in a special
        way; the caller allocates space for the result, and passes a
        pointer to it as an extra argument to the method.  This is
        called a Structure Return, or STRET.  Don't look at me; I
        don't name these things.</p>
<p>	    Here's a simple use of this in Objective C.  The first line
	    sends the "bounds" message to v1, which returns a rectangle.
	    The second line sends the "setBounds" message to v2, passing
	    that same rectangle as a parameter.</p>
<pre class="source-code">
        NSRect r = [v1 bounds];
        [v2 setBounds r];
	  
</pre>
<p>In Lisp, we must explicitly allocate the memory, which
        is done most easily and safely with <a href="#m_rlet"><CODE>rlet</CODE></a>.
        We do it like this:</p>
<pre class="source-code">
(rlet ((r :&lt;NSR&gt;ect))
          (send/stret r v1 'bounds)
          (send v2 :set-bounds r))
      
</pre>
<p>The rlet allocates the storage (but doesn't initialize
        it), and makes sure that it will be deallocated when we're
        done.  It binds the variable r to refer to it.  The call to
        <CODE>send/stret</CODE> is just like an ordinary call to
        <CODE>send</CODE>, except that r is passed as an extra,
        first parameter.  The third line, which calls
        <CODE>send</CODE>, does not need to do anything special,
        because there's nothing complicated about passing a structure
        as a parameter.</p>
<p>	    In order to make STRETs easier to use, the bridge
	    provides two conveniences.</p>
<p>        First, you can use the macros <CODE>slet</CODE>
        and <CODE>slet*</CODE> to allocate and initialize local
        variables to foreign structures in one step.  The example
        above could have been written more tersely as:</p>
<pre class="source-code">
(slet ((r (send v1 'bounds)))
      (send v2 :set-bounds r))
	  
</pre>
<p>Second, when one call to <CODE>send</CODE> is made
        inside another, the inner one has an implicit
        <CODE>slet</CODE> around it.  So, one could in fact
        just write:</p>
<pre class="source-code">
(send v1 :set-bounds (send v2 'bounds))
      
</pre>
<p>There are also several pseudo-functions provided for convenience
        by the Objective-C compiler, to make objects of specific types. The
        following are currently supported by the bridge: NS-MAKE-POINT,
        NS-MAKE-RANGE, NS-MAKE-RECT, and NS-MAKE-SIZE.</p>
<p>These pseudo-functions can be used within an SLET initform:</p>
<pre class="source-code">
(slet ((p (ns-make-point 100.0 200.0)))
      (send w :set-frame-origin p))
      
</pre>
<p>Or within a call to <CODE>send</CODE>:</p>
<pre class="source-code">
(send w :set-origin (ns-make-point 100.0 200.0))
      
</pre>
<p>However, since these aren't real functions, a call like the
        following won't work:</p>
<pre class="source-code">
(setq p (ns-make-point 100.0 200.0))
      
</pre>
<p>To extract fields from these objects, there are also some
        convenience macros: NS-MAX-RANGE, NS-MIN-X,
        NS-MIN-Y, NS-MAX-X, NS-MAX-Y, NS-MID-X, NS-MID-Y,
        NS-HEIGHT, and NS-WIDTH.</p>
<p>        Note that there is also a <CODE>send-super/stret</CODE>
        for use within methods.  Like <CODE>send-super</CODE>,
        it ignores any shadowing methods in a subclass, and calls the
        version of a method which belongs to its superclass.</p>
</div>
<a id="variable-arity-messages"></a>
<H4>Variable-Arity Messages</H4>
<div class="section">
<p>
        There are a few messages in Cocoa which take variable numbers
        of arguments. Perhaps the most common examples involve
        formatted strings:</p>
<pre class="source-code">
[NSClass stringWithFormat: "%f %f" x y]
      
</pre>
<p>In Lisp, this would be written:</p>
<pre class="source-code">
(send (find-class 'ns:ns-string)
      :string-with-format #@"%f %f"
      (:double-float x :double-float y))
      
</pre>
<p>Note that it's necessary to specify the foreign types of the
        variables (in this example, :double-float), because the
        compiler has no general way of knowing these types.  (You
        might think that it could parse the format string, but this
        would only work for format strings which are not determined
        at runtime.)</p>
<p>        Because the Objective-C runtime system does not provide any information
        on which messages are variable arity, they must be explicitly
        declared. The standard variable arity messages in Cocoa are
        predeclared by the bridge.  If you need to declare a new
        variable arity message, use
        (DEFINE-VARIABLE-ARITY-MESSAGE "myVariableArityMessage:").</p>
</div>
<a id="optimization"></a>
<H4>Optimization</H4>
<div class="section">
<p>The bridge works fairly hard to optimize message sends,
        when it has enough information to do so.  There are two cases
        when it does.  In either, a message send should be nearly as
        efficient as when writing in Objective C.</p>
<p>        The first case is when both the message and the
        receiver's class are known at compile-time. In general, the
        only way the receiver's class is known is if you declare it,
        which you can do with either a DECLARE or a THE form.  For
        example:</p>
<pre class="source-code">
(send (the ns:ns-window w) 'center)
	  
</pre>
<p>Note that there is no way in Objective-C to name the class of a
        class.  Thus the bridge provides a declaration, @METACLASS.
        The type of an instance of "NSColor" is ns:ns-color.  The type
        of the <EMPH>class</EMPH> "NSColor" is (@metaclass
        ns:ns-color):</p>
<pre class="source-code">
(let ((c (find-class 'ns:ns-color)))
  (declare ((ccl::@metaclass ns:ns-color) c))
  (send c 'white-color))
      
</pre>
<p>The other case that allows optimization is when only
        the message is known at compile-time, but its type signature
        is unique. Of the more-than-6000 messages currently provided
        by Cocoa, only about 50 of them have nonunique type
        signatures.</p>
<p>        An example of a message with a type signature that is
        not unique is SET.  It returns VOID for NSColor, but ID for
        NSSet.  In order to optimize sends of messages with nonunique
        type signatures, the class of the receiver must be declared at
        compile-time.</p>
<p>        If the type signature is nonunique or the message is
        unknown at compile-time, then a slower runtime call must be
        used.</p>
<p>        When the receiver's class is unknown, the bridge's
        ability to optimize relies on a type-signature table which it
        maintains.  When first loaded, the bridge initializes this
        table by scanning every method of every Objective-C class.  When new
        methods are defined later, the table must be updated.  This
        happens automatically when you define methods in Lisp.  After
        any other major change, such as loading an external framework,
        you should rebuild the table:</p>
<pre class="source-code">
? (update-type-signatures)
      
</pre>
<p>Because <CODE>send</CODE> and its relatives
        <CODE>send-super</CODE>, <CODE>send/stret</CODE>,
        and <CODE>send-super/stret</CODE> are macros, they
        cannot be <CODE>funcall</CODE>ed,
        <CODE>apply</CODE>ed, or passed as arguments to
        functions.</p>
<p>        To work around this, there are function equivalents to
        them: <CODE>%send</CODE>,
        <CODE>%send-super</CODE>,
        <CODE>%send/stret</CODE>, and
        <CODE>%send-super/stret</CODE>.  However, these
        functions should be used only when the macros will not do,
        because they are unable to optimize.</p>
</div>
</div>
<a id="defining-objective-c-classes"></a>
<H3>Defining Objective-C Classes</H3>
<div class="section">
<p>You can define your own foreign classes, which can then be
      passed to foreign functions; the methods which you implement in
      Lisp will be made available to the foreign code as
      callbacks.</p>
<p>      You can also define subclasses of existing classes,
      implementing your subclass in Lisp even though the parent class
      was in Objective C.  One such subclass is CCL::NS-LISP-STRING.
      It is also particularly useful to make subclasses of
      NS-WINDOW-CONTROLLER.</p>
<p>      We can use the MOP to define new Objective-C classes, but
      we have to do something a little funny: the :METACLASS that we'd
      want to use in a DEFCLASS option generally doesn't exist until
      we've created the class (recall that Objective-C classes have, for the
      sake of argument, unique and private metaclasses.) We can sort
      of sleaze our way around this by specifying a known Objective-C
      metaclass object name as the value of the DEFCLASS :METACLASS
      object; the metaclass of the root class NS:NS-OBJECT,
      NS:+NS-OBJECT, makes a good choice. To make a subclass of
      NS:NS-WINDOW (that, for simplicity's sake, doesn't define any
      new slots), we could do:</p>
<pre class="source-code">
(defclass example-window (ns:ns-window)
  ()
  (:metaclass ns:+ns-object))
    
</pre>
<p>That'll create a new Objective-C class named EXAMPLE-WINDOW whose
      metaclass is the class named +EXAMPLE-WINDOW. The class will be
      an object of type OBJC:OBJC-CLASS, and the metaclass will be of
      type OBJC:OBJC-METACLASS.  EXAMPLE-WINDOW will be a subclass of
      NS-WINDOW.</p>
<a id="defining-classes-with-foreign-slots"></a>
<H4>Defining classes with foreign slots</H4>
<div class="section">
<p>If a slot specification in an Objective-C class
        definition contains the keyword :FOREIGN-TYPE, the slot will
        be a "foreign slot" (i.e. an Objective-C instance variable). Be aware
        that it is an error to redefine an Objective-C class so that its
        foreign slots change in any way, and Clozure CL doesn't do
        anything consistent when you try to.</p>
<p>        The value of the :FOREIGN-TYPE initarg should be a
        foreign type specifier. For example, if we wanted (for some
        reason) to define a subclass of NS:NS-WINDOW that kept track
        of the number of key events it had received (and needed an
        instance variable to keep that information in), we could
        say:</p>
<pre class="source-code">
(defclass key-event-counting-window (ns:ns-window)
  ((key-event-count :foreign-type :int
                    :initform 0
                    :accessor window-key-event-count))
  (:metaclass ns:+ns-object))
      
</pre>
<p>Foreign slots are always SLOT-BOUNDP, and the initform
        above is redundant: foreign slots are initialized to binary
        0.</p>
</div>
<a id="defining-classes-with-lisp-slots"></a>
<H4>Defining classes with Lisp slots</H4>
<div class="section">
<p>A slot specification in an Objective-C class definition that
        doesn't contain the :FOREIGN-TYPE initarg defines a
        pretty-much normal lisp slot that'll happen to be associated
        with "an instance of a foreign class". For instance:</p>
<pre class="source-code">
(defclass hemlock-buffer-string (ns:ns-string)
  ((hemlock-buffer :type hi::hemlock-buffer
                   :initform hi::%make-hemlock-buffer
                   :accessor string-hemlock-buffer))
  (:metaclass ns:+ns-object))
	  
</pre>
<p>As one might expect, this has memory-management
        implications: we have to maintain an association between a
        MACPTR and a set of lisp objects (its slots) as long as the
        Objective-C instance exists, and we have to ensure that the Objective-C
        instance exists (does not have its -dealloc method called)
        while lisp is trying to think of it as a first-class object
        that can't be "deallocated" while it's still possible to
        reference it. Associating one or more lisp objects with a
        foreign instance is something that's often very useful; if you
        were to do this "by hand", you'd have to face many of the same
        memory-management issues.</p>
</div>
</div>
<a id="defining-objective-c-methods"></a>
<H3>Defining Objective-C Methods</H3>
<div class="section">
<p>In Objective-C, unlike in CLOS, every method belongs to some
      particular class.  This is probably not a strange concept to
      you, because C++ and Java do the same thing.  When you use Lisp
      to define Objective-C methods, it is only possible to define methods
      belonging to Objective-C classes which have been defined in
      Lisp.</p>
<p>      You can use either of two different macros to define methods
      on Objective-C classes. <CODE>define-objc-method</CODE>
      accepts a two-element list containing a message selector name
      and a class name, and a body. <CODE>objc:defmethod</CODE>
      superficially resembles the normal
      CLOS <CODE>defmethod</CODE>, but creates methods on
      Objective-C classes with the same restrictions as those created
      by <CODE>define-objc-method</CODE>.</p>
<a id="using-define-objc-method"></a>
<H4>Using define-objc-method</H4>
<div class="section">
<p>As described in the
        section <a href="#calling-objective-c-methods">Calling Objective-C Methods</a>, the names of Objective-C methods
        are broken into pieces, each piece followed by a parameter.
        The types of all parameters must be explicitly
        declared.</p>
<p>        Consider a few examples, meant to illustrate the use
        of <CODE>define-objc-method</CODE>. Let us define a
        class to use in them:</p>
<pre class="source-code">
(defclass data-window-controller (ns:ns-window-controller)
  ((window :foreign-type :id :accessor window)
   (data :initform nil :accessor data))
  (:metaclass ns:+ns-object))
      
</pre>
<p>There's nothing special about this class.  It inherits from
        <CODE>ns:ns-window-controller</CODE>.  It has two slots:
        <CODE>window</CODE> is a foreign slot, stored in the Objective-C
        world; and <CODE>data</CODE> is an ordinary slot, stored
        in the Lisp world.</p>
<p>        Here is an example of how to define a method which takes no
        arguments:</p>
<pre class="source-code">
(define-objc-method ((:id get-window)
                     data-window-controller)
    (window self))
      
</pre>
<p>The return type of this method is the foreign type :id,
        which is used for all Objective-C objects.  The name of the
        method is
        <CODE>get-window</CODE>.  The body of the method is the
        single line <CODE>(window self)</CODE>.  The
        variable <CODE>self</CODE> is bound, within the body, to
        the instance that is receiving the message.  The call
        to <CODE>window</CODE> uses the CLOS accessor to get the
        value of the window field.</p>
<p>        Here's an example that takes a parameter.  Notice that the
        name of the method without a parameter was an ordinary symbol,
        but with a parameter, it's a keyword:</p>
<pre class="source-code">
(define-objc-method ((:id :init-with-multiplier (:int multiplier))
                     data-window-controller)
  (setf (data self) (make-array 100))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (* i multiplier)))
  self)
      
</pre>
<p>To Objective-C code that uses the class, the name of this
        method is <CODE>initWithMultiplier:</CODE>.  The name of
        the parameter is
        <CODE>multiplier</CODE>, and its type
        is <CODE>:int</CODE>.  The body of the method does some
        meaningless things.  Then it returns
        <CODE>self</CODE>, because this is an initialization
        method.</p>
<p>Here's an example with more than one parameter:</p>
<pre class="source-code">
(define-objc-method ((:id :init-with-multiplier (:int multiplier)
                          :and-addend (:int addend))
                     data-window-controller)
  (setf (data self) (make-array size))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (+ (* i multiplier)
             addend)))
  self)
      
</pre>
<p>To Objective-C, the name of this method is
        <CODE>initWithMultiplier:andAddend:</CODE>.  Both
        parameters are of type <CODE>:int</CODE>; the first is
        named <CODE>multiplier</CODE>, and the second
        is <CODE>addend</CODE>.  Again, the method returns
        <CODE>self</CODE>.</p>
<p>        Here is a method that does not return any value, a so-called
        "void method".  Where our other methods
        said <CODE>:id</CODE>, this one
        says <CODE>:void</CODE> for the return type:</p>
<pre class="source-code">
(define-objc-method ((:void :take-action (:id sender))
                     data-window-controller)
  (declare (ignore sender))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (- (aref (data self) i)))))
      
</pre>
<p>This method would be called <CODE>takeAction:</CODE>
        in Objective-C.  The convention for methods that are going to be
        used as Cocoa actions is that they take one parameter, which is
        the object responsible for triggering the action.  However, this
        method doesn't actually need to use that parameter, so it
        explicitly ignores it to avoid a compiler warning.  As promised,
        the method doesn't return any value.</p>
<p>        There is also an alternate syntax, illustrated here.  The
        following two method definitions are equivalent:</p>
<pre class="source-code"><p>
(define-objc-method ("applicationShouldTerminate:"
                     "LispApplicationDelegate")
    (:id sender :&lt;BOOL&gt;)
    (declare (ignore sender))
    nil)</p>
<p>(define-objc-method ((:&lt;BOOL&gt;
                        :application-should-terminate sender)
                       lisp-application-delegate)
    (declare (ignore sender))
    nil)
      </p>
</pre>
</div>
<a id="using-objc-defmethod"></a>
<H4>Using objc:defmethod</H4>
<div class="section">
<p>The macro <CODE>OBJC:DEFMETHOD</CODE> can be used to
        define Objective-C methods.  It looks superficially like
        <CODE>CL:DEFMETHOD</CODE> in some respects.</p>
<p>Its syntax is</p>
<pre class="source-code">
(OBC:DEFMETHOD name-and-result-type 
               ((receiver-arg-and-class) <CODE>&amp;rest</CODE> other-args) 
      <CODE>&amp;body</CODE> body)
      
</pre>
<p><CODE>name-and-result-type</CODE> is either an
        Objective-C message name, for methods that return a value of
        type <CODE>:ID</CODE>, or a list containing an
        Objective-C message name and a foreign type specifier for
        methods with a different foreign result type.</p>
<p>        <CODE>receiver-arg-and-class</CODE> is a two-element
        list whose first element is a variable name and whose second
        element is the Lisp name of an Objective-C class or metaclass.
        The receiver variable name can be any bindable lisp variable
        name, but <CODE>SELF</CODE> might be a reasonable
        choice.  The receiver variable is declared to be "unsettable";
        i.e., it is an error to try to change the value of the
        receiver in the body of the method definition.</p>
<p>            <CODE>other-args</CODE> are either variable names
            (denoting parameters of type <CODE>:ID</CODE>) or
            2-element lists whose first element is a variable name and
            whose second element is a foreign type specifier.</p>
<p>Consider this example:</p>
<pre class="source-code">
(objc:defmethod (#/characterAtIndex: :unichar)
    ((self hemlock-buffer-string) (index :&lt;NSUI&gt;nteger))
  ...)
      
</pre>
<p>The method <CODE>characterAtIndex:</CODE>, when
        invoked on an object of
        class <CODE>HEMLOCK-BUFFER-STRING</CODE> with an
        additional argument of
        type <CODE>:&lt;NSU&gt;integer</CODE> returns a value of
        type
        <CODE>:unichar</CODE>.</p>
<p>        Arguments that wind up as some pointer type other
        than <CODE>:ID</CODE> (e.g. pointers, records passed by
        value) are represented as typed foreign pointers, so that the
        higher-level, type-checking accessors can be used on arguments
        of
        type <CODE>:ns-rect</CODE>, <CODE>:ns-point</CODE>,
        and so on.</p>
<p>        Within the body of methods defined
        via <CODE>OBJC:DEFMETHOD</CODE>, the local function
        <CODE>CL:CALL-NEXT-METHOD</CODE> is defined.  It isn't
        quite as general as <CODE>CL:CALL-NEXT-METHOD</CODE> is
        when used in a CLOS method, but it has some of the same
        semantics.  It accepts as many arguments as are present in the
        containing method's <CODE>other-args</CODE> list and
        invokes version of the containing method that would have been
        invoked on instances of the receiver's class's superclass with
        the receiver and other provided arguments.  (The idiom of
        passing the current method's arguments to the next method is
        common enough that the <CODE>CALL-NEXT-METHOD</CODE> in
        <CODE>OBJC:DEFMETHODs</CODE> should probably do this if
        it receives no arguments.)</p>
<p>        A method defined via <CODE>OBJC:DEFMETHOD</CODE>
        that returns a structure "by value" can do so by returning a
        record created via <CODE>MAKE-GCABLE-RECORD</CODE>, by
        returning the value returned
        via <CODE>CALL-NEXT-METHOD</CODE>, or by other similar
        means. Behind the scenes, there may be a pre-allocated
        instance of the record type (used to support native
        structure-return conventions), and any value returned by the
        method body will be copied to this internal record instance.
        Within the body of a method defined
        with <CODE>OBJC:DEFMETHOD</CODE> that's declared to
        return a structure type, the local macro
        <CODE>OBJC:RETURNING-FOREIGN-STRUCT</CODE> can be used
        to access the internal structure. For example:</p>
<pre class="source-code">
(objc:defmethod (#/reallyTinyRectangleAtPoint: :ns-rect) 
  ((self really-tiny-view) (where :ns-point))
  (objc:returning-foreign-struct (r)
    (ns:init-ns-rect r (ns:ns-point-x where) (ns:ns-point-y where)
                        single-float-epsilon single-float-epsilon)
    r))
       
</pre>
<p>If the <CODE>OBJC:DEFMETHOD</CODE> creates a new
       method, then it displays a message to that effect. These
       messages may be helpful in catching errors in the names of
       method definitions. In addition, if
       a <CODE>OBJC:DEFMETHOD</CODE> form redefines a method in
       a way that changes its type signature, Clozure CL signals a
       continuable error.</p>
</div>
<a id="method-redefinition-constraints"></a>
<H4>Method Redefinition Constraints</H4>
<div class="section">
<p>Objective C was not designed, as Lisp was, with runtime
        redefinition in mind.  So, there are a few constraints about
        how and when you can replace the definition of an Objective C
        method.  Currently, if you break these rules, nothing will
        collapse, but the behavior will be confusing; so
        don't.</p>
<p>        Objective C methods can be redefined at runtime, but
        their signatures shouldn't change.  That is, the types of the
        arguments and the return type have to stay the same.  The
        reason for this is that changing the signature changes the
        selector which is used to call the method.</p>
<p>        When a method has already been defined in one class, and
        you define it in a subclass, shadowing the original method,
        they must both have the same type signature.  There is no such
        constraint, though, if the two classes aren't related and the
        methods just happen to have the same name.</p>
</div>
</div>
<a id="loading-frameworks"></a>
<H3>Loading Frameworks</H3>
<div class="section">
<p>On Mac OS X, a framework is a structured directory
      containing one or more shared libraries along with metadata such
      as C and Objective-C header files. In some cases, frameworks may
      also contain additional items such as executables.</p>
<p>      Loading a framework means opening the shared libraries and
      processing any declarations so that Clozure CL can subsequently call
      its entry points and use its data structures. Clozure CL provides the
      function <CODE>OBJC:LOAD-FRAMEWORK</CODE> for this
      purpose.</p>
<pre class="source-code">
(OBJC:LOAD-FRAMEWORK framework-name interface-dir)
    
</pre>
<p><CODE>framework-name</CODE> is a string that names the
    framework (for example, "Foundation", or "Cocoa"),
    and <CODE>interface-dir</CODE> is a keyword that names the
    set of interface databases associated with the named framework
    (for example, <CODE>:foundation</CODE>,
    or <CODE>:cocoa</CODE>).</p>
<p>    Assuming that interface databases for the named frameworks
    exist on the standard search
    path, <CODE>OBJC:LOAD-FRAMEWORK</CODE> finds and initializes
    the framework bundle by searching OS X's standard framework search
    paths. Loading the named framework may create new Objective-C
    classes and methods, add foreign type descriptions and entry
    points, and adjust Clozure CL's dispatch functions.</p>
<p>    If interface databases don't exist for a framework you want
    to use, you will need to create them. For more information about
    creating interface databases,
    see <a href="#creating-new-interface-directories">Creating new interface directories</a>.</p>
</div>
<a id="how-objective-c-names-are-mapped-to-lisp-symbols"></a>
<H3>How Objective-C Names are Mapped to Lisp Symbols</H3>
<div class="section">
<p>There is a standard set of naming conventions for Cocoa
      classes, messages, etc.  As long as they are followed, the
      bridge is fairly good at automatically translating between Objective-C
      and Lisp names.</p>
<p>      For example, "NSOpenGLView" becomes ns:ns-opengl-view;
      "NSURLHandleClient" becomes ns:ns-url-handle-client; and
      "nextEventMatchingMask:untilDate:inMode:dequeue:" becomes
      (:next-event-matching-mask :until-date :in-mode :dequeue).  What
      a mouthful.</p>
<p>      To see how a given Objective-C or Lisp name will be translated by
      the bridge, you can use the following functions:</p>
(ccl::objc-to-lisp-classname string)
(ccl::lisp-to-objc-classname symbol)
(ccl::objc-to-lisp-message string)
(ccl::lisp-to-objc-message string)
(ccl::objc-to-lisp-init string)
(ccl::lisp-to-objc-init keyword-list)
<p>Of course, there will always be exceptions to any naming
      convention.  Please tell us on the mailing lists if you come
      across any name translation problems that seem to be bugs.
      Otherwise, the bridge provides two ways of dealing with
      exceptions:</p>
<p>      First, you can pass a string as the class name of
      MAKE-OBJC-INSTANCE and as the message to SEND.  These strings
      will be directly interpreted as Objective-C names, with no
      translation. This is useful for a one-time exception.  For
      example:</p>
<pre class="source-code">
(ccl::make-objc-instance "WiErDclass")
(ccl::send o "WiErDmEsSaGe:WithARG:" x y)
    
</pre>
<p>Alternatively, you can define a special translation rule
      for your exception.  This is useful for an exceptional name that
      you need to use throughout your code.  Some examples:</p>
<pre class="source-code">
(ccl::define-classname-translation "WiErDclass" wierd-class)
(ccl::define-message-translation "WiErDmEsSaGe:WithARG:" (:weird-message :with-arg))
(ccl::define-init-translation "WiErDiNiT:WITHOPTION:" (:weird-init :option))
    
</pre>
<p>The normal rule in Objective-C names is that each word begins with a
      capital letter (except possibly the first).  Using this rule
      literally, "NSWindow" would be translated as N-S-WINDOW, which
      seems wrong.  "NS" is a special word in Objective-C that should not be
      broken at each capital letter. Likewise "URL", "PDF", "OpenGL",
      etc. Most common special words used in Cocoa are already defined
      in the bridge, but you can define new ones as follows:</p>
<pre class="source-code">
(ccl::define-special-objc-word "QuickDraw")
    
</pre>
<p>Note that message keywords in a SEND such as (SEND V
      :MOUSE P :IN-RECT R) may look like the keyword arguments in a
      Lisp function call, but they really aren't. All keywords must be
      present and the order is significant. Neither (:IN-RECT :MOUSE)
      nor (:MOUSE) translate to "mouse:inRect:"</p>
<p>      Also, as a special exception, an "init" prefix is optional
      in the initializer keywords, so (MAKE-OBJC-INSTANCE 'NS-NUMBER
      :INIT-WITH-FLOAT 2.7) can also be expressed as
      (MAKE-OBJC-INSTANCE 'NS-NUMBER :WITH-FLOAT 2.7)</p>
</div>
</div>
<a id="the-clozure-cl-ide"></a>
<H2>The Clozure CL IDE</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#introduction_in_the-clozure-cl-ide">
Introduction</a>
<ul style="list-style: none">
</ul>
<li><a href="#building-the-ide">
Building the IDE</a>
<ul style="list-style: none">
</ul>
<li><a href="#running-the-ide">
Running the IDE</a>
<ul style="list-style: none">
</ul>
<li><a href="#ide-features">
IDE Features</a>
<ul style="list-style: none">
<li><a href="#editor-windows">
Editor Windows</a>
<li><a href="#the-lisp-menu">
The Lisp Menu</a>
<li><a href="#the-tools-menu">
The Tools Menu</a>
<li><a href="#the-inspector-window">
The Inspector Window</a>
</ul>
<li><a href="#ide-sources">
IDE Sources</a>
<ul style="list-style: none">
</ul>
<li><a href="#the-application-builder">
The Application Builder</a>
<ul style="list-style: none">
<li><a href="#running-the-application-builder-from-the-command-line">
Running the Application Builder From the Command
      Line</a>
</ul>
</ul>
<a id="introduction_in_the-clozure-cl-ide"></a>
<H3>Introduction</H3>
<div class="section">
<p>Clozure CL ships with the complete source code for an integrated
    development environment written using Cocoa on Mac OS X. This
    chapter describes how to build and use that environment,
    referred to hereafter simply as "the IDE".</p>
<p>      The IDE provides a programmable text editor, listener
      windows, an inspector for Lisp data structures, and a means of
      easily building a Cocoa application in Lisp. In addition, its
      source code provides an example of a fairly complex Cocoa
      application written in Lisp.</p>
<p>    The current version of the IDE has seen the addition of numerous
    features and many bugfixes. Although it's by no means a finished product,
    we hope it will prove more useful than previous versions, and we
    plan additional work on the IDE for future releases.</p>
</div>
<a id="building-the-ide"></a>
<H3>Building the IDE</H3>
<div class="section">
<p>Building the Clozure CL IDE is now a very simple
      process.</p>
<ol><li><p>In a shell session, cd to the ccl directory.</p>
<li><p>Run ccl from the shell. The easiest way to do this is
          generally to execute the ccl or ccl64 command.</p>
<li><p>Evaluate the form <CODE>(require :cocoa-application)</CODE></p>
</ol>
<p>For example, assuming that the Clozure CL distribution is
      installed in "/usr/local/ccl", the following sequence of shell
      interactions builds the IDE:</p>
<pre class="source-code"><p>
oshirion:ccl mikel$ ccl64
Welcome to Clozure Common Lisp Version 1.2-r9198M-trunk  (DarwinX8664)!
? (require :cocoa-application)
;Loading #P"ccl:cocoa-ide;fasls;cocoa-utils.dx64fsl.newest"...
;Loading #P"ccl:cocoa-ide;fasls;cocoa-defaults.dx64fsl.newest"...</p>
<p>[...many lines of "Compiling" and "Loading" omitted...]</p>
<p>Saving application to /usr/local/ccl/Clozure CL.app/</p>
<p>oshirion:ccl mikel$ </p>
<p>    </p>
</pre>
<p>Clozure CL compiles and loads the various subsystems that
      make up the IDE, then constructs a Cocoa application bundle
      named "Clozure CL.app" and saves the Lisp image into
      it. Normally Clozure CL creates the application bundle in the root
      directory of the Clozure CL distribution.</p>
</div>
<a id="running-the-ide"></a>
<H3>Running the IDE</H3>
<div class="section">
<p>After it has been built, you can run the "Clozure CL.app"
      application normally, by double-clicking its icon. When
      launched, the IDE initially displays a
      single <a href="#listener_window">listener window</a> that you can use to interact with Lisp. You
      can type Lisp expressions for evaluation at the prompt in the
      listener window. You can also
      use <a href="#hemlock">Hemlock</a> editing
      commands to edit the text of expressions in the listener
      window.</p>
</div>
<a id="ide-features"></a>
<H3>IDE Features</H3>
<div class="section">
<a id="editor-windows"></a>
<H4>Editor Windows</H4>
<div class="section">
<p>You can open an editor window either by choosing Open from
        the File menu and then selecting a text file, or by choosing
        New from the File menu. You can also evaluate the
        expression <CODE>(ed)</CODE> in the listener window; in that
        case Clozure CL creates a new window as if you had chosen New from
        the File menu.</p>
<p>Editor windows
        implement <a href="#hemlock">Hemlock</a>
        editing commands. You can use all the editing and customization
        features of Hemlock within any editor window (including listener
        windows).</p>
</div>
<a id="the-lisp-menu"></a>
<H4>The Lisp Menu</H4>
<div class="section">
<p>The Lisp menu provides several commands for interacting
        with the running Lisp session, in addition to the ways you can
        interact with it by evaluating expressions. You can evaluate a
        selected range of text in any editing buffer. You can compile
        and load the contents of editor windows (please note that in the
        current version, Clozure CL compiles and loads the contents of the
        file associated with an editor window; that means that if you
        try to load or compile a window that has not been saved to a
        file, the result is an error).</p>
<p>You can interrupt computations, trigger breaks, and select
        restarts from the Lisp menu. You can also display a backtrace or
        open the <a href="#the-inspector-window">Inspector window</a>.</p>
<a id="checking-for-updates"></a>
<H5>Checking for Updates</H5>
<div class="section">
<p>At the bottom of the Lisp menu is an item entitled
        "Check for Updates". If your copy of Clozure CL came from the
        Clozure Subversion server (which is the preferred source), and
        if your internet connection is working, then you can select
        this menu item to check for updates to your copy of
        Clozure CL.</p>
<p>        When you select "Check for Updates", Clozure CL uses the svn
        program to query the Clozure Subversion repository and
        determine whether new updates to Clozure CL are available. (This
        means that on Mac OS X versions earlier than 10.5, you must
        ensure that the Subversion client software is installed before
        using the "Check for Updates" feature. See
        the <a href="http://www.wikihow.com/Install-Subversion-on-Mac-OS-X">wikiHow
        page</a>
 on installing Subversion for more information.)
        If updates are available, Clozure CL automatically downloads and
        installs them. After a successful download, Clozure CL rebuilds
        itself, and then rebuilds the IDE on the newly-rebuilt
        Lisp. Once this process is finished, you should quit the
        running IDE and start the newly built one (which will be in
        the same place that the old one was).</p>
<p>        Normally, Clozure CL can install updates and rebuild itself
        without any problems. Occasionally, an unforeseen problem
        (such as a network outage, or a hardware failure) might
        interrupt the self-rebuilding process, and leave your copy of
        Clozure CL unusable. If you are expecting to update your copy of
        Clozure CL frequently, it might be prudent to keep a backup copy of
        your working environment ready in case of such
        situtations. You can also always obtain a full, fresh copy of
        Clozure CL from Clozure's repository..</p>
</div>
</div>
<a id="the-tools-menu"></a>
<H4>The Tools Menu</H4>
<div class="section">
<p>The tools menu provides access to the Apropos and
        Processes windows. The Apropos window searches the running Lisp
        image for symbols that match any text you enter. You can use the
        Apropos window to quickly find function names and other useful
        symbols. The Processes window lists all threads running in the
        current Lisp session. If you double-click a process entry, Clozure CL
        opens an <a href="#the-inspector-window">Inspector window</a> on that process.</p>
</div>
<a id="the-inspector-window"></a>
<H4>The Inspector Window</H4>
<div class="section">
<p>The Inspector window displays information about a Lisp
        value. The information displayed varies from the very simple, in
        the case of a simple data value such as a character, to the
        complex, in the case of structured data such as lists or CLOS
        objects. The left-hand column of the window's display shows the
        names of the object's attributes; the righthand column shows the
        values associated with those attributes. You can inspect the
        values in the righthand column by double-clicking them.</p>
<p>        Inspecting a value in the righthand column changes the
        Inspector window to display the double-clicked object. You can
        quickly navigate the fields of structured data this way,
        inspecting objects and the objects that they refer
        to. Navigation buttons at the top left of the window enable you
        to retrace your steps, backing up to return to previously-viewed
        objects, and going forward again to objects you navigated into
        previously.</p>
<p>        You can change the contents of a structured object by
        evaluating expressions in a listener window. The refresh button
        (marked with a curved arrow) updates the display of the
        Inspector window, enabling you to quickly see the results of
        changing a data structure.</p>
</div>
</div>
<a id="ide-sources"></a>
<H3>IDE Sources</H3>
<div class="section">
<p>Clozure CL builds the IDE from sources in the "objc-bridge" and
      "cocoa-ide" directories in the Clozure CL distribution. The IDE as a
      whole is a relatively complicated application, and is probably not
      the best place to look when you are first trying to understand how
      to build Cocoa applications. For that, you might benefit more from
      the examples in the "examples/cocoa/" directory. Once you are
      familiar with those examples, though, and have some experience
      building your own application features using Cocoa and the
      Objective-C bridge, you might browse through the IDE sources to
      see how it implements its features.</p>
<p>      The search path for Clozure CL's <CODE>REQUIRE</CODE> feature
      includes the "objc-bridge" and "cocoa-ide" directories. You can
      load features defined in these directories by
      using <CODE>REQUIRE</CODE>. For example, if you want to use the
      Cocoa features of Clozure CL from a terminal session (or from an Emacs
      session using SLIME or ILISP), you can evaluate <CODE>(require
        :cocoa)</CODE>.</p>
</div>
<a id="the-application-builder"></a>
<H3>The Application Builder</H3>
<div class="section">
<p>One important feature of the IDE currently has no Cocoa user
      interface: the application builder. The application builder
      constructs a
      Cocoa <a href="#application_bundle">application bundle</a> that runs a Lisp image when double-clicked. You
      can use the application builder to create Cocoa applications in
      Lisp. These applications are exactly like Cocoa applications
      created with XCode and Objective-C, except that they are written
      in Lisp.</p>
<p>To make the application builder available, evaluate the
      expression <CODE>(require :build-application)</CODE>. Clozure CL loads
      the required subsystems, if necessary.</p>
<a id="f_build-application"></a>
<div class=definition>
<code>build-application</code> <code>&amp;key</code>  (<i></i> <i>name</i> <i>&amp;quot;myapplication&amp;quot;</i> <i></i>)  (<i></i> <i>type-string</i> <i>&amp;quot;appl&amp;quot;</i> <i></i>)  (<i></i> <i>creator-string</i> <i>&amp;quot;omcl&amp;quot;</i> <i></i>)  (<i></i> <i>directory</i> <i>(current-directory)</i> <i></i>)  (<i></i> <i>copy-ide-resources</i> <i>t</i> <i></i>)  (<i></i> <i>info-plist</i> <i>nil</i> <i></i>)  (<i></i> <i>nibfiles</i> <i>nil</i> <i></i>)  (<i></i> <i>main-nib-name</i> <i>nil</i> <i></i>)  (<i></i> <i>application-class</i> <i>&amp;#039;gui::cocoa-application</i> <i></i>)  (<i></i> <i>toplevel-function</i> <i>nil</i> <i></i>) <span class="definition-kind">[Function]</span><a id="description_in_f_build-application"></a>
<p>
      The <a href="#f_build-application"><CODE>ccl::build-application</CODE></a> function constructs an
      application bundle, populates it with the files needed to satisfy
      Mac OS X that the bundle is a launchable application, and saves an
      executable Lisp image to the proper subdirectory of the
      bundle. Assuming that the saved Lisp image contains correct code,
      a user can subsequently launch the resulting Cocoa application by
      double-clicking its icon in the Finder, and the saved Lisp
      environment runs.</p>
<p>      The keyword arguments control various aspects of application
      bundle as <CODE>BUILD-APPLICATION</CODE> builds it.</p>
<dl><dt><I>name</I></dt>
<dd><p>Specifies the application name of the
            bundle. <CODE>BUILD-APPLICATION</CODE> creates an application
            bundle whose name is given by this parameter, with the
            extension ".app" appended. For example, using the default
            value for this parameter results in a bundle named
            "MyApplication.app".</p>
</dd>
<dt><I>type-string</I></dt>
<dd><p>Specifies type of bundle to create. You should normally
            never need to change the default value, which Mac OS X uses to
            identify application bundles.</p>
</dd>
<dt><I>creator-string</I></dt>
<dd><p>Specifies the <a href="#creator_code">creator code</a>, which uniquely identifies the application
            under Mac OS X. The default creator code is that of Clozure CL. For
            more information about reserving and assigning creator codes,
            see
            Apple's <a href="http://developer.apple.com/datatype/index.html">developer
              page</a>
 on the topic.</p>
</dd>
<dt><I>directory</I></dt>
<dd><p>The directory in which <CODE>BUILD-APPLICATION</CODE>
            creates the application bundle. By default, it creates the
            bundle in the current working directory. Unless you
            use <CODE>CURRENT-DIRECTORY</CODE> to set the working
            directory, the bundle may be created in some unexpected place,
            so it's safest to specify a full pathname for this argument. A
            typical value might be <CODE>"/Users/foo/Desktop/"</CODE>
            (assuming, of course, that your username is "foo").</p>
</dd>
<dt><I>copy-ide-resources</I></dt>
<dd><p>Whether to copy the resource files from the IDE's
            application bundle. By
            default, <CODE>BUILD-APPLICATION</CODE> copies nibfiles
            and other resources from the IDE to the newly-created
            application bundle. This option is often useful when you
            are developing a new application, because it enables your
            built application to have a fully-functional user
            interface even before you have finished designing one. By
            default, the application uses the application menu and
            other UI elements of the IDE until you specify
            otherwise. Once your application's UI is fully
            implemented, you may choose to pass <CODE>NIL</CODE>
            for the value of this parameter, in which case the IDE
            resources are not copied into your application
            bundle.</p>
</dd>
<dt><I>info-plist</I></dt>
<dd><p>A user-supplied NSDictionary object that defines the
          contents of the Info.plist file to be written to the
          application bundle. The default value
          is <CODE>NIL</CODE>, which specifies that the
          Info.plist from the IDE is to be used
          if <I>copy-ide-resources</I> is true,
          and a new dictionary created with default values is to be
          used otherwise. You can create a suitable NSDictionary
          object using the
          function <CODE>make-info-dict</CODE>. For details on
          the parameters to this function, see its definition in
          "ccl/cocoa-ide/builder-utilities.lisp".</p>
</dd>
<dt><I>nibfiles</I></dt>
<dd><p>A list of pathnames, where each pathname identifies
            a <a href="#nibfile">nibfile</a> created
            with
            Apple's <a href="#interfacebuilder">InterfaceBuilder</a>
            application. <CODE>BUILD-APPLICATION</CODE> copies each
            nibfile into the appropriate place in the application bundle,
            enabling the application to load user-interface elements from
            them as-needed. It is safest to provide full pathnames to the
            nibfiles in the list. Each nibfile must be in ".nib" format,
            not ".xib" format, in order that the application can load
            it.</p>
</dd>
<dt><I>main-nib-name</I></dt>
<dd><p>The name of
            the <a href="#nibfile">nibfile</a> to load
            initially when launching. The user-interface defined in this
            nibfile becomes the application's main interface. You must
            supply the name of a suitable nibfile for this parameter, or
            the resulting application uses the Clozure CL user
            interface.</p>
</dd>
<dt><I>application-class</I></dt>
<dd><p>The name of the application's CLOS class. The default
            value is the class provided by Clozure CL for graphical
            applications. Supply the name of your application class if you
            implement one. If not, Clozure CL uses the default class.</p>
</dd>
<dt><I>toplevel-function</I></dt>
<dd><p>The toplevel function that runs when the application
            launches. Normally the default value, which is Clozure CL's
            toplevel, works well, but in some cases you may wish to
            customize the behavior of the application's toplevel. The best
            source of information about writing your own toplevel is the
            Clozure CL source code, especially the implementations
            of <CODE>TOPLEVEL-FUNCTION</CODE> in
            "ccl/level-1/l1-application.lisp"</p>
</dd>
</dl>
<p><CODE>BUILD-APPLICATION</CODE> creates a folder named
      "<I>name</I>.app" in the
      directory <I>directory</I>. Inside that
      folder, it creates the "Contents" folder that Mac OS X
      application bundles are expected to contain, and populates it
      with the "MacOS" and "Resources" folders, and the "Info.plist"
      and "PkgInfo" files that must be present in a working
      application bundle. It takes the contents of the "Info.plist"
      and "PkgInfo" files from the parameters
      to <CODE>BUILD-APPLICATION</CODE>. If <I>copy-ide-resources</I>
      is true then it copies the contents of the "Resources" folder
      from the "Resources" folder of the running IDE.</p>
<p>    The work needed to produce a running Cocoa application is
    very minimal. In fact, if you
    supply <CODE>BUILD-APPLICATION</CODE> with a valid nibfile and
    pathnames, it builds a running Cocoa application that displays
    your UI. It doesn't need you to write any code at all to do
    this. Of course, the resulting application doesn't do anything
    apart from displaying the UI defined in the nibfile. If you want
    your UI to accomplish anything, you need to write the code to
    handle its events. But the path to a running application with your
    UI in it is very short indeed.</p>
<p>    Please note that <CODE>BUILD-APPLICATION</CODE> is a work in
    progress. It can easily build a working Cocoa application, but it
    still has limitations that may in some cases prove
    inconvenient. For example, in the current version it provides no
    easy way to specify an application delegate different from the
    default. If you find the current limitations
    of <CODE>BUILD-APPLICATION</CODE> too restrictive, and want to try
    extending it for your use, you can find the source code for it in
    "ccl/cocoa-ide/build-application.lisp". You can see the default
    values used to populate the "Info.plist" file in
    "ccl/cocoa-ide/builder-utilities.lisp".</p>
<p>    For more information on how to
    use <CODE>BUILD-APPLICATION</CODE>, see the Currency Converter
    example in "ccl/examples/cocoa/currency-converter/".</p>
</div>
<a id="running-the-application-builder-from-the-command-line"></a>
<H4>Running the Application Builder From the Command
      Line</H4>
<div class="section">
<p>It's possible to automate use of the application builder
        by running a call to <CODE>CCL:BUILD-APPLICATION</CODE>
        from the terminal command line. For example, the following
        command, entered at a shell prompt in Mac OS X's Terminal
        window, builds a working copy of the Clozure CL environment called
        "Foo.app":</p>
<pre class="source-code">
ccl -b -e "(require :cocoa)" -e "(require :build-application)" -e "(ccl::build-application :name \"Foo\")"
      
</pre>
<p>You can use the same method to automate building your
      Lisp/Cocoa applications. Clozure CL handles each Lisp expressions
      passed with a <CODE>-e</CODE> argument in order, so you
      can simply evaluate a sequence of Lisp expressions as in the
      above example to build your application, ending with a call
      to <CODE>CCL:BUILD-APPLICATION</CODE>. The call
      to <CODE>CCL:BUILD-APPLICATION</CODE> can process all the
      same arguments as if you evaluated it in a Listener window in
      the Clozure CL IDE.</p>
<p>      Building a substantial Cocoa application (rather than just
      reproducing the Lisp environment using defaults, as is done in
      the above example) is likely to involve a relatively complicated
      sequence of loading source files and perhaps evaluating Lisp
      forms. You might be best served to place your command line in a
      shell script that you can more easily edit and test.</p>
<p>        One potentially complicated issue concerns loading all
        your Lisp source files in the right order. You might consider
        using ASDF to define and load a system that includes all the
        parts of your application before
        calling <CODE>CCL:BUILD-APPLICATION</CODE>. ASDF is a
        "another system-definition facility", a sort
        of <CODE>make</CODE> for Lisp, and is included in the
        Clozure CL distribution. You can read more about ASDF at the ASDF
        <a href="http://common-lisp.net/project/asdf/">home
        page</a>
.</p>
<p>        Alternatively, you could use the standard features of
        Common Lisp to load your application's files in the proper
        order.</p>
</div>
</div>
</div>
<a id="hemlock-programming"></a>
<H2>Hemlock Programming</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#introduction_in_hemlock-programming">
Introduction</a>
<ul style="list-style: none">
</ul>
<li><a href="#representation-of-text">
Representation of Text</a>
<ul style="list-style: none">
<li><a href="#lines">
Lines</a>
<li><a href="#marks">
Marks</a>
<li><a href="#regions">
Regions</a>
</ul>
<li><a href="#buffers">
Buffers</a>
<ul style="list-style: none">
<li><a href="#the-current-buffer">
The Current Buffer</a>
<li><a href="#buffer-functions">
Buffer  Functions</a>
<li><a href="#modelines">
Modelines</a>
</ul>
<li><a href="#altering-and-searching-text">
Altering and Searching Text</a>
<ul style="list-style: none">
<li><a href="#altering-text">
Altering Text</a>
<li><a href="#text-predicates">
Text Predicates</a>
<li><a href="#kill-ring">
Kill Ring</a>
<li><a href="#active-regions">
Active Regions</a>
<li><a href="#searching-and-replacing">
Searching and Replacing</a>
</ul>
<li><a href="#the-current-environment">
The Current Environment</a>
<ul style="list-style: none">
<li><a href="#different-scopes">
Different Scopes</a>
<li><a href="#shadowing">
Shadowing</a>
</ul>
<li><a href="#hemlock-variables">
Hemlock Variables</a>
<ul style="list-style: none">
<li><a href="#variable-names">
Variable Names</a>
<li><a href="#variable-functions">
Variable Functions</a>
<li><a href="#hooks">
Hooks</a>
</ul>
<li><a href="#commands">
Commands</a>
<ul style="list-style: none">
<li><a href="#introduction_in_commands">
Introduction</a>
<li><a href="#the-command-interpreter">
The Command Interpreter</a>
<li><a href="#command-types">
Command Types</a>
<li><a href="#command-arguments">
Command Arguments</a>
</ul>
<li><a href="#modes">
Modes</a>
<ul style="list-style: none">
<li><a href="#mode-hooks">
Mode Hooks</a>
<li><a href="#major-and-minor-modes">
Major and Minor Modes</a>
<li><a href="#mode-functions">
Mode Functions</a>
</ul>
<li><a href="#character-attributes">
Character Attributes</a>
<ul style="list-style: none">
<li><a href="#introduction_in_character-attributes">
Introduction</a>
<li><a href="#character-attribute-names">
Character Attribute Names</a>
<li><a href="#character-attribute-functions">
Character Attribute Functions</a>
<li><a href="#character-attribute-hooks">
Character Attribute Hooks</a>
<li><a href="#system-defined-character-attributes">
System Defined Character Attributes</a>
</ul>
<li><a href="#controlling-the-display">
Controlling the Display</a>
<ul style="list-style: none">
<li><a href="#views">
Views</a>
<li><a href="#the-current-view">
The Current View</a>
<li><a href="#view-functions">
View Functions</a>
<li><a href="#cursor-positions">
Cursor Positions</a>
<li><a href="#redisplay">
Redisplay</a>
</ul>
<li><a href="#logical-key-events">
Logical Key-Events</a>
<ul style="list-style: none">
<li><a href="#introduction_in_logical-key-events">
Introduction</a>
<li><a href="#logical-key-event-functions">
Logical Key-Event Functions</a>
<li><a href="#system-defined-logical-key-events">
System Defined Logical Key-Events</a>
</ul>
<li><a href="#the-echo-area">
The Echo Area</a>
<ul style="list-style: none">
<li><a href="#echo-area-functions">
Echo Area Functions</a>
<li><a href="#prompting-functions">
Prompting Functions</a>
<li><a href="#control-of-parsing-behavior">
Control of Parsing Behavior</a>
<li><a href="#defining-new-prompting-functions">
Defining New Prompting Functions</a>
<li><a href="#some-echo-area-commands">
Some Echo Area Commands</a>
</ul>
<li><a href="#files">
Files</a>
<ul style="list-style: none">
<li><a href="#file-options-and-type-hooks">
File Options and Type Hooks</a>
<li><a href="#pathnames-and-buffers">
Pathnames and Buffers</a>
<li><a href="#file-groups">
File Groups</a>
<li><a href="#file-reading-and-writing">
File Reading and Writing</a>
</ul>
<li><a href="#hemlock-s-lisp-environment">
Hemlock's Lisp Environment</a>
<ul style="list-style: none">
<li><a href="#entering-and-leaving-the-editor">
Entering and Leaving the Editor</a>
<li><a href="#keyboard-input">
Keyboard Input</a>
<li><a href="#hemlock-streams">
Hemlock Streams</a>
<li><a href="#interface-to-the-error-system">
Interface to the Error System</a>
<li><a href="#definition-editing">
Definition Editing</a>
<li><a href="#event-scheduling">
Event Scheduling</a>
<li><a href="#miscellaneous_in_hemlock-s-lisp-environment">
Miscellaneous</a>
</ul>
<li><a href="#high-level-text-primitives">
High-Level Text Primitives</a>
<ul style="list-style: none">
<li><a href="#indenting-text">
Indenting Text</a>
<li><a href="#lisp-text-buffers">
Lisp Text Buffers</a>
<li><a href="#english-text-buffers">
English Text Buffers</a>
<li><a href="#logical-pages">
Logical Pages</a>
<li><a href="#filling">
Filling</a>
</ul>
<li><a href="#utilities">
Utilities</a>
<ul style="list-style: none">
<li><a href="#string-table-functions">
String-table Functions</a>
<li><a href="#ring-functions">
Ring Functions</a>
<li><a href="#undoing-commands">
Undoing commands</a>
</ul>
<li><a href="#miscellaneous_in_hemlock-programming">
Miscellaneous</a>
<ul style="list-style: none">
<li><a href="#key-events">
Key-events</a>
</ul>
</ul>
<a id="introduction_in_hemlock-programming"></a>
<H3>Introduction</H3>
<div class="section">
<p>
Hemlock is the text editor used in Clozure CL.  It was originally based on the <a href="http://www.cons.org/cmucl/hemlock/index.html">CMU Hemlock editor</a>
, but has since diverged from it in various ways.  We continue to call the editor part of our IDE <CODE>Hemlock</CODE> to give credit where credit is due, but we make no attempt at source or API compatibility with the original Hemlock.</p>
<p>Like the code, this documentation is based on the original Hemlock documentation, modified as necessary.</p>
<p>Hemlock follows in the tradition of Emacs-compatible editors, with a rich set of extensible commands.  This document describes the API for implementing new commands.  The basic editor consists of a set of Lisp utility functions for manipulating buffers and the other data structures of the editor.  All user level commands are written in terms of these 
functions. To find out how to define commands see <a href="#commands">Commands</a>.
        </p>
</div>
<a id="representation-of-text"></a>
<H3>Representation of Text</H3>
<div class="section">
<p>
In Hemlock, text is represented as a sequence of lines.  Newline characters
are never stored but are implicit between lines.  The
implicit newline character is treated as the single character <CODE>#\Newline</CODE> by the
text primitives.</p>
<p>Text is broken into lines when it is first introduced into Hemlock.  Text enters
Hemlock from the outside world in two ways: reading a file, or pasting text
from the system clipboard.  Hemlock uses heuristics <EMPH>(which should be documented here!)</EMPH>
to decide what newline convention to use to convert the incoming text into its internal
representation as a sequence of lines.  Similarly it uses heuristics
<EMPH>(which should be documented here!)</EMPH> to convert the internal representation into
a string with embedded newlines in order to write a file or paste a region into
the clipboard.
        </p>
<a id="lines"></a>
<H4>Lines</H4>
<div class="section">
<p>
A <CODE>line</CODE> is an object representing a sequence of characters with no line breaks.
            </p>
<a id="f_linep"></a>
<div class=definition>
<code>linep</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_linep"></a>
<p>
This function returns t if line is a line object, otherwise nil.
                    </p>
</div>
<a id="f_line-string"></a>
<div class=definition>
<code>line-string</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-string"></a>
<p>
Given a line, this function returns as a simple string the characters
in the line.  This is setf'able to set the line-string to any string
that does not contain newline characters.  It is an error to
destructively modify the result of line-string or to destructively
modify any string after the line-string of some line has been set to
that string.
                    </p>
</div>
<a id="f_line-previous"></a>
<div class=definition>
<code>line-previous</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-previous"></a>
<p> </p>
</div>
<a id="f_line-next"></a>
<div class=definition>
<code>line-next</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-next"></a>
<p>
Given a line, line-previous returns the previous line or nil if there
is no previous line.  Similarly, line-next returns the line following
line or nil.
                    </p>
</div>
<a id="f_line-buffer"></a>
<div class=definition>
<code>line-buffer</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-buffer"></a>
<p>
This function returns the buffer which contains this line. Since a
line may not be associated with any buffer, in which case line-buffer
returns nil.
                    </p>
</div>
<a id="f_line-length"></a>
<div class=definition>
<code>line-length</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-length"></a>
<p>
This function returns the number of characters in the line. This
excludes the newline character at the end.
                    </p>
</div>
<a id="f_line-character"></a>
<div class=definition>
<code>line-character</code> <i>line</i> <i>index</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-character"></a>
<p>
This function returns the character at position index within line. It
is an error for index to be greater than the length of the line or
less than zero.  If index is equal to the length of the line, this
returns a #\newline character.
                    </p>
</div>
<a id="f_line-plist"></a>
<div class=definition>
<code>line-plist</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-plist"></a>
<p>
This function returns the property-list for line. setf, getf, putf and
remf can be used to change properties. This is typically used in
conjunction with line-signature to cache information about the line's
contents.
                    </p>
</div>
<a id="f_line-signature"></a>
<div class=definition>
<code>line-signature</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-signature"></a>
<p>
This function returns an object that serves as a signature for a
line's contents. It is guaranteed that any modification of text on the
line will result in the signature changing so that it is not eql to
any previous value. The signature may change even when the text
remains unmodified, but this does not happen often.
                    </p>
</div>
</div>
<a id="marks"></a>
<H4>Marks</H4>
<div class="section">
<p>
A <CODE>mark</CODE> indicates a specific position within the text represented by a
line and a character position within that line.  Although a mark is
sometimes loosely referred to as pointing to some character, it in
fact points between characters.  If the charpos is zero, the previous
character is the newline character separating the previous line from
the mark's line. If the charpos is equal to the number of characters
in the line, the next character is the newline character separating
the current line from the next.  If the mark's line has no previous
line, a mark with charpos of zero has no previous character; if the
mark's line has no next line, a mark with charpos equal to the length of
the line has no next character.</p>
<p>This section discusses the very basic operations involving marks, but
a lot of Hemlock programming is built on altering some text at a mark.
For more extended uses of marks see <a href="#altering-and-searching-text">Altering and Searching Text</a>.
            </p>
<a id="kinds-of-marks"></a>
<H5>Kinds of Marks</H5>
<div class="section">
<p>
A mark may have one of two lifetimes: temporary or permanent. Permanent
marks remain valid after arbitrary operations on the text; temporary
marks do not.  Temporary marks are used because less bookkeeping
overhead is involved in their creation and use.  If a temporary mark
is used after the text it points to has been modified results will be
unpredictable. Permanent marks continue to point between the same two
characters regardless of insertions and deletions made before or after
them.</p>
<p>There are two different kinds of permanent marks which differ only in
their behavior when text is inserted at the position of the mark; text
is inserted to the left of a left-inserting mark and to the right of
right-inserting mark.
                </p>
</div>
<a id="mark-functions"></a>
<H5>Mark Functions</H5>
<div class="section">
<a id="f_markp"></a>
<div class=definition>
<code>markp</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_markp"></a>
<p>
This function returns t if mark is a mark object, otherwise nil.
                        </p>
</div>
<a id="f_mark-line"></a>
<div class=definition>
<code>mark-line</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-line"></a>
<p>
This function returns the line to which mark points.
                        </p>
</div>
<a id="f_mark-charpos"></a>
<div class=definition>
<code>mark-charpos</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-charpos"></a>
<p>
This function returns the character position <EMPH>in the line</EMPH> of the character
after mark, i.e. the number of characters before the mark in the mark's line.
                        </p>
</div>
<a id="f_mark-buffer"></a>
<div class=definition>
<code>mark-buffer</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-buffer"></a>
<p>
Returns the buffer containing this mark.
                        </p>
</div>
<a id="f_mark-absolute-position"></a>
<div class=definition>
<code>mark-absolute-position</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-absolute-position"></a>
<p>
This function returns the character position <EMPH>in the buffer</EMPH> of the character
after the mark, i.e. the number of characters before the mark in the mark's
buffer.
                        </p>
</div>
<a id="f_mark-kind"></a>
<div class=definition>
<code>mark-kind</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-kind"></a>
<p>
This function returns one of <CODE>:right-inserting</CODE>, <CODE>:left-inserting</CODE> or
                            <CODE>:temporary</CODE> depending on the mark's kind.  A corresponding setf form
changes the mark's kind.
                        </p>
</div>
<a id="f_previous-character"></a>
<div class=definition>
<code>previous-character</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_previous-character"></a>
<p> </p>
</div>
<a id="f_next-character"></a>
<div class=definition>
<code>next-character</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_next-character"></a>
<p>
This function returns the character immediately before (after) the
position of the mark, or nil if there is no previous (next) character.
These characters may be set with setf when they exist; the setf
methods for these forms signal errors when there is no previous or
next character.
                        </p>
</div>
</div>
<a id="making-marks"></a>
<H5>Making Marks</H5>
<div class="section">
<a id="f_mark"></a>
<div class=definition>
<code>mark</code> <i>line</i> <i>charpos</i> <code>&amp;optional</code> <i>kind</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark"></a>
<p>
This function returns a mark object that points to the charpos'th
character of the line. Kind is the kind of mark to create, one
of <CODE>:temporary</CODE>, <CODE>:left-inserting</CODE>, or <CODE>:right-inserting</CODE>. The default is
:temporary.
                        </p>
</div>
<a id="f_copy-mark"></a>
<div class=definition>
<code>copy-mark</code> <i>mark</i> <code>&amp;optional</code> <i>kind</i> <span class="definition-kind">[Function]</span><a id="description_in_f_copy-mark"></a>
<p>
This function returns a new mark pointing to the same position and of
the same kind, or of kind kind if it is supplied.
                        </p>
</div>
<a id="f_delete-mark"></a>
<div class=definition>
<code>delete-mark</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-mark"></a>
<p>
This function deletes mark. Delete any permanent marks when you are
finished using it.
                        </p>
</div>
<a id="m_with-mark"></a>
<div class=definition>
<code>with-mark</code>  (<i>{(mark</i> <i>pos</i> <i>[kind])}*</i>) <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-mark"></a>
<p>
This macro binds to each variable mark a mark of kind kind, which
defaults to <CODE>:temporary</CODE>, pointing to the same position as the
markpos. On exit from the scope the mark is deleted.  The value of the
last form is the value returned.
                        </p>
</div>
</div>
<a id="moving-marks"></a>
<H5>Moving Marks</H5>
<div class="section">
<p>
These functions destructively modify marks to point to new positions.
Other sections of this document describe mark moving routines specific
to higher level text forms than characters and lines, such as words,
sentences, paragraphs, Lisp forms, etc.
                </p>
<a id="f_move-to-position"></a>
<div class=definition>
<code>move-to-position</code> <i>mark</i> <i>charpos</i> <code>&amp;optional</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_move-to-position"></a>
<p>
This function changes the mark to point to the given character
position on the line line. Line defaults to mark's line.
                        </p>
</div>
<a id="f_move-to-absolute-position"></a>
<div class=definition>
<code>move-to-absolute-position</code> <i>mark</i> <i>position</i> <span class="definition-kind">[Function]</span><a id="description_in_f_move-to-absolute-position"></a>
<p>
This function changes the mark to point to the given character
position in the buffer.
                        </p>
</div>
<a id="f_move-mark"></a>
<div class=definition>
<code>move-mark</code> <i>mark</i> <i>new-position</i> <span class="definition-kind">[Function]</span><a id="description_in_f_move-mark"></a>
<p>
This function moves mark to the same position as the
mark new-position and returns it.
                        </p>
</div>
<a id="f_line-start"></a>
<div class=definition>
<code>line-start</code> <i>mark</i> <code>&amp;optional</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-start"></a>
<p> </p>
</div>
<a id="f_line-end"></a>
<div class=definition>
<code>line-end</code> <i>mark</i> <code>&amp;optional</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-end"></a>
<p>
This function changes mark to point to the beginning or the end of
line and returns it. Line defaults to mark's line.
                        </p>
</div>
<a id="f_buffer-start"></a>
<div class=definition>
<code>buffer-start</code> <i>mark</i> <code>&amp;optional</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-start"></a>
<p> </p>
</div>
<a id="f_buffer-end"></a>
<div class=definition>
<code>buffer-end</code> <i>mark</i> <code>&amp;optional</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-end"></a>
<p>
These functions change mark to point to the beginning or end of
buffer, which defaults to the buffer mark currently points into. If
buffer is unsupplied, then it is an error for mark to be disassociated
from any buffer.
                        </p>
</div>
<a id="f_mark-before"></a>
<div class=definition>
<code>mark-before</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-before"></a>
<p> </p>
</div>
<a id="f_mark-after"></a>
<div class=definition>
<code>mark-after</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-after"></a>
<p>
These functions change mark to point one character before or after the
current position.  If there is no character before/after the current
position, then they return nil and leave mark unmodified.
                        </p>
</div>
<a id="f_character-offset"></a>
<div class=definition>
<code>character-offset</code> <i>mark</i> <i>n</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-offset"></a>
<p>
This function changes mark to point n characters after (n before if n
is negative) the current position.  If there are less than n
characters after (before) the mark, then this returns nil and mark is
unmodified.
                        </p>
</div>
<a id="f_line-offset"></a>
<div class=definition>
<code>line-offset</code> <i>mark</i> <i>n</i> <code>&amp;optional</code> <i>charpos</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-offset"></a>
<p>
This function changes mark to point n lines after (n before if n is
negative) the current position.  The character position of the
resulting mark is (min (line-length resulting-line) (mark-charpos
mark)) if charpos is unspecified, or (min (line-length resulting-line)
charpos) if it is.  As with character-offset, if there are not n lines
then nil is returned and mark is not modified.
                        </p>
</div>
</div>
</div>
<a id="regions"></a>
<H4>Regions</H4>
<div class="section">
<p>
A <CODE>region</CODE> is simply a pair of marks: a starting mark and an ending
mark.  The text in a region consists of the characters following the
starting mark and preceding the ending mark (keep in mind that a mark
points between characters on a line, not at them).  By modifying the
starting or ending mark in a region it is possible to produce regions
with a start and end which are out of order or even in different
buffers.  The use of such regions is undefined and may result in
arbitrarily bad behavior.
            </p>
<a id="region-functions"></a>
<H5>Region Functions</H5>
<div class="section">
<a id="f_region"></a>
<div class=definition>
<code>region</code> <i>start</i> <i>end</i> <span class="definition-kind">[Function]</span><a id="description_in_f_region"></a>
<p>
This function returns a region constructed from the marks start and
end. It is an error for the marks to point to non-contiguous lines or
for start to come after end.
                        </p>
</div>
<a id="f_regionp"></a>
<div class=definition>
<code>regionp</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_regionp"></a>
<p>
This function returns t if region is a region object, otherwise nil.
                        </p>
</div>
<a id="f_make-empty-region"></a>
<div class=definition>
<code>make-empty-region</code> <span class="definition-kind">[Function]</span><a id="description_in_f_make-empty-region"></a>
<p>
This function returns a region with start and end marks pointing to
the start of one empty line.  The start mark is a <CODE>:right-inserting</CODE>
mark, and the end is a <CODE>:left-inserting</CODE> mark.
                        </p>
</div>
<a id="f_copy-region"></a>
<div class=definition>
<code>copy-region</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_copy-region"></a>
<p>
This function returns a region containing a copy of the text in the
specified region. The resulting region is completely disjoint
from region with respect to data references --- marks, lines, text, etc.
                        </p>
</div>
<a id="f_region-to-string"></a>
<div class=definition>
<code>region-to-string</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_region-to-string"></a>
<p> </p>
</div>
<a id="f_string-to-region"></a>
<div class=definition>
<code>string-to-region</code> <i>string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_string-to-region"></a>
<p>
These functions coerce regions to Lisp strings and vice versa.  Within
the string, lines are delimited by newline characters.
                        </p>
</div>
<a id="f_line-to-region"></a>
<div class=definition>
<code>line-to-region</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line-to-region"></a>
<p>
This function returns a region containing all the characters on
line. The first mark is <CODE>:right-inserting</CODE> and the last is
                            <CODE>:left-inserting</CODE>.
                        </p>
</div>
<a id="f_region-start"></a>
<div class=definition>
<code>region-start</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_region-start"></a>
<p> </p>
</div>
<a id="f_region-end"></a>
<div class=definition>
<code>region-end</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_region-end"></a>
<p>
This function returns the start or end mark of region.
                        </p>
</div>
<a id="f_region-bounds"></a>
<div class=definition>
<code>region-bounds</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_region-bounds"></a>
<p>
This function returns as multiple-values the starting and ending marks
of region.
                        </p>
</div>
<a id="f_set-region-bounds"></a>
<div class=definition>
<code>set-region-bounds</code> <i>region</i> <i>start</i> <i>end</i> <span class="definition-kind">[Function]</span><a id="description_in_f_set-region-bounds"></a>
<p>
This function sets the start and end of region to start and end. It is
an error for start to be after or in a different buffer from end.
                        </p>
</div>
<a id="f_count-lines"></a>
<div class=definition>
<code>count-lines</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_count-lines"></a>
<p>
This function returns the number of lines in the region, first and
last lines inclusive.  A newline is associated with the line it
follows, thus a region containing some number of non-newline
characters followed by one newline is one line, but if a newline were
added at the beginning, it would be two lines.
                        </p>
</div>
<a id="f_count-characters"></a>
<div class=definition>
<code>count-characters</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_count-characters"></a>
<p>
This function returns the number of characters in a given region. This
counts line breaks as one character.
                        </p>
</div>
</div>
</div>
</div>
<a id="buffers"></a>
<H3>Buffers</H3>
<div class="section">
<p>
A buffer is an object consisting of:
            <ol><li><p>
A name.
                    </p>
<li><p>
A piece of text.
                    </p>
<li><p>
The insertion point.
                    </p>
<li><p>
An associated file (optional).
                    </p>
<li><p>
A write protect flag.
                    </p>
<li><p>
Some <a href="#hemlock-variables">variables</a>.
                    </p>
<li><p>
Some <a href="#commands">key bindings</a>.
                    </p>
<li><p>
A collection of <a href="#modes">Modes</a>.
		    </p>
<li><p>
A list of modeline fields (optional).
                    </p>
</ol>
Because of the way Hemlock is currently integrated in Cocoa, all modifications
to buffer contents must take place in the GUI thread.  Hemlock commands always
run in the GUI thread, so most of the time you do not need to worry about it.
If you are running code in another thread that needs to modify a buffer, you
should perform that action using <CODE>gui::execute-in-gui</CODE> or <CODE>gui::queue-for-gui</CODE>.
        </p>
<p>
There are no intrinsic limitations on examining buffers from any thread,
however, Hemlock currently does no locking, so you risk seeing the buffer
in an inconsistent state if you look at it outside the GUI thread.
        </p>
<a id="the-current-buffer"></a>
<H4>The Current Buffer</H4>
<div class="section">
<p>
Hemlock has the concept of the "current buffer".  The current buffer
is defined during Hemlock commands as the buffer of the hemlock view
that received the key events that invoked the command.  Many hemlock
functions operate on the current buffer rather than taking an explicit
buffer argument.  In effect, the current buffer is an implicit argument
to many text manipulation functions.
            </p>
<a id="f_current-buffer"></a>
<div class=definition>
<code>current-buffer</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-buffer"></a>
<p>
Returns the current buffer, which, during command execution, is the
buffer that is the target of the command.
                    </p>
</div>
<a id="f_current-point"></a>
<div class=definition>
<code>current-point</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point"></a>
<p>
This function returns the buffer-point of the current buffer . This is
such a common idiom in commands that it is defined despite its trivial
implementation.
                    </p>
</div>
<a id="f_current-point-collapsing-selection"></a>
<div class=definition>
<code>current-point-collapsing-selection</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point-collapsing-selection"></a>
<p>
This function returns the buffer-point of the current buffer, after first
deactivating any active region.
                    </p>
</div>
<a id="f_current-point-extending-selection"></a>
<div class=definition>
<code>current-point-extending-selection</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point-extending-selection"></a>
<p>
This function returns the buffer-point of the current buffer, after first
making sure there is an active region - if the region is already active,
keeps it active, otherwise it establishes a new (empty) region at point.
                    </p>
</div>
<a id="f_current-point-for-insertion"></a>
<div class=definition>
<code>current-point-for-insertion</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point-for-insertion"></a>
<p>
This function checks to see if the current buffer can be modified at its
current point, and errors if not.  Otherwise, it deletes the current
selection if any, and returns the current point.
                    </p>
</div>
<a id="f_current-point-for-deletion"></a>
<div class=definition>
<code>current-point-for-deletion</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point-for-deletion"></a>
<p>
This function checks to see if the current buffer can be modified at its
current point and errors if not.  Otherwise, if there is a section
in the current buffer, it deletes it and returns NIL.  If there is no
selection, it returns the current point.
                    </p>
</div>
<a id="f_current-point-unless-selection"></a>
<div class=definition>
<code>current-point-unless-selection</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-point-unless-selection"></a>
<p>
This function checks to see if the current buffer can be modified at its
current point and errors if not.  Otherwise, if there's a selection in the
current buffer, returns NIL.  If there is no selection, it returns the
current point.
                    </p>
</div>
<a id="f_current-mark"></a>
<div class=definition>
<code>current-mark</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-mark"></a>
<p>
This function returns the top of the current buffer's mark stack.
There always is at least one mark at the beginning of the buffer's
region, and all marks returned are right-inserting.
                    </p>
</div>
<a id="f_pop-buffer-mark"></a>
<div class=definition>
<code>pop-buffer-mark</code> <span class="definition-kind">[Function]</span><a id="description_in_f_pop-buffer-mark"></a>
<p>
This function pops the current buffer's mark stack, returning the
mark.  If the stack becomes empty, this pushes a new mark on the stack
pointing to the buffer's start.  This always deactivates the current
region (see <a href="#active-regions">Active Regions</a>).
                    </p>
</div>
<a id="f_push-buffer-mark"></a>
<div class=definition>
<code>push-buffer-mark</code> <i>mark</i> <code>&amp;optional</code> <i>activate-region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_push-buffer-mark"></a>
<p>
This function pushes mark into the current buffer's mark stack,
ensuring that the mark is right-inserting. If mark does not point into
the current buffer, this signals an error.  Optionally, the current
region is made active, but this never deactivates the current region
(see <a href="#active-regions">Active Regions</a>).
Mark is returned.
                    </p>
</div>
<a id="f_push-new-buffer-mark"></a>
<div class=definition>
<code>push-new-buffer-mark</code> <i>mark</i> <code>&amp;optional</code> <i>activate-region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_push-new-buffer-mark"></a>
<p>
This function pushes a new mark onto the mark stack, at the position of <CODE>mark</CODE>.
It's equivalent to calling <CODE>push-buffer-mark</CODE> on <CODE>(copy-mark mark)</CODE>.
                    </p>
</div>
<a id="f_all-buffers"></a>
<div class=definition>
<code>all-buffers</code> <span class="definition-kind">[Function]</span><a id="description_in_f_all-buffers"></a>
<p>
This function returns a list of all the buffer objects made with make-buffer.
                    </p>
</div>
<a id="v_buffer-names"></a>
<div class=definition>
<code>*buffer-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_buffer-names"></a>
<p>
This variable holds a <a href="#string-table-functions">string-table</a>
mapping the name of a buffer to the corresponding buffer object.
                    </p>
</div>
</div>
<a id="buffer-functions"></a>
<H4>Buffer  Functions</H4>
<div class="section">
<a id="f_make-buffer"></a>
<div class=definition>
<code>make-buffer</code> <i>name</i> <code>&amp;key</code> <i>:modes</i> <i>:modeline-fields</i> <i>:delete-hook</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-buffer"></a>
<p> </p>
</div>
<a id="hv_default_modeline_fields"></a>
<div class=definition>
<code>default</code> <i>modeline</i> <i>fields</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_default_modeline_fields"></a>
<p> </p>
</div>
<a id="hv_make_buffer_hook"></a>
<div class=definition>
<code>make</code> <i>buffer</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_make_buffer_hook"></a>
<p>
make-buffer creates and returns a buffer with the given name. If a
buffer named name already exists, nil is returned. Modes is a list of
modes which should be in effect in the buffer, major mode first,
followed by any minor modes.  If this is omitted then the buffer is
created with the list of modes contained in <a href="#hv_default_modes"><CODE>"Default Modes"</CODE></a>. Modeline-fields is a list of modeline-field objects (see
the  <a href="#modelines">Modelines</a> section)
which may be nil. delete-hook is a list of delete hooks specific
to this buffer, and delete-buffer invokes these along with Delete
Buffer Hook.
                    </p>
<p>
Buffers created with make-buffer are entered into the list
(all-buffers), and their names are inserted into the string-table
*buffer-names*. When a buffer is created the hook Make Buffer Hook is
invoked with the new buffer.
                    </p>
</div>
<a id="f_bufferp"></a>
<div class=definition>
<code>bufferp</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_bufferp"></a>
<p>
Returns t if buffer is a buffer object, otherwise nil.
                    </p>
</div>
<a id="f_buffer-name"></a>
<div class=definition>
<code>buffer-name</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-name"></a>
<p> </p>
</div>
<a id="hv_buffer_name_hook"></a>
<div class=definition>
<code>buffer</code> <i>name</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_name_hook"></a>
<p>
buffer-name returns the name, which is a string, of the given buffer.
The corresponding setf method invokes Buffer Name Hook with buffer
and the new name and then sets the buffer's name.  When the user
supplies a name for which a buffer already exists, the setf method
signals an error.
                    </p>
</div>
<a id="f_buffer-region"></a>
<div class=definition>
<code>buffer-region</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-region"></a>
<p>
Returns the buffer's region.  Note this is the region that contains all
the text in a buffer, as opposed to the <a href="#f_current-region"><CODE>hemlock-interface:current-region</CODE></a>.
                    </p>
<p>
This can be set with setf to replace the buffer's text.
                    </p>
</div>
<a id="f_buffer-pathname"></a>
<div class=definition>
<code>buffer-pathname</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-pathname"></a>
<p> </p>
</div>
<a id="hv_buffer_pathname_hook"></a>
<div class=definition>
<code>buffer</code> <i>pathname</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_pathname_hook"></a>
<p>
buffer-pathname returns the pathname of the file associated with the
given buffer, or nil if it has no associated file.  This is the
truename of the file as of the most recent time it was read or
written.  There is a setf form to change the pathname.  When the
pathname is changed the hook Buffer Pathname Hook is invoked with the
buffer and new value.
                    </p>
</div>
<a id="f_buffer-write-date"></a>
<div class=definition>
<code>buffer-write-date</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-write-date"></a>
<p>
Returns the write date for the file associated with the buffer in
universal time format.  When this the buffer-pathname is set, use setf
to set this to the corresponding write date, or to nil if the date is
unknown or there is no file.
                    </p>
</div>
<a id="f_buffer-point"></a>
<div class=definition>
<code>buffer-point</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-point"></a>
<p>
Returns the mark which is the current location within buffer. To move
the point, use <a href="#f_move-mark"><CODE>hemlock-interface:move-mark</CODE></a> or <a href="#f_move-to-position"><CODE>hemlock-interface:move-to-position</CODE></a></p>
</div>
<a id="f_buffer-mark"></a>
<div class=definition>
<code>buffer-mark</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-mark"></a>
<p>
This function returns the top of buffer's mark stack.  There always is
at least one mark at the beginning of buffer's region, and all marks
returned are right-inserting.
                    </p>
</div>
<a id="f_buffer-start-mark"></a>
<div class=definition>
<code>buffer-start-mark</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-start-mark"></a>
<p> </p>
</div>
<a id="f_buffer-end-mark"></a>
<div class=definition>
<code>buffer-end-mark</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-end-mark"></a>
<p>
These functions return the start and end marks of buffer's region:
<pre class="source-code">
(buffer-start-mark buffer )  &amp;lt;==&amp;gt;  (region-start (buffer-region buffer))
</pre>
and
<pre class="source-code">
(buffer-end-mark buffer )  &amp;lt;==&amp;gt;  (region-end (buffer-region buffer))
</pre>
</p>
</div>
<a id="f_buffer-writable"></a>
<div class=definition>
<code>buffer-writable</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-writable"></a>
<p> </p>
</div>
<a id="hv_buffer_writable_hook"></a>
<div class=definition>
<code>buffer</code> <i>writable</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_writable_hook"></a>
<p>
This function returns t if you can modify the buffer, nil if you
cannot.  If a buffer is not writable, then any attempt to alter text
in the buffer results in an error.  There is a setf method to change
this value.  The setf method invokes the functions in Buffer Writable
Hook on the buffer and new value before storing the new value.
                    </p>
</div>
<a id="f_buffer-modified"></a>
<div class=definition>
<code>buffer-modified</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-modified"></a>
<p> </p>
</div>
<a id="hv_buffer_modified_hook"></a>
<div class=definition>
<code>buffer</code> <i>modified</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_modified_hook"></a>
<p>
buffer-modified returns t if the buffer has been modified, nil if it
hasn't.  This attribute is set whenever a text-altering operation is
performed on a buffer.  There is a setf method to change this value.
The setf method invokes the functions in Buffer Modified Hook with the
buffer whenever the value of the modified flag changes.
                    </p>
</div>
<a id="m_with-writable-buffer"></a>
<div class=definition>
<code>with-writable-buffer</code> <i>(buffer)</i> <code>&amp;body</code> <i>body</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-writable-buffer"></a>
<p>
This macro executes forms with buffer's writable status set.  After
forms execute, this resets the buffer's writable and modified status.
                    </p>
</div>
<a id="f_buffer-signature"></a>
<div class=definition>
<code>buffer-signature</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-signature"></a>
<p>
This function returns an arbitrary number which reflects the buffer's
current signature. The result is eql to a previous result if and only if
the buffer has not been modified between the calls.
                    </p>
</div>
<a id="f_buffer-variables"></a>
<div class=definition>
<code>buffer-variables</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-variables"></a>
<p>
This function returns a <a href="#string-table-functions">string-table</a> containing the names of
the buffer's local <a href="#hemlock-variables">variables</a>.
                    </p>
</div>
<a id="f_buffer-modes"></a>
<div class=definition>
<code>buffer-modes</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-modes"></a>
<p>
This function returns the list of the names of the modes active in
buffer. The major mode is first, followed by any minor modes.  See
the <a href="#modes">Modes</a> chapter.
                    </p>
</div>
<a id="f_buffer-delete-hook"></a>
<div class=definition>
<code>buffer-delete-hook</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-delete-hook"></a>
<p>
This function returns the list of buffer specific functions
delete-buffer invokes when deleting a buffer . This is setf-able.
                    </p>
</div>
<a id="f_delete-buffer"></a>
<div class=definition>
<code>delete-buffer</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-buffer"></a>
<p> </p>
</div>
<a id="hv_delete_buffer_hook"></a>
<div class=definition>
<code>delete</code> <i>buffer</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_delete_buffer_hook"></a>
<p>
delete-buffer removes buffer from (<a href="#f_all-buffers"><CODE>hemlock-interface:all-buffers</CODE></a>) and its name
from <a href="#v_buffer-names"><CODE>hi:*buffer-names*</CODE></a>.  Before buffer is deleted, this invokes
the functions on buffer returned by buffer-delete-hook and those found
in Delete Buffer Hook. If buffer is the current-buffer, or if it is
displayed in any view, then this function signals an error.
                    </p>
</div>
</div>
<a id="modelines"></a>
<H4>Modelines</H4>
<div class="section">
<p>
A Buffer may specify a modeline, a line of text which is displayed
across the bottom of a view to indicate status information.
Modelines are described by a list of modeline-field objects which have
individual update functions and are optionally fixed-width. These have
an eql name for convenience in referencing and updating, but the name
must be unique for all created modeline-field objects.  All modeline-field
functions must take a buffer as an
argument and return a string.  When displaying
a modeline-field with a specified width, the result of the update
function is either truncated or padded on the right to meet the
constraint.</p>
<p>Whenever one of the following changes occurs, all of a buffer's
modeline fields are updated:
            </p>
<ul><li><p>
A buffer's major mode is set.
                    </p>
<li><p>
One of a buffer's minor modes is turned on or off.
                    </p>
<li><p>
A buffer  is renamed.
                    </p>
<li><p>
A buffer's pathname changes.
                    </p>
<li><p>
A buffer's modified status changes.
                    </p>
</ul>
<p>
The policy is that whenever one of these changes occurs, it is
guaranteed that the modeline will be updated before the next trip
through redisplay.  Furthermore, since the system cannot know what
modeline-field objects the user has added whose update functions rely
on these values, or how he has changed Default Modeline Fields, we must
update all the fields.  </p>
<p>The user should note that modelines can be updated at any time, so
update functions should be careful to avoid needless delays (for
example, waiting for a local area network to determine information).
            </p>
<a id="f_make-modeline-field"></a>
<div class=definition>
<code>make-modeline-field</code> <code>&amp;key</code> <i>:name</i> <i>:width</i> <i>:function</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-modeline-field"></a>
<p>
This function returns a modeline-field object with name, width,
and function. Width defaults to nil meaning that the field is variable
width; otherwise, the programmer must supply this as a positive
integer. Function must take a buffer as an arguments and
return a string.  If name already names a modeline-field object,
then this signals an error.
                    </p>
</div>
<a id="f_modeline-field-name"></a>
<div class=definition>
<code>modeline-field-name</code> <i>modeline-field</i> <span class="definition-kind">[Function]</span><a id="description_in_f_modeline-field-name"></a>
<p>
This function returns the name field of a modeline-field object.
If this is set with setf, and the new name already names a
modeline-field, then the setf method signals an error.
                    </p>
</div>
<a id="f_modeline-field-p"></a>
<div class=definition>
<code>modeline-field-p</code> <i>modeline-field</i> <span class="definition-kind">[Function]</span><a id="description_in_f_modeline-field-p"></a>
<p>
This function returns t if its argument is a modeline-field object, nil
otherwise.
                    </p>
</div>
<a id="f_modeline-field"></a>
<div class=definition>
<code>modeline-field</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_modeline-field"></a>
<p>
This returns the modeline-field object named name. If none exists, this
returns nil.
                    </p>
</div>
<a id="f_modeline-field-function"></a>
<div class=definition>
<code>modeline-field-function</code> <i>modeline-field</i> <span class="definition-kind">[Function]</span><a id="description_in_f_modeline-field-function"></a>
<p>
Returns the function called when updating the modeline-field. When this
is set with setf, the setf method updates modeline-field for all views
on all buffers that contain the given field, so the next trip through
redisplay will reflect the change.  All modeline-field functions must
take a buffer as an argument and return a string.
                    </p>
</div>
<a id="f_modeline-field-width"></a>
<div class=definition>
<code>modeline-field-width</code> <i>modeline-field</i> <span class="definition-kind">[Function]</span><a id="description_in_f_modeline-field-width"></a>
<p>
Returns the width to which modeline-field is constrained, or nil
indicating that it is variable width.  When this is set with setf, the
setf method updates all modeline-fields for all views on all buffers
that contain the given field, so the next trip through redisplay will
reflect the change.
                    </p>
</div>
<a id="f_buffer-modeline-fields"></a>
<div class=definition>
<code>buffer-modeline-fields</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-modeline-fields"></a>
<p>
Returns a copy of the list of buffer's modeline-field objects. This
list can be destructively modified without affecting display of
buffer's modeline, but modifying any particular field's components
(for example, width or function) causes the changes to be reflected
the next trip through redisplay in every modeline display that uses
the modified modeline-field.  When this is set with setf, the setf
method method updates all modeline-fields on all views on the buffer,
so next trip through the redisplay will reflect the change.
                    </p>
</div>
<a id="f_buffer-modeline-field-p"></a>
<div class=definition>
<code>buffer-modeline-field-p</code> <i>buffer</i> <i>field</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-modeline-field-p"></a>
<p>
If field, a modeline-field or the name of one, is in buffer's list of
modeline-field objects, it is returned; otherwise, this returns nil.
                    </p>
</div>
<a id="f_update-modeline-fields"></a>
<div class=definition>
<code>update-modeline-fields</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_update-modeline-fields"></a>
<p>
Arranges so that the modeline display is updated with the latest values
at the end of current command.
                    </p>
</div>
</div>
</div>
<a id="altering-and-searching-text"></a>
<H3>Altering and Searching Text</H3>
<div class="section">
<p>
A note on marks and text alteration: :temporary marks are invalid
after any change has been made to the buffer the mark points to; it is
an error to use a temporary mark after such a change has been made.</p>
<p>If text is deleted which has permanent marks pointing into it then
they are left pointing to the position where the text was.
        </p>
<a id="altering-text"></a>
<H4>Altering Text</H4>
<div class="section">
<a id="f_insert-character"></a>
<div class=definition>
<code>insert-character</code> <i>mark</i> <i>character</i> <span class="definition-kind">[Function]</span><a id="description_in_f_insert-character"></a>
<p> </p>
</div>
<a id="f_insert-string"></a>
<div class=definition>
<code>insert-string</code> <i>mark</i> <i>string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_insert-string"></a>
<p> </p>
</div>
<a id="f_insert-region"></a>
<div class=definition>
<code>insert-region</code> <i>mark</i> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_insert-region"></a>
<p>
Inserts character, string or region at mark. <CODE>insert-character</CODE> signals
an error if character is not <CODE>string-char-p</CODE>. If string or region is
empty, and mark is in some buffer, then Hemlock leaves buffer-modified of
mark's buffer unaffected.
                    </p>
</div>
<a id="f_ninsert-region"></a>
<div class=definition>
<code>ninsert-region</code> <i>mark</i> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ninsert-region"></a>
<p>
Like <CODE>insert-region</CODE>, inserts the region at the mark's position,
destroying the source region.  This must be used with caution, since
if anyone else can refer to the source region bad things will
happen. In particular, one should make sure the region is not linked
into any existing buffer.  If region is empty, and mark is in some
buffer, then Hemlock leaves buffer-modified of mark's buffer unaffected.
                    </p>
</div>
<a id="f_delete-characters"></a>
<div class=definition>
<code>delete-characters</code> <i>mark</i> <i>n</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-characters"></a>
<p>
This deletes n characters after the mark (or -n before if n is
negative).  If n characters after (or -n before) the mark do not
exist, then this returns nil; otherwise, it returns t. If n is zero,
and mark is in some buffer, then Hemlock leaves buffer-modified of
mark's buffer unaffected.
                    </p>
</div>
<a id="f_delete-region"></a>
<div class=definition>
<code>delete-region</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-region"></a>
<p>
This deletes region. This is faster than delete-and-save-region
(below) because no lines are copied. If region is empty and contained
in some buffer's buffer-region, then Hemlock leaves buffer-modified of
the buffer unaffected.
                    </p>
</div>
<a id="f_delete-and-save-region"></a>
<div class=definition>
<code>delete-and-save-region</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-and-save-region"></a>
<p>
This deletes region and returns a region containing the original
region's text. If region is empty and contained in some buffer's
buffer-region, then Hemlock leaves buffer-modified of the buffer
unaffected. In this case, this returns a distinct empty region.
                    </p>
</div>
<a id="f_filter-region"></a>
<div class=definition>
<code>filter-region</code> <i>function</i> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_filter-region"></a>
<p>
Destructively modifies region by replacing the text of each line with
the result of the application of function to a string containing that
text. Function must obey the following restrictions:
                    </p>
<ol><li><p>
The argument may not be destructively modified.
                            </p>
<li><p>
The return value may not contain newline characters.
                            </p>
<li><p>
The return value may not be destructively modified after it is returned from function.
                            </p>
</ol>
<p>
The strings are passed in order.</p>
<p>Using this function, a region could be uppercased by doing:
                        <CODE>(filter-region #'string-upcase region)</CODE></p>
</div>
</div>
<a id="text-predicates"></a>
<H4>Text Predicates</H4>
<div class="section">
<a id="f_start-line-p"></a>
<div class=definition>
<code>start-line-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_start-line-p"></a>
<p>
Returns t if the mark points before the first character in a line, nil
otherwise.
                    </p>
</div>
<a id="f_end-line-p"></a>
<div class=definition>
<code>end-line-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_end-line-p"></a>
<p>
Returns t if the mark points after the last character in a line and
before the newline, nil otherwise.</p>
<p><CODE>empty-line-p</CODE> mark [Function]
Return t if the line which mark points to contains no characters.
                    </p>
</div>
<a id="f_blank-line-p"></a>
<div class=definition>
<code>blank-line-p</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_blank-line-p"></a>
<p>
Returns t if line contains only characters with a Whitespace attribute
of 1.  See the <a href="#character-attributes">Character Attributes</a>
chapter for discussion of character attributes.
                    </p>
</div>
<a id="f_blank-before-p"></a>
<div class=definition>
<code>blank-before-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_blank-before-p"></a>
<p> </p>
</div>
<a id="f_blank-after-p"></a>
<div class=definition>
<code>blank-after-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_blank-after-p"></a>
<p>
These functions test if all the characters preceding or following mark
on the line it is on have a Whitespace attribute of 1.
                    </p>
</div>
<a id="f_same-line-p"></a>
<div class=definition>
<code>same-line-p</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_same-line-p"></a>
<p>
Returns t if mark1 and mark2 point to the same line, or nil otherwise; That is,
<pre class="source-code">
(same-line-p a b) &amp;lt;==&amp;gt; (eq (mark-line a) (mark-line b))
</pre>
</p>
</div>
<a id="f_mark_lt"></a>
<div class=definition>
<code>mark&lt;</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_lt"></a>
<p> </p>
</div>
<a id="f_mark_le"></a>
<div class=definition>
<code>mark&lt;=</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_le"></a>
<p> </p>
</div>
<a id="f_mark_eq"></a>
<div class=definition>
<code>mark=</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_eq"></a>
<p> </p>
</div>
<a id="f_mark_ne"></a>
<div class=definition>
<code>mark/=</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_ne"></a>
<p> </p>
</div>
<a id="f_mark_ge"></a>
<div class=definition>
<code>mark&gt;=</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_ge"></a>
<p> </p>
</div>
<a id="f_mark_gt"></a>
<div class=definition>
<code>mark&gt;</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark_gt"></a>
<p>
These predicates test the relative ordering of two marks in a piece of
text, that is a mark is mark&gt; another if it points to a position after
it. An error is signalled if the marks do not point into the same buffer,
except that for such marks mark= is always false and mark/= is always true.
                    </p>
</div>
<a id="f_line_lt"></a>
<div class=definition>
<code>line&lt;</code> <i>line1</i> <i>line2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line_lt"></a>
<p> </p>
</div>
<a id="f_line_le"></a>
<div class=definition>
<code>line&lt;=</code> <i>line1</i> <i>line2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line_le"></a>
<p> </p>
</div>
<a id="f_line_ge"></a>
<div class=definition>
<code>line&gt;=</code> <i>line1</i> <i>line2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line_ge"></a>
<p> </p>
</div>
<a id="f_line_gt"></a>
<div class=definition>
<code>line&gt;</code> <i>line1</i> <i>line2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_line_gt"></a>
<p>
These predicates test the ordering of line1 and line2. An error is signalled
if the lines are not in the same buffer.
                    </p>
</div>
<a id="f_lines-related"></a>
<div class=definition>
<code>lines-related</code> <i>line1</i> <i>line2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_lines-related"></a>
<p>
This function returns t if line1 and line2 are in the same buffer, nil
nil otherwise.
                    </p>
</div>
<a id="f_first-line-p"></a>
<div class=definition>
<code>first-line-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_first-line-p"></a>
<p> </p>
</div>
<a id="f_last-line-p"></a>
<div class=definition>
<code>last-line-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_last-line-p"></a>
<p><CODE>first-line-p</CODE> returns t if there is no line before the line mark is on,
and nil otherwise. <CODE>Last-line-p</CODE> similarly tests tests whether there is
no line after mark.
                    </p>
</div>
</div>
<a id="kill-ring"></a>
<H4>Kill Ring</H4>
<div class="section">
<p>
There is a global <a href="#ring-functions">ring</a> of regions deleted from buffers.
Some commands save affected regions on the kill ring before performing
modifications.  You should consider making the command <a href="#undoing-commands">undoable</a>,
but this is a simple way of achieving a less
satisfactory means for the user to recover.
            </p>
<a id="f_kill-region"></a>
<div class=definition>
<code>kill-region</code> <i>region</i> <i>current-type</i> <span class="definition-kind">[Function]</span><a id="description_in_f_kill-region"></a>
<p>
This kills region saving it in the kill ring. Current-type is either
:kill-forward or :kill-backward. When the <a href="#f_last-command-type"><CODE>hemlock-interface:last-command-type</CODE></a>
is one of these, this adds region to the beginning or end,
respectively, of the top of the kill ring. The result of calling this is
undoable using the command Undo (see the Hemlock User's Manual). This
sets last-command-type to current-type, and it interacts with
kill-characters.
                    </p>
</div>
<a id="f_kill-characters"></a>
<div class=definition>
<code>kill-characters</code> <i>mark</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_kill-characters"></a>
<p> </p>
</div>
<a id="hv_character_deletion_threshold"></a>
<div class=definition>
<code>character</code> <i>deletion</i> <i>threshold</i>  (<i>initial</i> <i>value</i> <i>5</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_character_deletion_threshold"></a>
<p>
kill-characters kills count characters after mark if count is
positive, otherwise before mark if count is negative.  When count is
greater than or equal to Character Deletion Threshold, the killed
characters are saved on the kill ring. This may be called multiple times
contiguously (that is, without  <a href="#f_last-command-type"><CODE>hemlock-interface:last-command-type</CODE></a> being set)
to accumulate an effective count for purposes of comparison with the
threshold.
                    </p>
<p>
This sets last-command-type, and it interacts with kill-region. When
this adds a new region to the kill ring, it sets last-command-type to
:kill-forward (if count is positive) or :kill-backward (if count is
negative).  When last-command-type is :kill-forward or :kill-backward,
this adds the killed characters to the beginning (if count is
negative) or the end (if count is positive) of the top of the kill ring,
and it sets last-command-type as if it added a new region to the
kill ring. When the kill ring is unaffected, this sets
last-command-type to :char-kill-forward or :char-kill-backward
depending on whether count is positive or negative, respectively.</p>
<p>This returns mark if it deletes characters.  If there are not count
characters in the appropriate direction, this returns nil.
                    </p>
</div>
</div>
<a id="active-regions"></a>
<H4>Active Regions</H4>
<div class="section">
<p>
Every buffer has a mark stack and a mark known as the point
where most text altering nominally occurs.  Between the top of the
mark stack, the current-mark, and the current-buffer's point, the
current-point, is what is known as the current-region. Certain
commands signal errors when the user tries to operate on the
current-region without its having been activated.  If the user turns
off this feature, then the current-region is effectively always
active.</p>
<p>When writing a command that marks a region of text, the programmer
should make sure to activate the region.  This typically occurs
naturally from the primitives that you use to mark regions, but
sometimes you must explicitly activate the region.  These commands
should be written this way, so they do not require the user to
separately mark an area and then activate it.  Commands that modify
regions do not have to worry about deactivating the region since
modifying a buffer automatically deactivates the region.  Commands
that insert text often activate the region ephemerally; that is, the
region is active for the immediately following command, allowing the
user wants to delete the region inserted, fill it, or whatever.</p>
<p>Once a marking command makes the region active, it remains active until:
            </p>
<ul><li><p>
a command uses the region,
                    </p>
<li><p>
a command modifies the buffer,
                    </p>
<li><p>
a command changes the current window or buffer,
                    </p>
<li><p>
a command signals an editor-error,
                    </p>
<li><p>
or the user types C-g.
                    </p>
</ul>
<a id="hv_active_regions_enabled"></a>
<div class=definition>
<code>active</code> <i>regions</i> <i>enabled</i>  (<i>initial</i> <i>value</i> <i>t</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_active_regions_enabled"></a>
<p>
When this variable is non-nil, some primitives signal an editor-error
if the region is not active.  This may be set to nil for more
traditional Emacs region semantics.
                    </p>
</div>
<a id="v_ephemerally-active-command-types"></a>
<div class=definition>
<code>*ephemerally-active-command-types*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_ephemerally-active-command-types"></a>
<p>
This is a list of <a href="#command-types">Command Types</a>, and its initial
value is the list of :ephemerally-active and :unkill. When the
previous command's type is one of these, the current-region is active
for the currently executing command only, regardless of whether it
does something to deactivate the region.  However, the current command
may activate the region for future commands. :ephemerally-active is a
default command type that may be used to ephemerally activate the
region, and:unkill is the type used by two commands, Un-kill and
Rotate Kill Ring (what users typically think of as C-y and M-y).
                    </p>
</div>
<a id="f_activate-region"></a>
<div class=definition>
<code>activate-region</code> <span class="definition-kind">[Function]</span><a id="description_in_f_activate-region"></a>
<p>
This makes the current-region active.
                    </p>
</div>
<a id="f_deactivate-region"></a>
<div class=definition>
<code>deactivate-region</code> <span class="definition-kind">[Function]</span><a id="description_in_f_deactivate-region"></a>
<p>
After invoking this the current-region is no longer active.
                    </p>
</div>
<a id="f_region-active-p"></a>
<div class=definition>
<code>region-active-p</code> <span class="definition-kind">[Function]</span><a id="description_in_f_region-active-p"></a>
<p>
Returns whether the current-region is active, including
ephemerally. This ignores Active Regions Enabled.
                    </p>
</div>
<a id="f_check-region-active"></a>
<div class=definition>
<code>check-region-active</code> <span class="definition-kind">[Function]</span><a id="description_in_f_check-region-active"></a>
<p>
This signals an editor-error when active regions are enabled, and the
current-region is not active.
                    </p>
</div>
<a id="f_current-region"></a>
<div class=definition>
<code>current-region</code> <code>&amp;optional</code> <i>error-if-not-active</i> <i>deactivate-region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_current-region"></a>
<p>
This returns a region formed with current-mark and current-point,
optionally signaling an editor-error if the current region is not
active. Error-if-not-active defaults to t. Each call returns a
distinct region object.  Depending on deactivate-region (defaults to
t), fetching the current region deactivates it.  Hemlock primitives
are free to modify text regardless of whether the region is active, so
a command that checks for this can deactivate the region whenever it
is convenient.
                    </p>
</div>
</div>
<a id="searching-and-replacing"></a>
<H4>Searching and Replacing</H4>
<div class="section">
<p>
Before using any of these functions to do a character search, look at
<a href="#character-attributes">Character Attributes</a>.  They provide a facility similar to
the syntax table in real Emacs.  Syntax tables are a powerful,
general, and efficient mechanism for assigning meanings to characters
in various modes.
            </p>
<a id="f_new-search-pattern"></a>
<div class=definition>
<code>new-search-pattern</code> <i>kind</i> <i>direction</i> <i>pattern</i> <code>&amp;optional</code> <i>result-search-pattern</i> <span class="definition-kind">[Function]</span><a id="description_in_f_new-search-pattern"></a>
<p>
Returns a search-pattern object which can be given to the find-pattern
and replace-pattern functions. A search-pattern is a specification of
a particular sort of search to do. direction is either :forward or
:backward, indicating the direction to search in. kind specifies the
kind of search pattern to make, and pattern is a thing which specifies
what to search for.  The interpretation of pattern depends on the kind
of pattern being made.  Currently defined kinds of search pattern are:
                    </p>
<dl><dt>:string-insensitive</dt>
<dd><p>
Does a case-insensitive string search for pattern
                                </p>
</dd>
<dt>:string-sensitive</dt>
<dd><p>
Does a case-sensitive string search for pattern.
                                </p>
</dd>
<dt>:character</dt>
<dd><p>
Finds an occurrence of the character pattern. This is case sensitive.
                                </p>
</dd>
<dt>:not-character</dt>
<dd><p>
Find a character which is not the character pattern.
                                </p>
</dd>
<dt>:test</dt>
<dd><p>
Finds a character which satisfies the function pattern. This function may not be applied an any particular fashion, so it should depend only on what its argument is, and should have no side-effects.
                                </p>
</dd>
<dt>:test-not</dt>
<dd><p>
Similar to :test, except it finds a character that fails the test.
                                </p>
</dd>
<dt>:any</dt>
<dd><p>
Finds a character that is in the string pattern.
                                </p>
</dd>
<dt>:not-any</dt>
<dd><p>
Finds a character that is not in the string pattern.
                                </p>
</dd>
</dl>
<p>
result-search-pattern, if supplied, is a search-pattern to
destructively modify to produce the new pattern.  Where reasonable
this should be supplied, since some kinds of search patterns may
involve large data structures.
                    </p>
</div>
<a id="f_search-pattern-p"></a>
<div class=definition>
<code>search-pattern-p</code> <i>search-pattern</i> <span class="definition-kind">[Function]</span><a id="description_in_f_search-pattern-p"></a>
<p>
Returns t if search-pattern is a search-pattern object, otherwise nil.
                    </p>
</div>
<a id="f_get-search-pattern"></a>
<div class=definition>
<code>get-search-pattern</code> <i>string</i> <i>direction</i> <span class="definition-kind">[Function]</span><a id="description_in_f_get-search-pattern"></a>
<p>
get-search-pattern interfaces to a default search string and pattern
that search and replacing commands can use.  These commands then share
a default when prompting for what to search or replace, and save on
consing a search pattern each time they execute.  This uses Default
Search Kind (see the  Hemlock  User's Manual) when updating the pattern
object.
                    </p>
</div>
<a id="v_last-search-string"></a>
<div class=definition>
<code>*last-search-string*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_last-search-string"></a>
<p>
Returns the last string searched for, useful when prompting.
                    </p>
</div>
<a id="f_find-pattern"></a>
<div class=definition>
<code>find-pattern</code> <i>mark</i> <i>search-pattern</i> <span class="definition-kind">[Function]</span><a id="description_in_f_find-pattern"></a>
<p>
Find the next match of search-pattern starting at mark. If a match is
found then mark is altered to point before the matched text and the
number of characters matched is returned.  If no match is found then
nil is returned and mark is not modified.
                    </p>
</div>
<a id="f_replace-pattern"></a>
<div class=definition>
<code>replace-pattern</code> <i>mark</i> <i>search-pattern</i> <i>replacement</i> <code>&amp;optional</code> <i>n</i> <span class="definition-kind">[Function]</span><a id="description_in_f_replace-pattern"></a>
<p>
Replace n matches of search-pattern with the string replacement
starting at mark. If n is nil (the default) then replace all matches.
A mark pointing before the last replacement done is returned.
                    </p>
</div>
</div>
</div>
<a id="the-current-environment"></a>
<H3>The Current Environment</H3>
<div class="section">
<a id="different-scopes"></a>
<H4>Different Scopes</H4>
<div class="section">
<p>
In Hemlock the "current" values of <a href="#hemlock-variables">variables</a>,
<a href="#commands">key bindings</a> and
<a href="#character-attributes">character-attributes</a>
depend on the <a href="#the-current-buffer">current buffer</a>
and the modes active in it.  There are three possible scopes for
Hemlock values:
            </p>
<dl><dt>buffer local</dt>
<dd><p>
The value is present only if the buffer it is local to is the current buffer.
                        </p>
</dd>
<dt>mode local</dt>
<dd><p>
The value is present only when the mode it is local to is active in the current buffer.
                        </p>
</dd>
<dt>global</dt>
<dd><p>
The value is always present unless shadowed by a buffer or mode local value.
                        </p>
</dd>
</dl>
</div>
<a id="shadowing"></a>
<H4>Shadowing</H4>
<div class="section">
<p>
It is possible that there are different values for the same thing in 
in different scopes.  For example, there be might a global binding for a given
variable and also a local binding in the current buffer.  Whenever there is a
conflict, shadowing occurs, permitting only one of the values to be visible in
the current environment.</p>
<p>The process of resolving such a conflict can be described as a search
down a list of places where the value might be defined, returning the
first value found.  The order for the search is as follows:
            </p>
<ol><li><p>
Local values in the current buffer.
                    </p>
<li><p>
Mode local values in the minor modes of the current buffer, in order from the highest precedence mode to the lowest precedence mode.  The order of minor modes with equal precedences is undefined.
                    </p>
<li><p>
Mode local values in the current buffer's major mode.
                    </p>
<li><p>
Global values.
                    </p>
</ol>
</div>
</div>
<a id="hemlock-variables"></a>
<H3>Hemlock Variables</H3>
<div class="section">
<p>
Hemlock implements a system of variables separate from normal Lisp
variables for the following reasons:
        </p>
<ol><li><p>
Hemlock has different scoping rules which are useful in an editor.  Hemlock variables can be local to a <a href="#buffers">buffer</a> or a <a href="#modes">mode</a>.
                </p>
<li><p>
Hemlock variables have <a href="#mode-hooks">hooks</a>, lists of functions called when someone sets the variable. See variable-value for the arguments Hemlock passes to these hook functions.
                </p>
<li><p>
There is a database of variable names and documentation which makes it easier to find out what variables exist and what their values mean.
                </p>
</ol>
<a id="variable-names"></a>
<H4>Variable Names</H4>
<div class="section">
<p>
To the user, a variable name is a case insensitive string.  This
string is referred to as the string name of the variable. A string
name is conventionally composed of words separated by spaces.</p>
<p>In Lisp code a variable name is a symbol.  The name of this symbol is
created by replacing any spaces in the string name with hyphens.  This
symbol name is always interned in the Hemlock package.
            </p>
<a id="v_global-variable-names"></a>
<div class=definition>
<code>*global-variable-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_global-variable-names"></a>
<p>
This variable holds a string-table of the names of all the global
Hemlock variables. The value of each entry is the symbol name of the
variable.
                    </p>
</div>
<a id="f_current-variable-tables"></a>
<div class=definition>
<code>current-variable-tables</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-variable-tables"></a>
<p>
This function returns a list of variable tables currently established,
globally, in the current buffer, and by the modes of the
current-buffer. This list is suitable for use with
prompt-for-variable.
                    </p>
</div>
</div>
<a id="variable-functions"></a>
<H4>Variable Functions</H4>
<div class="section">
<p>
In the following descriptions name is the symbol name of the variable.
            </p>
<a id="f_defhvar"></a>
<div class=definition>
<code>defhvar</code> <i>string-name</i> <i>documentation</i> <code>&amp;key</code> <i>:mode</i> <i>:buffer</i> <i>:hooks</i> <i>:value</i> <span class="definition-kind">[Function]</span><a id="description_in_f_defhvar"></a>
<p>
This function defines a Hemlock variable. Functions that take a
variable name signal an error when the variable is undefined.
                    </p>
<dl><dt><I>string-name</I></dt>
<dd><p>
The string name of the variable to define.
                                </p>
</dd>
<dt><I>documentation</I></dt>
<dd><p>
The documentation string for the variable.
                                </p>
</dd>
<dt><I>mode</I>, <I>buffer</I></dt>
<dd><p>
If buffer is supplied, the variable is local to that buffer.  If mode is supplied, it is local to that mode.  If neither is supplied, it is global.
                                </p>
</dd>
<dt><I>value</I></dt>
<dd><p>
This is the initial value for the variable, which defaults to nil.
                                </p>
</dd>
<dt><I>hooks</I></dt>
<dd><p>
This is the initial list of functions to call when someone sets the variable's value. These functions execute before Hemlock establishes the new value. See variable-value for the arguments passed to the hook functions.
                                </p>
</dd>
</dl>
<p>
If a variable with the same name already exists in the same place,
then defhvar sets its hooks and value from hooks and value if the user
supplies these keywords.
                    </p>
</div>
<a id="f_variable-value"></a>
<div class=definition>
<code>variable-value</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_variable-value"></a>
<p>
This function returns the value of a Hemlock variable in some place. The following values for kind are defined:
                    </p>
<dl><dt>:current</dt>
<dd><p>
Return the value present in the current environment, taking into consideration any mode or buffer local variables.  This is the default.
                                </p>
</dd>
<dt>:global</dt>
<dd><p>
Return the global value.
                                </p>
</dd>
<dt>:mode</dt>
<dd><p>
Return the value in the mode named where.
                                </p>
</dd>
<dt>:buffer</dt>
<dd><p>
Return the value in the buffer where.
                                </p>
</dd>
</dl>
<p>
When set with setf, Hemlock sets the value of the specified variable
and invokes the functions in its hook list with name, kind, where, and
the new value.
                    </p>
</div>
<a id="f_variable-documentation"></a>
<div class=definition>
<code>variable-documentation</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_variable-documentation"></a>
<p> </p>
</div>
<a id="f_variable-hooks"></a>
<div class=definition>
<code>variable-hooks</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_variable-hooks"></a>
<p> </p>
</div>
<a id="f_variable-name"></a>
<div class=definition>
<code>variable-name</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_variable-name"></a>
<p>
These function return the documentation, hooks and string name of a
Hemlock variable. The kind and where arguments are the same as for
variable-value. The documentation and hook list may be set using setf.
                    </p>
</div>
<a id="f_string-to-variable"></a>
<div class=definition>
<code>string-to-variable</code> <i>string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_string-to-variable"></a>
<p>
This function converts a string into the corresponding variable symbol
name. String need not be the name of an actual Hemlock variable.
                    </p>
</div>
<a id="m_value"></a>
<div class=definition>
<code>value</code> <i>name</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_value"></a>
<p> </p>
</div>
<a id="m_setv"></a>
<div class=definition>
<code>setv</code> <i>name</i> <i>new-value</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_setv"></a>
<p>
These macros get and set the current value of the Hemlock variable
name. Name is not evaluated.  There is a setf form for <CODE>value</CODE>.
                    </p>
</div>
<a id="m_hlet"></a>
<div class=definition>
<code>hlet</code>  (<i>{(var</i> <i>value)}*){form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_hlet"></a>
<p>
This macro is very similar to let in effect; within its scope each of
the Hemlock variables var have the respective values, but after the
scope is exited by any means the binding is removed.  This does not
cause any hooks to be invoked.  The value of the last form is
returned.
                    </p>
</div>
<a id="f_hemlock-bound-p"></a>
<div class=definition>
<code>hemlock-bound-p</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_hemlock-bound-p"></a>
<p>
Returns t if name is defined as a Hemlock variable in the place
specified by kind and where, or nil otherwise.
                    </p>
</div>
<a id="f_delete-variable"></a>
<div class=definition>
<code>delete-variable</code> <i>name</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-variable"></a>
<p> </p>
</div>
<a id="hv_delete_variable_hook"></a>
<div class=definition>
<code>delete</code> <i>variable</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_delete_variable_hook"></a>
<p>
delete-variable makes the Hemlock variable name no longer defined in
the specified place. Kind and where have the same meanings as they do
for variable-value, except that :current is not available, and the
default for kind is :global</p>
<p>An error will be signaled if no such variable exists.  The hook,
Delete Variable Hook is invoked with the same arguments before the
variable is deleted.
                    </p>
</div>
</div>
<a id="hooks"></a>
<H4>Hooks</H4>
<div class="section">
<p>
Hemlock actions such as setting variables, changing buffers, changing
windows, turning modes on and off, etc., often have hooks associated
with them.  A hook is a list of functions called before the system
performs the action.  The manual describes the object specific hooks
with the rest of the operations defined on these objects.</p>
<p>Often hooks are stored in Hemlock variables, Delete Buffer Hook and
Set Window Hook for example.  This leads to a minor point of confusion
because these variables have hooks that the system executes when
someone changes their values.  These hook functions Hemlock invokes
when someone sets a variable are an example of a hook stored in an
object instead of a Hemlock variable. These are all hooks for editor
activity, but Hemlock keeps them in different kinds of locations.
This is why some of the routines in this section have a special
interpretation of the hook place argument.
            </p>
<a id="m_add-hook"></a>
<div class=definition>
<code>add-hook</code> <i>place</i> <i>hook-fun</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_add-hook"></a>
<p> </p>
</div>
<a id="m_remove-hook"></a>
<div class=definition>
<code>remove-hook</code> <i>place</i> <i>hook-fun</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_remove-hook"></a>
<p>
These macros add or remove a hook function in some place. If hook-fun
already exists in place, this call has no effect.  If place is a
symbol, then it is a Hemlock variable; otherwise, it is a generalized
variable or storage location.  Here are two examples:
                    </p>
<pre class="source-code">
(add-hook delete-buffer-hook 'remove-buffer-from-menu)
(add-hook (variable-hooks 'check-mail-interval)
          'reschedule-mail-check)
</pre>
</div>
<a id="m_invoke-hook"></a>
<div class=definition>
<code>invoke-hook</code> <i>place</i> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_invoke-hook"></a>
<p>
This macro calls all the functions in place. If place is a symbol,
then it is a Hemlock variable; otherwise, it is a generalized
variable.
                    </p>
</div>
</div>
</div>
<a id="commands"></a>
<H3>Commands</H3>
<div class="section">
<a id="introduction_in_commands"></a>
<H4>Introduction</H4>
<div class="section">
<p>
The way that the user tells Hemlock to do something is by invoking a
command. Commands have three attributes:
            </p>
<dl><dt>name</dt>
<dd><p>
A command's name provides a way to refer to it.  Command names are
usually capitalized words separated by spaces, such as Forward Word.
                        </p>
</dd>
<dt>documentation</dt>
<dd><p>
The documentation for a command is used by on-line help facilities.
                        </p>
</dd>
<dt>function</dt>
<dd><p>
A command is implemented by a Lisp function, which is callable from Lisp.
                        </p>
</dd>
</dl>
<a id="defining-commands"></a>
<H5>Defining Commands</H5>
<div class="section">
<a id="v_command-names"></a>
<div class=definition>
<code>*command-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_command-names"></a>
<p>
Holds a <a href="#string-table-functions">string-table</a> associating command names to command
objects.  Whenever a new command is defined it is entered in this
table.
                    </p>
</div>
<a id="m_defcommand"></a>
<div class=definition>
<code>defcommand</code> <i>{command-name</i> <i>|</i>  (<i>command-name</i> <i>function-name</i> <i>&amp;amp;key)}</i> <i>lambda-list</i> <i>command-doc</i> <i>{function-doc}</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_defcommand"></a>
<p>
Defines a command named name. defcommand creates a function to
implement the command from the lambda-list and forms supplied.  The
lambda-list must specify one required argument, see <a href="#command-arguments">below</a>,
which by convention is typically named <CODE>p</CODE>. If the caller does not specify
function-name, defcommand creates the command name by replacing all
spaces with hyphens and appending "-command".  Any keyword arguments
are as for <CODE>make-command</CODE>.  Command-doc becomes the command
documentation for the command.  Function-doc, if present, becomes the
documentation for the function and should primarily describe
issues involved in calling the command as a function, such as what any
additional arguments are. 
                            </p>
</div>
<a id="f_make-command"></a>
<div class=definition>
<code>make-command</code> <i>name</i> <i>documentation</i> <i>function</i> <code>&amp;key</code> <i>:transparent-p</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-command"></a>
<p>
Defines a new command named name, with command documentation
documentation and function function.  If :transparent-p is true,
the command becomes <a href="#transparent-key-bindings">transparent</a>.
The command in entered in the
string-table <a href="#v_command-names"><CODE>hemlock-interface:*command-names*</CODE></a>, with the command object as its
value.  Normally command implementors will use the defcommand macro,
but this permits access to the command definition mechanism at a lower
level, which is occasionally useful.
                            </p>
</div>
<a id="f_commandp"></a>
<div class=definition>
<code>commandp</code> <i>command</i> <span class="definition-kind">[Function]</span><a id="description_in_f_commandp"></a>
<p>
Returns t if command is a command object, otherwise nil.
                            </p>
</div>
<a id="f_command-documentation"></a>
<div class=definition>
<code>command-documentation</code> <i>command</i> <span class="definition-kind">[Function]</span><a id="description_in_f_command-documentation"></a>
<p> </p>
</div>
<a id="f_command-function"></a>
<div class=definition>
<code>command-function</code> <i>command</i> <span class="definition-kind">[Function]</span><a id="description_in_f_command-function"></a>
<p> </p>
</div>
<a id="f_command-name"></a>
<div class=definition>
<code>command-name</code> <i>command</i> <span class="definition-kind">[Function]</span><a id="description_in_f_command-name"></a>
<p>
Returns the documentation, function, or name for command. These may be
set with setf.
                            </p>
</div>
</div>
<a id="command-documentation"></a>
<H5>Command Documentation</H5>
<div class="section">
<p>
Command documentation is a description of what the command does when
it is invoked as an extended command or from a key.  Command
documentation may be either a string or a function.  If the
documentation is a string then the first line should briefly summarize
the command, with remaining lines filling the details.  Example:
                    </p>
<pre class="source-code">
(defcommand "Forward Character" (p)
  "Move the point forward one character.
   With prefix argument move that many characters, with negative
   argument go backwards."
. . .)
</pre>
<p>
Command documentation may also be a function of one argument.  The
function is called with either :short or :full, indicating that the
function should return a short documentation string or do something
to document the command fully.
                    </p>
</div>
</div>
<a id="the-command-interpreter"></a>
<H4>The Command Interpreter</H4>
<div class="section">
<p>
The command interpreter is the functionality invoked by the event
handler to process key-events from the keyboard and dispatch to
different commands on the basis of what the user types.  When the
command interpreter executes a command, we say it invokes the command.  The
command interpreter also provides facilities for communication between
contiguously running commands, such as a last command type register.
It also takes care of resetting communication mechanisms, clearing the
echo area, displaying partial keys typed slowly by the user, etc.
            </p>
<a id="controlling-the-command-interpreter"></a>
<H5>Controlling The Command Interpreter</H5>
<div class="section">
<a id="hv_command_abort_hook"></a>
<div class=definition>
<code>command</code> <i>abort</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_command_abort_hook"></a>
<p>
The command interpreter invokes the function in this variable whenever
someone aborts a command (for example, if someone called
editor-error).
                    </p>
</div>
</div>
<a id="editor-input"></a>
<H5>Editor Input</H5>
<div class="section">
<p>
The canonical representation of editor input is a key-event structure.
Users can bind commands to keys, which are
non-empty sequences of key-events. A key-event consists of an
identifying token known as a keysym and a field of bits representing
modifiers.  Users define keysym names by supplying names that reflect
the legends on their keyboard's keys. Users define modifier names
similarly, but the system chooses the bit and mask for recognizing the
modifier.  You can use keysym and modifier names to textually specify
key-events and Hemlock keys in a #k syntax. The following are some
examples:
                    </p>
<pre class="source-code">
#k"C-u"
#k"Control-u"
#k"c-m-z"
#k"control-x meta-d"
#k"a"
#k"A"
#k"Linefeed"
</pre>
<p>
This is convenient for use within code and in init files
containing <CODE>bind-key</CODE> calls.</p>
<p>The #k syntax is delimited by double quotes.  Within the
double quotes, spaces separate multiple key-events.  A single
key-event optionally starts with modifier names terminated by hyphens.
Modifier names are alphabetic sequences of characters which the system
uses case-insensitively. Following modifiers is a keysym name, which
is case-insensitive if it consists of multiple characters, but if the
name consists of only a single character, then it is case-sensitive.</p>
<p>You can escape special characters---hyphen, double quote, open angle
bracket, close angle bracket, and space---with a backslash, and you
can specify a backslash by using two contiguously.  You can use angle
brackets to enclose a keysym name with many special characters in it.
Between angle brackets appearing in a keysym name position, there are
only two special characters, the closing angle bracket and backslash.</p>
<p>For more information on key-events see the <a href="#key-events">Key-events</a> section.
                    </p>
</div>
<a id="binding-commands-to-keys"></a>
<H5>Binding Commands to Keys</H5>
<div class="section">
<p>
The command interpreter determines which command to invoke on the
basis of <EMPH>key bindings</EMPH>. A key binding is an association between a
command and a sequence of key-events.  A sequence
of key-events is called a key and is represented by a single key-event
or a sequence (list or vector) of key-events.
                    </p>
<p>
Since key bindings may be local to a mode or buffer, the <a href="#the-current-environment">current environment</a> determines the set of key bindings in effect at
any given time.  When the command interpreter tries to find the
binding for a key, it first checks if there is a local binding in
the <a href="#the-current-buffer">current buffer</a>, then if there is a binding in each of the
minor modes and the major <a href="#modes">mode</a> for the current buffer, and
finally checks to see if there is a global binding.  If no binding is
found, then the command interpreter beeps or flashes the screen to
indicate this.
                    </p>
<a id="f_bind-key"></a>
<div class=definition>
<code>bind-key</code> <i>name</i> <i>key</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_bind-key"></a>
<p>
This function associates command name and key in some environment. Key
is either a key-event or a sequence of key-events.  There are three
possible values of kind:
                            </p>
<dl><dt>:global</dt>
<dd><p>
The default, make a global key binding.
                                        </p>
</dd>
<dt>:mode</dt>
<dd><p>
Make a mode specific key binding in the mode whose name is where.
                                        </p>
</dd>
<dt>:buffer</dt>
<dd><p>
Make a binding which is local to buffer where.
                                        </p>
</dd>
</dl>
<p>
This processes key for <a href="#key-translation">key translations</a> before establishing the
binding.
                            </p>
<p>
If the key is some prefix of a key binding which already exists in the
specified place, then the new one will override the old one,
effectively deleting it.</p>
<p><CODE>do-alpha-key-events</CODE> is useful for setting up bindings in certain new modes.
                            </p>
</div>
<a id="f_command-bindings"></a>
<div class=definition>
<code>command-bindings</code> <i>command</i> <span class="definition-kind">[Function]</span><a id="description_in_f_command-bindings"></a>
<p>
This function returns a list of the places where command is bound.  A
place is specified as a list of the key (always a vector), the kind of
binding, and where (either the mode or buffer to which the binding is
local, or nil if it is a global).
                            </p>
</div>
<a id="f_delete-key-binding"></a>
<div class=definition>
<code>delete-key-binding</code> <i>key</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-key-binding"></a>
<p>
This function removes the binding of key in some place. Key is either
a key-event or a sequence of key-events. kind is the kind of binding
to delete, one of :global(the default), :mode or :buffer. If kind is
:mode, where is the mode name, and if kind is :buffer, then where is
the buffer.</p>
<p>This function signals an error if key is unbound.
                            </p>
<p>
This processes key for <a href="#key-translation">key translations</a> before deleting the binding.
                            </p>
</div>
<a id="f_get-command"></a>
<div class=definition>
<code>get-command</code> <i>key</i> <code>&amp;optional</code> <i>kind</i> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_get-command"></a>
<p>
This function returns the command bound to key, returning nil if it is
unbound. Key is either a key-event or a sequence of key-events.  If
key is an initial subsequence of some keys, then this returns the
keyword :prefix. There are four cases of kind:
                            </p>
<dl><dt>:current</dt>
<dd><p>
Return the current binding of key using the current buffer's search
list.  If there are any transparent key bindings for key, then they
are returned in a list as a second value.
                                        </p>
</dd>
<dt>:global</dt>
<dd><p>
Return the global binding of key. This is the default.
                                        </p>
</dd>
<dt>:mode</dt>
<dd><p>
Return the binding of key in the mode named where.
                                        </p>
</dd>
<dt>:buffer</dt>
<dd><p>
Return the binding of key local to the buffer where.
                                        </p>
</dd>
</dl>
<p>
This processes key for <a href="#key-translation">key translations</a> before looking for any
binding.
                            </p>
</div>
<a id="f_map-bindings"></a>
<div class=definition>
<code>map-bindings</code> <i>function</i> <i>kind</i> <code>&amp;optional</code> <i>where</i> <span class="definition-kind">[Function]</span><a id="description_in_f_map-bindings"></a>
<p>
This function maps over the key bindings in some place.  For each
binding, this passes function the key and the command bound to
it. Kind and where are the same as in bind-key. The key is not
guaranteed to remain valid after a given iteration.
                            </p>
</div>
</div>
<a id="key-translation"></a>
<H5>Key Translation</H5>
<div class="section">
<p>
Key translation is a process that the command interpreter applies to
keys before doing anything else.  There are two kinds of key
translations: substitution and bit-prefix. In either case, the command
interpreter translates a key when a specified key-event sequence
appears in a key.</p>
<p>In a substitution translation, the system replaces the matched
subsequence with another key-event sequence. Key translation is not
recursively applied to the substituted key-events.</p>
<p>In a bit-prefix translation, the system removes the matched
subsequence and effectively sets the specified bits in the next
key-event in the key.</p>
<p>While translating a key, if the system encounters an incomplete final
subsequence of key-events, it aborts the translation process.  This
happens when those last key-events form a prefix of some
translation. It also happens when they translate to a bit-prefix, but
there is no following key-event to which the system can apply the
indicated modifier. If there is a binding for this partially
untranslated key, then the command interpreter will invoke that
command; otherwise, it will wait for the user to type more key-events.
                    </p>
<a id="f_key-translation"></a>
<div class=definition>
<code>key-translation</code> <i>key</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-translation"></a>
<p>
This form is setf-able and allows users to register key translations
that the command interpreter will use as users type key-events.</p>
<p>This function returns the key translation for key, returning nil if
there is none. Key is either a key-event or a sequence of key-events.
If key is a prefix of a translation, then this returns :prefix.</p>
<p>A key translation is either a key or modifier specification. The bits
translations have a list form: (:bits {bit-name}*).</p>
<p>Whenever key appears as a subsequence of a key argument to the binding
manipulation functions, that portion will be replaced with the
translation.
                            </p>
</div>
</div>
<a id="transparent-key-bindings"></a>
<H5>Transparent Key Bindings</H5>
<div class="section">
<p>
Key bindings local to a mode may be transparent. A transparent key
binding does not shadow less local key bindings, but rather indicates
that the bound command should be invoked before the first normal key
binding.  Transparent key bindings are primarily useful for
implementing minor modes such as auto fill and word
abbreviation. There may be several transparent key bindings for a
given key, in which case all of the transparent commands are invoked in the
order they were found. If there no normal key binding for a key typed,
then the command interpreter acts as though the key is unbound even if
there are transparent key bindings.
                    </p>
<p>
The :transparent-p argument to <a href="#f_defmode"><CODE>hemlock-interface:defmode</CODE></a> determines whether
all the key bindings in a mode are transparent or not.  In addition
a particular command may be declared to be transparent by the
:transparent-p argument to defcommand and make-command.
                    </p>
</div>
</div>
<a id="command-types"></a>
<H4>Command Types</H4>
<div class="section">
<p>
In many editors the behavior of a command depends on the kind of
command invoked before it. Hemlock provides a mechanism to support
this known as <CODE>command type</CODE>.
            </p>
<a id="f_last-command-type"></a>
<div class=definition>
<code>last-command-type</code> <span class="definition-kind">[Function]</span><a id="description_in_f_last-command-type"></a>
<p>
This returns the command type of the last command invoked. If this is
set with setf, the supplied value becomes the value of
last-command-type until the next command completes.  If the previous
command did not set last-command-type, then its value is nil. Normally
a command type is a keyword. The command type is not cleared after a
command is invoked due to a transparent key binding.
                    </p>
</div>
</div>
<a id="command-arguments"></a>
<H4>Command Arguments</H4>
<div class="section">
<p>
There are three ways in which a command may be invoked: It may be
bound to a key which has been typed, it may be invoked as an extended
command, or it may be called as a Lisp function.  Ideally commands
should be written in such a way that they will behave sensibly no
matter which way they are invoked. The functions which implement
commands must obey certain conventions about argument passing if the
command is to function properly.
            </p>
<a id="the-prefix-argument"></a>
<H5>The Prefix Argument</H5>
<div class="section">
<p>
Whenever a command is invoked it is passed as its first argument what
is known as the prefix argument. The prefix argument is always either
an integer or nil. When a command uses this value it is usually as a
repeat count, or some conceptually similar function.
                </p>
<a id="f_prefix-argument"></a>
<div class=definition>
<code>prefix-argument</code> <span class="definition-kind">[Function]</span><a id="description_in_f_prefix-argument"></a>
<p>
This function returns the current value of the prefix argument.  When
set with setf, the new value becomes the prefix argument for the next
command.  If the prefix argument is not set by the previous command
then the prefix argument for a command is nil. The prefix argument is
not cleared after a command is invoked due to a transparent key
binding.
                        </p>
</div>
</div>
<a id="lisp-arguments"></a>
<H5>Lisp Arguments</H5>
<div class="section">
<p>
It is often desirable to call commands from Lisp code, in which case
arguments which would otherwise be prompted for are passed as optional
arguments following the prefix argument.  A command should prompt for
any arguments not supplied.
                </p>
</div>
</div>
</div>
<a id="modes"></a>
<H3>Modes</H3>
<div class="section">
<p>
A mode is a collection of Hemlock values which may be present in the
<a href="#the-current-environment">current environment</a> depending on the editing task at hand.
An example of a typical mode is Lisp, for editing Lisp code.
        </p>
<a id="mode-hooks"></a>
<H4>Mode Hooks</H4>
<div class="section">
<p>
When a mode is added to or removed from a buffer, its mode hook is
invoked.  The hook functions take two arguments, the buffer involved
and t if the mode is being added or nil if it is being removed.  Mode
hooks are typically used to make a mode do something additional to
what it usually does.  One might, for example, make a Text mode hook
that turned on auto-fill mode when you entered.
            </p>
</div>
<a id="major-and-minor-modes"></a>
<H4>Major and Minor Modes</H4>
<div class="section">
<p>
There are two kinds of modes, major modes and minor modes. A buffer
always has exactly one major mode, but it may have any number of minor
modes.  Major modes may have mode character attributes while minor
modes may not.</p>
<p>A major mode is usually used to change the environment in some major
way, such as to install special commands for editing some language.
Minor modes generally change some small attribute of the environment,
such as whether lines are automatically broken when they get too long.
A minor mode should work regardless of what major mode and minor modes
are in effect.
            </p>
<a id="hv_default_modes"></a>
<div class=definition>
<code>default</code> <i>modes</i>  (<i>initial</i> <i>value</i> <i>&amp;#039;(&amp;quot;fundamental&amp;quot;</i> <i>&amp;quot;save&amp;quot;</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_default_modes"></a>
<p>
This variable contains a list of mode names which are instantiated in
a buffer when no other information is available.
                    </p>
</div>
<a id="v_mode-names"></a>
<div class=definition>
<code>*mode-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_mode-names"></a>
<p>
Holds a string-table of the names of all the modes.
                    </p>
</div>
<a id="hc_illegal"></a>
<div class=definition>
<code>illegal</code> <span class="definition-kind">[Hemlock Command]</span><a id="description_in_hc_illegal"></a>
<p>
This is a useful command to bind in modes that wish to shadow global
bindings by making them effectively illegal.  Also, although less
likely, minor modes may shadow major mode bindings with this.  This
command calls editor-error.
                    </p>
</div>
</div>
<a id="mode-functions"></a>
<H4>Mode Functions</H4>
<div class="section">
<a id="f_defmode"></a>
<div class=definition>
<code>defmode</code> <i>name</i> <code>&amp;key</code> <i>:setup-function</i> <i>:cleanup-function</i> <i>:major-p</i> <i>:precedence</i> <i>:transparent-p</i> <i>:documentation</i> <span class="definition-kind">[Function]</span><a id="description_in_f_defmode"></a>
<p>
This function defines a new mode named name, and enters it in
<a href="#v_mode-names"><CODE>hemlock-interface:*mode-names*</CODE></a>.  If major-p is supplied and is not nil then
the mode is a major mode; otherwise it is a minor mode.
                    </p>
<p>
Setup-function and cleanup-function are functions which are invoked
with the buffer affected, after the mode is turned on, and before it
is turned off, respectively.  These functions typically are used to
make buffer-local key or variable bindings and to remove them when the
mode is turned off.</p>
<p>Precedence is only meaningful for a minor mode.  The precedence of a
minor mode determines the order in which it in a buffer's list of
modes.  When searching for values in the current environment, minor
modes are searched in order, so the precedence of a minor mode
determines which value is found when there are several definitions.</p>
<p>Transparent-p determines whether key bindings local to the defined mode
are transparent.  Transparent key bindings are invoked in addition to
the first normal key binding found rather than shadowing less local
key bindings.</p>
<p>Documentation is some introductory text about the mode.  Commands such
as Describe Mode use this.
                    </p>
</div>
<a id="f_mode-documentation"></a>
<div class=definition>
<code>mode-documentation</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mode-documentation"></a>
<p>
This function returns the documentation for the mode named name.
                    </p>
</div>
<a id="f_buffer-major-mode"></a>
<div class=definition>
<code>buffer-major-mode</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-major-mode"></a>
<p> </p>
</div>
<a id="hv_buffer_major_mode_hook"></a>
<div class=definition>
<code>buffer</code> <i>major</i> <i>mode</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_major_mode_hook"></a>
<p>
buffer-major-mode returns the name of buffer's major mode.  The major
mode may be changed with setf; then Buffer Major Mode Hook is invoked
with buffer and the new mode.
                    </p>
</div>
<a id="f_buffer-minor-mode"></a>
<div class=definition>
<code>buffer-minor-mode</code> <i>buffer</i> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-minor-mode"></a>
<p> </p>
</div>
<a id="hv_buffer_minor_mode_hook"></a>
<div class=definition>
<code>buffer</code> <i>minor</i> <i>mode</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_buffer_minor_mode_hook"></a>
<p>
buffer-minor-mode returns t if the minor mode name is active in
buffer, nil otherwise. A minor mode may be turned on or off by using
setf; then Buffer Minor Mode Hook is invoked with buffer, name and the
new value.
                    </p>
</div>
<a id="f_mode-variables"></a>
<div class=definition>
<code>mode-variables</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mode-variables"></a>
<p>
Returns the string-table of mode local variables.
                    </p>
</div>
<a id="f_mode-major-p"></a>
<div class=definition>
<code>mode-major-p</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mode-major-p"></a>
<p>
Returns t if name is the name of a major mode, or nil if it is the
name of a minor mode.  It is an error for name not to be the name of a
mode.
                    </p>
</div>
</div>
</div>
<a id="character-attributes"></a>
<H3>Character Attributes</H3>
<div class="section">
<a id="introduction_in_character-attributes"></a>
<H4>Introduction</H4>
<div class="section">
<p>
Character attributes provide a global database of information about
characters.  This facility is similar to, but more general than, the
syntax tables of other editors such as Emacs. For example, you should
use character attributes for commands that need information regarding
whether a character is whitespace or not.  Use character attributes
for these reasons:
            </p>
<ol><li><p>
If this information is all in one place, then it is easy the
change the behavior of the editor by changing the syntax table,
much easier than it would be if character constants were wired
into commands.
                    </p>
</ol>
<ol><li><p>
This centralization of information avoids needless duplication of effort.
                    </p>
</ol>
<ol><li><p>
The syntax table primitives are probably faster than anything that
can be written above the primitive level.
                    </p>
</ol>
<p>
Note that an essential part of the character attribute scheme is that
character attributes are global and are there for the user to
change. Information about characters which is internal to some set of
commands (and which the user should not know about) should not be
maintained as a character attribute.  For such uses various character
searching abilities are provided by the function <a href="#f_find-pattern"><CODE>hemlock-interface:find-pattern</CODE></a>.
20).
            </p>
</div>
<a id="character-attribute-names"></a>
<H4>Character Attribute Names</H4>
<div class="section">
<p>
As for Hemlock variables, character attributes have a user visible
string name, but are referred to in Lisp code as a symbol.  The string
name, which is typically composed of capitalized words separated by
spaces, is translated into a keyword by replacing all spaces with
hyphens and interning this string in the keyword package.  The
attribute named "Ada Syntax" would thus become :ada-syntax.
            </p>
<a id="v_character-attribute-names"></a>
<div class=definition>
<code>*character-attribute-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_character-attribute-names"></a>
<p>
Whenever a character attribute is defined, its name is entered in this
<a href="#string-table-functions">string-table</a>, with the corresponding keyword as the value.
                    </p>
</div>
</div>
<a id="character-attribute-functions"></a>
<H4>Character Attribute Functions</H4>
<div class="section">
<a id="f_defattribute"></a>
<div class=definition>
<code>defattribute</code> <i>name</i> <i>documentation</i> <code>&amp;optional</code> <i>type</i> <i>initial-value</i> <span class="definition-kind">[Function]</span><a id="description_in_f_defattribute"></a>
<p>
This function defines a new character attribute with name, a
string.  Character attribute operations take attribute
arguments as a keyword whose name is name uppercased with spaces
replaced by hyphens.</p>
<p>Documentation describes the uses of the character attribute.</p>
<p>Type, which defaults to (mod 2), specifies what type the values of the
character attribute are.  Values of a character attribute may be of
any type which may be specified to make-array. Initial-value (default
0) is the value which all characters will initially have for this
attribute.
                    </p>
</div>
<a id="f_character-attribute-name"></a>
<div class=definition>
<code>character-attribute-name</code> <i>attribute</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-attribute-name"></a>
<p> </p>
</div>
<a id="f_character-attribute-documentation"></a>
<div class=definition>
<code>character-attribute-documentation</code> <i>attribute</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-attribute-documentation"></a>
<p>
These functions return the name or documentation for attribute.
                    </p>
</div>
<a id="f_character-attribute"></a>
<div class=definition>
<code>character-attribute</code> <i>attribute</i> <i>character</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-attribute"></a>
<p> </p>
</div>
<a id="hv_character_attribute_hook"></a>
<div class=definition>
<code>character</code> <i>attribute</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_character_attribute_hook"></a>
<p>
character-attribute returns the value of attribute for character. This
signals an error if attribute is undefined.</p>
<p>setf will set a character's attributes.  This setf method invokes the
functions in Character Attribute Hook on the attribute and character
before it makes the change.</p>
<p>If character is nil, then the value of the attribute for the beginning
or end of the buffer can be accessed or set.  The buffer beginning and
end thus become a sort of fictitious character, which simplifies the
use of character attributes in many cases.
                    </p>
</div>
<a id="f_character-attribute-p"></a>
<div class=definition>
<code>character-attribute-p</code> <i>symbol</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-attribute-p"></a>
<p>
This function returns t if symbolis the name of a character attribute,
nil otherwise.
                    </p>
</div>
<a id="f_shadow-attribute"></a>
<div class=definition>
<code>shadow-attribute</code> <i>attribute</i> <i>character</i> <i>value</i> <i>mode</i> <span class="definition-kind">[Function]</span><a id="description_in_f_shadow-attribute"></a>
<p> </p>
</div>
<a id="hv_shadow_attribute_hook"></a>
<div class=definition>
<code>shadow</code> <i>attribute</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_shadow_attribute_hook"></a>
<p>
This function establishes value as the value of character's attribute
attribute when in the mode mode.  Mode must be the name of a major
mode. Shadow Attribute Hook is invoked with the same arguments when
this function is called. If the value for an attribute is set while
the value is shadowed, then only the shadowed value is affected, not
the global one.
                    </p>
</div>
<a id="f_unshadow-attribute"></a>
<div class=definition>
<code>unshadow-attribute</code> <i>attribute</i> <i>character</i> <i>mode</i> <span class="definition-kind">[Function]</span><a id="description_in_f_unshadow-attribute"></a>
<p> </p>
</div>
<a id="hv_unshadow_attribute_hook"></a>
<div class=definition>
<code>unshadow</code> <i>attribute</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_unshadow_attribute_hook"></a>
<p>
Make the value of attribute for character no longer be shadowed in
mode. Unshadow Attribute Hook is invoked with the same arguments when
this function is called.
                    </p>
</div>
<a id="f_find-attribute"></a>
<div class=definition>
<code>find-attribute</code> <i>mark</i> <i>attribute</i> <code>&amp;optional</code> <i>test</i> <span class="definition-kind">[Function]</span><a id="description_in_f_find-attribute"></a>
<p> </p>
</div>
<a id="f_reverse-find-attribute"></a>
<div class=definition>
<code>reverse-find-attribute</code> <i>mark</i> <i>attribute</i> <code>&amp;optional</code> <i>test</i> <span class="definition-kind">[Function]</span><a id="description_in_f_reverse-find-attribute"></a>
<p>
These functions find the next (or previous) character with some value
for the character attribute attribute starting at mark. They pass test
one argument, the value of attribute for the character tested.  If the
test succeeds, then these routines modify mark to point before (after
for reverse-find-attribute) the character which satisfied the test.
If no characters satisfy the test, then these return nil, and mark
remains unmodified. Test defaults to <CODE>#'not-zerop</CODE>. There is no guarantee
that the test is applied in any particular fashion, so it should have
no side effects and depend only on its argument.
                    </p>
</div>
<a id="f_find-not-attribute"></a>
<div class=definition>
<code>find-not-attribute</code> <i>mark</i> <i>attribute</i> <span class="definition-kind">[Function]</span><a id="description_in_f_find-not-attribute"></a>
<p> </p>
</div>
<a id="f_reverse-find-not-attribute"></a>
<div class=definition>
<code>reverse-find-not-attribute</code> <i>mark</i> <i>attribute</i> <span class="definition-kind">[Function]</span><a id="description_in_f_reverse-find-not-attribute"></a>
<p>
These are equivalent to (find-attribute mark attribute #'zerop) and
(reverse-find-attribute mark attribute #'zerop), respectively.
                    </p>
</div>
</div>
<a id="character-attribute-hooks"></a>
<H4>Character Attribute Hooks</H4>
<div class="section">
<p>
It is often useful to use the character attribute mechanism as an
abstract interface to other information about characters which in fact
is stored elsewhere.  For example, some implementation of Hemlock
might decide to define a Print Representation attribute which controls
how a character is displayed on an output device.</p>
<p>To make this easy to do, each attribute has a list of hook functions
which are invoked with the attribute, character and new value whenever
the current value changes for any reason.
            </p>
<a id="f_character-attribute-hooks"></a>
<div class=definition>
<code>character-attribute-hooks</code> <i>attribute</i> <span class="definition-kind">[Function]</span><a id="description_in_f_character-attribute-hooks"></a>
<p>
Return the current hook list for attribute. This may be set with
setf. The <a href="#m_add-hook"><CODE>hemlock-interface:add-hook</CODE></a> and <a href="#m_remove-hook"><CODE>hemlock-interface:remove-hook</CODE></a> macros should be used to
manipulate these lists.
                    </p>
</div>
</div>
<a id="system-defined-character-attributes"></a>
<H4>System Defined Character Attributes</H4>
<div class="section">
<p>
These are predefined in Hemlock:
            </p>
<dl><dt>"Whitespace"</dt>
<dd><p>
A value of 1 indicates the character is whitespace.
                        </p>
</dd>
<dt>"Word Delimiter"</dt>
<dd><p>
A value of 1 indicates the character separates words (see the <a href="#english-text-buffers">English Text Buffers</a> section).</p>
<p>                        </p>
</dd>
<dt>"Space"</dt>
<dd><p>
This is like Whitespace, but it should not include Newline. Hemlock
uses this primarily for handling indentation on a line.
                        </p>
</dd>
<dt>"Sentence Terminator"</dt>
<dd><p>
A value of 1 indicates these characters terminate sentences (see the <a href="#english-text-buffers">English Text Buffers</a> section).
                        </p>
</dd>
<dt>"Sentence Closing Char"</dt>
<dd><p>
A value of 1 indicates these delimiting characters, such as " or ),
may follow a Sentence Terminator.
                        </p>
</dd>
<dt>"Paragraph Delimiter"</dt>
<dd><p>
A value of 1 indicates these characters delimit paragraphs when they
begin a line (see the <a href="#english-text-buffers">English Text Buffers</a> section).
                        </p>
</dd>
<dt>"Page Delimiter"</dt>
<dd><p>
A value of 1 indicates this character separates <a href="#logical-pages">Logical Pages</a>
when it begins a line.
                        </p>
</dd>
<dt>"Lisp Syntax"</dt>
<dd><p>
This uses symbol values from the following:
                        </p>
</dd>
</dl>
<ul><li><p>
nil  These characters have no interesting properties.
                    </p>
</ul>
<ul><li><p>
:space  These characters act like whitespace and should not include Newline.
                    </p>
</ul>
<ul><li><p>
:newline  This is the Newline character.
                    </p>
</ul>
<ul><li><p>
:open-paren  This is ( character.
                    </p>
</ul>
<ul><li><p>
:close-paren  This is ) character.
                    </p>
</ul>
<ul><li><p>
:prefix  This is a character that is a part of any form it precedes for example, the single quote, '.
                    </p>
</ul>
<ul><li><p>
:string-quote  This is the character that quotes a string literal, ".
                    </p>
</ul>
<ul><li><p>
:char-quote  This is the character that escapes a single character, \.
                    </p>
</ul>
<ul><li><p>
:comment  This is the character that makes a comment with the rest of the line,;.
                    </p>
</ul>
<ul><li><p>
:constituent  These characters are constitute symbol names.
                    </p>
</ul>
</div>
</div>
<a id="controlling-the-display"></a>
<H3>Controlling the Display</H3>
<div class="section">
<a id="views"></a>
<H4>Views</H4>
<div class="section">
<p>
A <CODE>hemlock-view</CODE> represents the GUI object(s) used to display the contents
of a buffer.  Conceptually it consists of a text buffer, a
modeline for semi-permanent status info, an echo area for transient
status info, and a text input area for reading prompted
input. (Currently the last two are conflated, i.e. text input happens
in the echo area).</p>
<p>The API for working with hemlock-views is not fully
defined yet.  If you need to work with views beyond what's listed
here, you will probably need to get in the sources and find some
internal functions to call.
            </p>
</div>
<a id="the-current-view"></a>
<H4>The Current View</H4>
<div class="section">
<a id="f_current-view"></a>
<div class=definition>
<code>current-view</code> <span class="definition-kind">[Function]</span><a id="description_in_f_current-view"></a>
<p>
current-view returns the hemlock view which is the target of the
currently executing command.  This is usually the frontmost hemlock
window in the current application.
                    </p>
</div>
</div>
<a id="view-functions"></a>
<H4>View Functions</H4>
<div class="section">
<a id="f_hemlock-view-p"></a>
<div class=definition>
<code>hemlock-view-p</code> <i>object</i> <span class="definition-kind">[Function]</span><a id="description_in_f_hemlock-view-p"></a>
<p>
This function returns t if object is a hemlock view, otherwise nil.
                    </p>
</div>
<a id="f_hemlock-view-buffer"></a>
<div class=definition>
<code>hemlock-view-buffer</code> <i>view</i> <span class="definition-kind">[Function]</span><a id="description_in_f_hemlock-view-buffer"></a>
<p>
This function returns the buffer which is displayed in the view.
                    </p>
</div>
</div>
<a id="cursor-positions"></a>
<H4>Cursor Positions</H4>
<div class="section">
<a id="f_mark-column"></a>
<div class=definition>
<code>mark-column</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-column"></a>
<p>
This function returns the X position at which mark would be displayed,
supposing its line was displayed on an infinitely wide screen.  This
takes into consideration strange characters such as tabs.
                    </p>
</div>
<a id="f_move-to-column"></a>
<div class=definition>
<code>move-to-column</code> <i>mark</i> <i>column</i> <code>&amp;optional</code> <i>line</i> <span class="definition-kind">[Function]</span><a id="description_in_f_move-to-column"></a>
<p>
This function is analogous to <a href="#f_move-to-position"><CODE>hemlock-interface:move-to-position</CODE></a>, except that
it moves mark to the position on line which corresponds to the
specified column.  If the line would not reach to the specified column, then nil is
returned and mark is not modified.  Note that since a character may be
displayed on more than one column on the screen, several different
values of column may cause mark to be moved to the same position.
                    </p>
</div>
</div>
<a id="redisplay"></a>
<H4>Redisplay</H4>
<div class="section">
<p>
The display of the buffer contents on the screen is updated at the
end of each command.  The following function can be used to control
the scroll position of the buffer in the view.
            </p>
<a id="f_set-scroll-position"></a>
<div class=definition>
<code>set-scroll-position</code> <i>how</i> <code>&amp;optional</code> <i>what</i> <span class="definition-kind">[Function]</span><a id="description_in_f_set-scroll-position"></a>
<p>
Normally, after a command that changes the contents of the buffer
or the selection (i.e. the active region), the event handler repositions
the view so that the selection is visible, scrolling the buffer as
necessary.  Calling this function tells the system to not do that,
and instead to position the buffer in a particular way.  <CODE>how</CODE> can
be one of the following:
                    </p>
<dl><dt>:center-selection</dt>
<dd><p>
This causes the selection (or the point) to be centered in the visible area.  <CODE>what</CODE> is ignored.</p>
<p>                                </p>
</dd>
<dt>:page-up</dt>
<dd><p>
This causes the previous page of the buffer to be shown <CODE>what</CODE> is ignored.
                                </p>
</dd>
<dt>:page-down</dt>
<dd><p>
This causes the next page of the buffer to be shown. <CODE>what</CODE> is ignored.
                                </p>
</dd>
<dt>:lines-up</dt>
<dd><p>
 This causes <CODE>what</CODE> previous lines to be scrolled in at the top. <CODE>what</CODE> must be an integer.  
                                </p>
</dd>
<dt>:lines-down</dt>
<dd><p>
This causes <CODE>what</CODE> next lines to be scrolled in at the bottom. <CODE>what</CODE> must be an integer.
                                </p>
</dd>
<dt>:line</dt>
<dd><p>
 This causes the line containing <CODE>what</CODE> to be scrolled to the top of the view. <CODE>what</CODE> must be a mark.
                                </p>
</dd>
</dl>
</div>
</div>
</div>
<a id="logical-key-events"></a>
<H3>Logical Key-Events</H3>
<div class="section">
<a id="introduction_in_logical-key-events"></a>
<H4>Introduction</H4>
<div class="section">
<p>
Some primitives such as <a href="#f_prompt-for-key"><CODE>hemlock-interface:prompt-for-key</CODE></a> and commands such as
Emacs query replace read key-events directly from the keyboard instead
of using the command interpreter.  To encourage consistency between
these commands and to make them portable and easy to customize, there
is a mechanism for defininglogical key-events.  A logical key-event is
a keyword which stands for some set of key-events.  The system
globally interprets these key-events as indicators a particular
action.  For example, the :help logical key-event represents the set of
key-events that request help in a given Hemlock implementation. This
mapping is a many-to-many mapping, not one-to-one, so a given logical
key-event may have multiple corresponding actual key-events.  Also,
any key-event may represent different logical key-events.
            </p>
</div>
<a id="logical-key-event-functions"></a>
<H4>Logical Key-Event Functions</H4>
<div class="section">
<a id="v_logical-key-event-names"></a>
<div class=definition>
<code>*logical-key-event-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_logical-key-event-names"></a>
<p>
This variable holds a string-table mapping all logical key-event names
to the keyword identifying the logical key-event.
                    </p>
</div>
<a id="f_define-logical-key-event"></a>
<div class=definition>
<code>define-logical-key-event</code> <i>string-name</i> <i>documentation</i> <span class="definition-kind">[Function]</span><a id="description_in_f_define-logical-key-event"></a>
<p>
This function defines a new logical key-event with name string-name.
Logical key-event operations take logical key-events
arguments as a keyword whose name is string-name uppercased with
spaces replaced by hyphens.</p>
<p>Documentation describes the action indicated by the logical key-event.
                    </p>
</div>
<a id="f_logical-key-event-key-events"></a>
<div class=definition>
<code>logical-key-event-key-events</code> <i>keyword</i> <span class="definition-kind">[Function]</span><a id="description_in_f_logical-key-event-key-events"></a>
<p>
This function returns the list of key-events representing the logical
key-event keyword.
                    </p>
</div>
<a id="f_logical-key-event-name"></a>
<div class=definition>
<code>logical-key-event-name</code> <i>keyword</i> <span class="definition-kind">[Function]</span><a id="description_in_f_logical-key-event-name"></a>
<p> </p>
</div>
<a id="f_logical-key-event-documentation"></a>
<div class=definition>
<code>logical-key-event-documentation</code> <i>keyword</i> <span class="definition-kind">[Function]</span><a id="description_in_f_logical-key-event-documentation"></a>
<p>
These functions return the string name and documentation given
to define-logical-key-event for logical key-event keyword.
                    </p>
</div>
<a id="f_logical-key-event-p"></a>
<div class=definition>
<code>logical-key-event-p</code> <i>key-event</i> <i>keyword</i> <span class="definition-kind">[Function]</span><a id="description_in_f_logical-key-event-p"></a>
<p>
This function returns t if key-event is the logical key-event
keyword. This is setf-able establishing or disestablishing key-events
as particular logical key-events. It is a error for keyword to be an
undefined logical key-event.
                    </p>
</div>
</div>
<a id="system-defined-logical-key-events"></a>
<H4>System Defined Logical Key-Events</H4>
<div class="section">
<p>
There are many default logical key-events, some of which are used by
functions documented in this manual.  If a command wants to read a
single key-event command that fits one of these descriptions then the
key-event read should be compared to the corresponding logical
key-event instead of explicitly mentioning the particular key-event in
the code.  In many cases you can use the <a href="#m_command-case"><CODE>hemlock-interface:command-case</CODE></a> macro.
It makes logical key-events easy to use and takes care of prompting
and displaying help messages.
            </p>
<ul><li><p>
:abort Indicates the prompter should terminate its activity without performing any closing actions of convenience, for example.
                    </p>
<li><p>
:yes Indicates the prompter should take the action under consideration.
                    </p>
<li><p>
:no Indicates the prompter should NOT take the action under consideration.
                    </p>
<li><p>
:do-all Indicates the prompter should repeat the action under consideration as many times as possible.
                    </p>
<li><p>
:do-once Indicates the prompter should execute the action under consideration once and then exit.
                    </p>
<li><p>
:help Indicates the prompter should display some help information.
                    </p>
<li><p>
:confirm Indicates the prompter should take any input provided or use the default if the user entered nothing.
                    </p>
<li><p>
:quote Indicates the prompter should take the following key-event as itself without any sort of command interpretation.
                    </p>
<li><p>
:keep Indicates the prompter should preserve something.
                    </p>
<li><p>
:y Indicates a short positive response
                    </p>
<li><p>
:n Indicates a short negative response
                    </p>
</ul>
<p>
Define a new logical key-event whenever:
            </p>
<ol><li><p>
The key-event concerned represents a general class of actions, and
several commands may want to take a similar action of this type.
                    </p>
</ol>
<ol><li><p>
The exact key-event a command implementor chooses may generate
violent taste disputes among users, and then the users can trivially
change the command in their init files.
                    </p>
</ol>
<ol><li><p>
You are using <CODE>command-case</CODE> which prevents implementors from
specifying non-standard characters for dispatching in otherwise
possibly portable code, and you can define and set the logical
key-event in a site dependent file where you can mention
implementation dependent characters.
                    </p>
</ol>
</div>
</div>
<a id="the-echo-area"></a>
<H3>The Echo Area</H3>
<div class="section">
<p>
Hemlock provides a number of facilities for displaying information and
prompting the user for it.  Most of these work through a small area
displayed at the bottom of the screen, called the Echo Area.
        </p>
<a id="echo-area-functions"></a>
<H4>Echo Area Functions</H4>
<div class="section">
<a id="f_clear-echo-area"></a>
<div class=definition>
<code>clear-echo-area</code> <span class="definition-kind">[Function]</span><a id="description_in_f_clear-echo-area"></a>
<p>
Clears the echo area.
                    </p>
</div>
<a id="f_message"></a>
<div class=definition>
<code>message</code> <i>control-string</i> <code>&amp;rest</code> <i>format-arguments</i> <span class="definition-kind">[Function]</span><a id="description_in_f_message"></a>
<p> </p>
</div>
<a id="f_loud-message"></a>
<div class=definition>
<code>loud-message</code> <i>control-string</i> <code>&amp;rest</code> <i>format-arguments</i> <span class="definition-kind">[Function]</span><a id="description_in_f_loud-message"></a>
<p>
Displays a message in the echo area, replacing previous contents if any.
loud-message is like message, but it also beeps.
                    </p>
</div>
<a id="f_beep"></a>
<div class=definition>
<code>beep</code> <span class="definition-kind">[Function]</span><a id="description_in_f_beep"></a>
<p>
Gets the user's attention, typically by making a sound.
                    </p>
</div>
</div>
<a id="prompting-functions"></a>
<H4>Prompting Functions</H4>
<div class="section">
<p>
Prompting functions can be used to obtain short one-line input from the user.</p>
<p>Cocoa note: Because of implementation restrictions, only one buffer at
a time is allowed to read prompted input.  If a prompting function is
invoked while a prompting operation is already in effect in another
buffer, the attempt fails, telling the user "Buffer xxx is already
waiting for input".</p>
<p>Most of the prompting functions accept the following keyword arguments:
            </p>
<dl><dt>:must-exist</dt>
<dd><p>
If :must-exist has a non-nil value then the user is
prompted until a valid response is obtained. If :must-exist is nil
then return as a string whatever is input.  The default is t.
                        </p>
</dd>
<dt>:default</dt>
<dd><p>
If null input is given when the user is prompted then this
value is returned. If no default is given then some input must be
given before anything interesting will happen.
                        </p>
</dd>
<dt>:default-string</dt>
<dd><p>
If a :default is given then this is a string to be
printed to indicate what the default is.  The default is some
representation of the value for :default, for example for a buffer it
is the name of the buffer.
                        </p>
</dd>
<dt>:prompt</dt>
<dd><p>
This is the prompt string to display.
                        </p>
</dd>
<dt>:help</dt>
<dd><p>
This is similar to :prompt, except that it is displayed when the help
command is typed during input.
                        </p>
</dd>
</dl>
<blockquote>
<p>This may also be a function.  When called with no arguments, it
should either return a string which is the help text or perform some
action to help the user, returning nil.
            </p>
</blockquote>
<a id="f_prompt-for-buffer"></a>
<div class=definition>
<code>prompt-for-buffer</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-buffer"></a>
<p>
Prompts with completion for a buffer name and returns the
corresponding buffer.  If must-exist is nil, then it returns the input
string if it is not a buffer name.  This refuses to accept the empty
string as input when :default and :default-string are
nil. :default-string may be used to supply a default buffer name
when:default is nil, but when :must-exist is non-nil, it must name an
already existing buffer.
                    </p>
</div>
<a id="f_prompt-for-key-event"></a>
<div class=definition>
<code>prompt-for-key-event</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-key-event"></a>
<p>
This function prompts for a key-event returning immediately when the
user types the next key-event.  <a href="#m_command-case"><CODE>hemlock-interface:command-case</CODE></a> is more useful
for most purposes. When appropriate, use <a href="#logical-key-events">Logical Key-Events</a>.
                    </p>
</div>
<a id="f_prompt-for-key"></a>
<div class=definition>
<code>prompt-for-key</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-key"></a>
<p>
This function prompts for a key, a vector of key-events, suitable for
passing to any of the functions that manipulate <a href="#binding-commands-to-keys">key bindings</a>.
If must-exist is true, then the key must be bound in the current
environment, and the command currently bound is returned as the second
value.
                    </p>
</div>
<a id="f_prompt-for-file"></a>
<div class=definition>
<code>prompt-for-file</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-file"></a>
<p>
This function prompts for an acceptable filename.  "Acceptable" means
that it is a legal filename, and it exists if must-exist is
non-nil. prompt-for-file returns a Common Lisp pathname.  If the file
exists as entered, then this returns it, otherwise it is merged with
default as by merge-pathnames.
                    </p>
</div>
<a id="f_prompt-for-integer"></a>
<div class=definition>
<code>prompt-for-integer</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-integer"></a>
<p>
This function prompts for a possibly signed integer. If must-exist is
nil, then prompt-for-integer returns the input as a string if it is
not a valid integer.
                    </p>
</div>
<a id="f_prompt-for-keyword"></a>
<div class=definition>
<code>prompt-for-keyword</code> <i>string-tables</i> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-keyword"></a>
<p>
This function prompts for a keyword with completion, using the string
tables in the list string-tables. If must-exist is non-nil, then the
result must be an unambiguous prefix of a string in one of the
string-tables, and the returns the complete string even if only a
prefix of the full string was typed.  In addition, this returns the
value of the corresponding entry in the string table as the second
value.</p>
<p>If must-exist is nil, then this function returns the string exactly as
entered.  The difference between prompt-for-keyword with must-exist
nil, and prompt-for-string, is the user may complete the input using
the Complete Parse and Complete Field commands.
                    </p>
</div>
<a id="f_prompt-for-expression"></a>
<div class=definition>
<code>prompt-for-expression</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-expression"></a>
<p>
This function reads a Lisp expression.  If must-exist is nil, and a
read error occurs, then this returns the string typed.
                    </p>
</div>
<a id="f_prompt-for-string"></a>
<div class=definition>
<code>prompt-for-string</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-string"></a>
<p>
This function prompts for a string; this cannot fail.
                    </p>
</div>
<a id="f_prompt-for-variable"></a>
<div class=definition>
<code>prompt-for-variable</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-variable"></a>
<p>
This function prompts for a variable name.  If must-exist is non-nil,
then the string must be a variable defined in the current environment,
in which case the symbol name of the variable found is returned as the
second value.
                    </p>
</div>
<a id="f_prompt-for-y-or-n"></a>
<div class=definition>
<code>prompt-for-y-or-n</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-y-or-n"></a>
<p>
This prompts for logical key events :Y or :N, returning t or nil without waiting for
confirmation.  When the user types a confirmation key, this returns
default if it is supplied.  If must-exist is nil, this returns
whatever key-event the user first types; however, if the user types
one of the above key-events, this returns t or nil. This is analogous to
the Common Lisp function y-or-n-p.
                    </p>
</div>
<a id="f_prompt-for-yes-or-no"></a>
<div class=definition>
<code>prompt-for-yes-or-no</code> <code>&amp;key</code> <i>:prompt</i> <i>:help</i> <i>:must-exist</i> <i>:default</i> <i>:default-string</i> <span class="definition-kind">[Function]</span><a id="description_in_f_prompt-for-yes-or-no"></a>
<p>
This function is to prompt-for-y-or-n as yes-or-no-p is to
y-or-n-p. "Yes" or "No" must be typed out in full and confirmation
must be given.
                    </p>
</div>
<a id="m_command-case"></a>
<div class=definition>
<code>command-case</code>  (<i>{key</i> <i>value}*){({({tag}*</i>) <i>|</i> <i>tag}</i> <i>help</i> <i>{form}*)}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_command-case"></a>
<p>
This macro is analogous to the Common Lisp case macro. Commands such
as Help use this to get a key-event, translate it to a
character, and then to dispatch on the character to some case.  In
addition to character dispatching, this supports <a href="#logical-key-events">Logical Key-Events</a>
by using the input key-event directly without translating it
to a character.  Since the description of this macro is rather
complex, first consider the following example:
<pre class="source-code">
(defcommand "Save All Buffers" (p)
  "Give the User a chance to save each modified buffer."
  (dolist (b *buffer-list*)
    (select-buffer-command () b)
    (when (buffer-modified b)
      (command-case (:prompt "Save this buffer: [Y] "
			     :help "Save buffer, or do something else:")
	((:yes :confirm)
	 "Save this buffer and go on to the next."
	 (save-file-command () b))
	(:no "Skip saving this buffer, and go on to the next.")
	((:exit #\p) "Punt this silly loop."
	 (return nil))))))
</pre>
</p>
<p>
command-case prompts for a key-event and then executes the code in the
first branch with a logical key-event or a character (called tags)
matching the input.  Each character must be a standard-character, one
that satisfies the Common Lisp standard-char-p predicate, and the
dispatching mechanism compares the input key-event to any character
tags by mapping the key-event to a character with
ext:key-event-char. If the tag is a logical key-event, then the search
for an appropriate case compares the key-event read with the tag
using logical-key-event-p.</p>
<p>All uses of command-case have two default cases, :help and :abort. You
can override these easily by specifying your own branches that include
these logical key-event tags.  The :help branch displays in a pop-up
window the a description of the valid responses using the variously
specified help strings. The :abort branch signals an editor-error.</p>
<p>The key/value arguments control the prompting.  The following are valid values:
                    </p>
<dl><dt>:help</dt>
<dd><p>
The default :help case displays this string in a pop-up window.  In
addition it formats a description of the valid input including each
case's help string.
                                </p>
</dd>
<dt>:prompt</dt>
<dd><p>
This is the prompt used when reading the key-event.
                                </p>
</dd>
<dt>:bind</dt>
<dd><p>
This specifies a variable to which the prompting mechanism binds the
input key-event. Any case may reference this variable.  If you wish
to know what character corresponds to the key-event, use
key-event-char.
                                </p>
</dd>
</dl>
<p>
Instead of specifying a tag or list of tags, you may use t. This
becomes the default branch, and its forms execute if no other branch
is taken, including the default :help and :abort cases. This option has
no helpstring, and the default :help case does not describe the default
branch.  Every command-case has a default branch; if none is specified,
the macro includes one that beep's and reprompt's (see below).</p>
<p>Within the body of command-case, there is a defined reprompt macro. It
causes the prompting mechanism and dispatching mechanism to
immediately repeat without further execution in the current branch.
                    </p>
</div>
</div>
<a id="control-of-parsing-behavior"></a>
<H4>Control of Parsing Behavior</H4>
<div class="section">
<a id="hv_beep_on_ambiguity"></a>
<div class=definition>
<code>beep</code> <i>on</i> <i>ambiguity</i>  (<i>initial</i> <i>value</i> <i>t</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_beep_on_ambiguity"></a>
<p>
If this variable is true, then an attempt to complete a parse which is
ambiguous will result in a "beep".
                    </p>
</div>
</div>
<a id="defining-new-prompting-functions"></a>
<H4>Defining New Prompting Functions</H4>
<div class="section">
<p>
Prompting functionality is implemented by the function parse-for-something
in cooperation with commands defined in "Echo Area" mode on the buffer associated
with the echo area. You can implement new prompting functions by invoking
parse-for-something with appropriate arguments.
            </p>
<a id="f_parse-for-something"></a>
<div class=definition>
<code>parse-for-something</code> <code>&amp;key</code> <span class="definition-kind">[Function]</span><a id="description_in_f_parse-for-something"></a>
<p>
This function enters a mode reading input from the user and echoing it in the echo area, and
returns a value when done.  The input is managed by commands bound in "Echo Area" mode on the
buffer associated with the echo area.  The following  keyword arguments are accepted:
                    </p>
<dl><dt><CODE>:verification-function</CODE></dt>
<dd><p>
This is invoked by the <a href="#hc_confirm_parse"><CODE>"Confirm Parse"</CODE></a> command.  It does most of
the work when parsing prompted input. Confirm Parse calls it
with one argument, which is the string that the user typed so far.
The function should return a list of values which are to be the result
of the recursive edit, or nil indicating that the parse failed.  In order
to return zero values, a non-nil second value may be returned along with
a nil first value.
                                </p>
</dd>
<dt><CODE>:string-tables</CODE></dt>
<dd><p>
This is the list of string-tables, if any, that pertain to this parse.
                                </p>
</dd>
<dt><CODE>:value-must-exist</CODE></dt>
<dd><p>
This is referred to by the verification function, and possibly some of the
commands.
                                </p>
</dd>
<dt><CODE>:default</CODE></dt>
<dd><p>
The string representing the default object when prompting the user.
Confirm Parse supplies this to the parse verification function when the
user input is empty.
                                </p>
</dd>
<dt><CODE>:default-string</CODE></dt>
<dd><p>
When prompting the user, if :default is not specified, Hemlock displays
this string as a representation of the default object; for example,
when prompting for a buffer, this argument would be a default buffer name.
                                </p>
</dd>
<dt><CODE>:type</CODE></dt>
<dd><p>
The kind of parse, e.g. :file, :keyword, :string. This tells the completion
commands how to do completion, with :string disabling completion.
                                </p>
</dd>
<dt><CODE>:prompt</CODE></dt>
<dd><p>
The prompt to display to the user.
                                </p>
</dd>
<dt><CODE>:help</CODE></dt>
<dd><p>
The help string or function being used for the current parse.
                                </p>
</dd>
</dl>
</div>
</div>
<a id="some-echo-area-commands"></a>
<H4>Some Echo Area Commands</H4>
<div class="section">
<p>
These are some of the Echo Area commands that coordinate with the
prompting routines. Hemlock binds other commands specific to the Echo
Area, but they are uninteresting to mention here, such as deleting to
the beginning of the line or deleting backwards a word.
            </p>
<a id="hc_help_on_parse"></a>
<div class=definition>
<code>help</code> <i>on</i> <i>parse</i>  (<i>bound</i> <i>to</i> <i>home,</i> <i>c-_</i> <i>in</i> <i>echo</i> <i>area</i> <i>mode</i>) <span class="definition-kind">[Hemlock Command]</span><a id="description_in_hc_help_on_parse"></a>
<p>
Display the help text for the parse currently in progress.
                    </p>
</div>
<a id="hc_complete_keyword"></a>
<div class=definition>
<code>complete</code> <i>keyword</i>  (<i>bound</i> <i>to</i> <i>escape</i> <i>in</i> <i>echo</i> <i>area</i> <i>mode</i>) <span class="definition-kind">[Hemlock Command]</span><a id="description_in_hc_complete_keyword"></a>
<p>
This attempts to complete the current region.
It signals an editor-error if the input is ambiguous or incorrect.
                    </p>
</div>
<a id="hc_complete_field"></a>
<div class=definition>
<code>complete</code> <i>field</i>  (<i>bound</i> <i>to</i> <i>space</i> <i>in</i> <i>echo</i> <i>area</i> <i>mode</i>) <span class="definition-kind">[Hemlock Command]</span><a id="description_in_hc_complete_field"></a>
<p>
Similar to <CODE>Complete Keyword</CODE>, but only attempts to complete up to and
including the first character in the keyword with a non-zero
:parse-field-separator attribute. If there is no field separator then
attempt to complete the entire keyword.  If it is not a keyword parse
then just self-insert.
                    </p>
</div>
<a id="hc_confirm_parse"></a>
<div class=definition>
<code>confirm</code> <i>parse</i>  (<i>bound</i> <i>to</i> <i>return</i> <i>in</i> <i>echo</i> <i>area</i> <i>mode</i>) <span class="definition-kind">[Hemlock Command]</span><a id="description_in_hc_confirm_parse"></a>
<p>
Call the verification function with the current input.  If it
returns a non-nil value then that is returned as the value of the
parse.  A parse may return a nil value if the verification function
returns a non-nil second value.
                    </p>
</div>
</div>
</div>
<a id="files"></a>
<H3>Files</H3>
<div class="section">
<p>
This chapter discusses ways to read and write files at various
levels---at marks, into regions, and into buffers.  This also treats
automatic mechanisms that affect the state of buffers in which files
are read.
        </p>
<a id="file-options-and-type-hooks"></a>
<H4>File Options and Type Hooks</H4>
<div class="section">
<p>
The user specifies file options with a special syntax on the first
line of a file.  If the first line contains the string "-*-",
then Hemlock interprets the text between the first such occurrence and
the second, which must be contained in one line , as a list of
"option: value" pairs separated by semicolons.  The following is a
typical example:
<pre class="source-code">
;;; -*- Mode: Lisp, Editor; Package: Hemlock -*-
</pre>
See the Hemlock User's Manual for more details and predefined options.
            </p>
<p>
File type hooks are executed when Hemlock reads a file into a buffer
based on the type of the pathname.  When the user specifies a Mode
file option that turns on a major mode, Hemlock ignores type hooks.
This mechanism is mostly used as a simple means for turning on some
appropriate default major mode.
            </p>
<a id="m_define-file-option"></a>
<div class=definition>
<code>define-file-option</code> <i>name</i>  (<i>buffer</i> <i>value</i>) <i>{declaration}*</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_define-file-option"></a>
<p>
This defines a new file option with the string
name name. Buffer and value specify variable names for the buffer and the
option value string, and forms are evaluated with these bound.
                    </p>
</div>
<a id="m_define-file-type-hook"></a>
<div class=definition>
<code>define-file-type-hook</code> <i>type-list</i>  (<i>buffer</i> <i>type</i>) <i>{declaration}*</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_define-file-type-hook"></a>
<p>
This defines some code that process-file-options(below) executes when
the file options fail to set a major mode.  This associates each type,
a string, in type-list with a routine that binds buffer to the
buffer the file is in and type to the type of the pathname.
                    </p>
</div>
<a id="f_process-file-options"></a>
<div class=definition>
<code>process-file-options</code> <i>buffer</i> <code>&amp;optional</code> <i>pathname</i> <span class="definition-kind">[Function]</span><a id="description_in_f_process-file-options"></a>
<p>
This checks for file options in buffer and invokes handlers if there
are any. Pathname defaults to buffer's pathname but may be nil. If
there is no Mode file option that specifies a major mode, and pathname
has a type, then this tries to invoke the appropriate file type
hook. read-buffer-file calls this.
                    </p>
</div>
</div>
<a id="pathnames-and-buffers"></a>
<H4>Pathnames and Buffers</H4>
<div class="section">
<p>
There is no good way to uniquely identify buffer names and pathnames.
However, Hemlock has one way of mapping pathnames to buffer names that
should be used for consistency among customizations and primitives.
Independent of this, Hemlock provides a means for consistently
generating prompting defaults when asking the user for pathnames.
            </p>
<a id="f_pathname-to-buffer-name"></a>
<div class=definition>
<code>pathname-to-buffer-name</code> <i>pathname</i> <span class="definition-kind">[Function]</span><a id="description_in_f_pathname-to-buffer-name"></a>
<p>
This function returns a string of the form "file-namestring directory-namestring".
                    </p>
</div>
<a id="hv_pathname_defaults"></a>
<div class=definition>
<code>pathname</code> <i>defaults</i>  (<i>initial</i> <i>value</i>  (<i>pathname</i> <i>&amp;quot;gazonk.del&amp;quot;</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_pathname_defaults"></a>
<p> </p>
</div>
<a id="hv_last_resort_pathname_defaults_function"></a>
<div class=definition>
<code>last</code> <i>resort</i> <i>pathname</i> <i>defaults</i> <i>function</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_last_resort_pathname_defaults_function"></a>
<p> </p>
</div>
<a id="hv_last_resort_pathname_defaults"></a>
<div class=definition>
<code>last</code> <i>resort</i> <i>pathname</i> <i>defaults</i>  (<i>initial</i> <i>value</i>  (<i>pathname</i> <i>&amp;quot;gazonk&amp;quot;</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_last_resort_pathname_defaults"></a>
<p>
These variables control the computation of default pathnames when
needed for promting the user.  Pathname Defaults is a sticky
default. See the Hemlock User's Manual for more details.
                    </p>
</div>
<a id="f_buffer-default-pathname"></a>
<div class=definition>
<code>buffer-default-pathname</code> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_buffer-default-pathname"></a>
<p>
This returns Buffer Pathname if it is bound.  If it is not bound, and
buffer's name is composed solely of alphnumeric characters, then
return a pathname formed from buffer's name.  If buffer's name has
other characters in it, then return the value of Last Resort Pathname
Defaults Function called on buffer.
                    </p>
</div>
</div>
<a id="file-groups"></a>
<H4>File Groups</H4>
<div class="section">
<p>
Currently Hemlock doesn't have support for file groups.
            </p>
</div>
<a id="file-reading-and-writing"></a>
<H4>File Reading and Writing</H4>
<div class="section">
<p>
Common Lisp pathnames are used by the file primitives.  For probing,
checking write dates, and so forth, all of the Common Lisp file
functions are available.
            </p>
<a id="f_read-file"></a>
<div class=definition>
<code>read-file</code> <i>pathname</i> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_read-file"></a>
<p>
This inserts the file named by pathname at mark.
                    </p>
</div>
<a id="f_write-file"></a>
<div class=definition>
<code>write-file</code> <i>region</i> <i>pathname</i> <code>&amp;key</code> <i>:keep-backup</i> <i>:append</i> <span class="definition-kind">[Function]</span><a id="description_in_f_write-file"></a>
<p> </p>
</div>
<a id="hv_keep_backup_files"></a>
<div class=definition>
<code>keep</code> <i>backup</i> <i>files</i>  (<i>initial</i> <i>value</i> <i>nil</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_keep_backup_files"></a>
<p>
This function writes the contents of region to the file named by
pathname. This writes region using a stream as if it were opened with
:if-exists supplied as :rename-and-delete.</p>
<p>When keep-backup, which defaults to the value of Keep Backup Files, is
non-nil, this opens the stream as if :if-exists were :rename. If
append is non-nil, this writes the file as if it were opened
with:if-exists supplied as :append.</p>
<p>This signals an error if both append and keep-backup are supplied as non-nil.
                    </p>
</div>
<a id="f_write-buffer-file"></a>
<div class=definition>
<code>write-buffer-file</code> <i>buffer</i> <i>pathname</i> <span class="definition-kind">[Function]</span><a id="description_in_f_write-buffer-file"></a>
<p> </p>
</div>
<a id="hv_write_file_hook"></a>
<div class=definition>
<code>write</code> <i>file</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_write_file_hook"></a>
<p> </p>
</div>
<a id="hv_add_newline_at_eof_on_writing_file"></a>
<div class=definition>
<code>add</code> <i>newline</i> <i>at</i> <i>eof</i> <i>on</i> <i>writing</i> <i>file</i>  (<i>initial</i> <i>value</i> <i>:ask-user</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_add_newline_at_eof_on_writing_file"></a>
<p>
write-buffer-file writes buffer to the file named by pathname
including the following:
                    </p>
<ul><li><p>
It assumes pathname is somehow related to buffer's pathname: if
the buffer's write date is not the same as pathname's, then this
prompts the user for confirmation before overwriting the file.
                            </p>
</ul>
<ul><li><p>
It consults Add Newline at EOF on Writing File (see Hemlock User's
Manual for possible values) and interacts with the user if
necessary.
                            </p>
</ul>
<ul><li><p>
It sets Pathname Defaults, and after using write-file,
marks buffer unmodified.
                            </p>
</ul>
<ul><li><p>
It updates Buffer's pathname and write date.
                            </p>
</ul>
<ul><li><p>
It renames the buffer according to the new pathname if possible.
                            </p>
</ul>
<ul><li><p>
It invokes Write File Hook.
                            </p>
</ul>
<p>
Write File Hook is a list of functions that take the newly written buffer as an argument.
                    </p>
</div>
<a id="f_read-buffer-file"></a>
<div class=definition>
<code>read-buffer-file</code> <i>pathname</i> <i>buffer</i> <span class="definition-kind">[Function]</span><a id="description_in_f_read-buffer-file"></a>
<p> </p>
</div>
<a id="hv_read_file_hook"></a>
<div class=definition>
<code>read</code> <i>file</i> <i>hook</i> <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_read_file_hook"></a>
<p>
read-buffer-file deletes buffer's region and uses read-file to read
pathname into it, including the following:
                    </p>
<ul><li><p>
It sets buffer's write date to the file's write date if the file
exists; otherwise, it messages that this is a new file and sets
buffer's write date to nil.
                            </p>
</ul>
<ul><li><p>
It moves buffer's point to the beginning.
                            </p>
</ul>
<ul><li><p>
It sets buffer's unmodified status.
                            </p>
</ul>
<ul><li><p>
It sets buffer's pathname to the result of probing pathname if the
file exists; otherwise, this function sets buffer's pathname to the
result of merging pathname with default-directory.
                            </p>
</ul>
<ul><li><p>
It sets Pathname Defaults to the result of the previous item.
                            </p>
</ul>
<ul><li><p>
It processes the file options.
                            </p>
</ul>
<ul><li><p>
It invokes Read File Hook.
                            </p>
</ul>
<p>
Read File Hook is a list functions that take two arguments---the
buffer read into and whether the file existed, t if so.
                    </p>
</div>
</div>
</div>
<a id="hemlock-s-lisp-environment"></a>
<H3>Hemlock's Lisp Environment</H3>
<div class="section">
<p>
This chapter is sort of a catch all for any functions and variables
which concern Hemlock's interaction with the outside world.
        </p>
<a id="entering-and-leaving-the-editor"></a>
<H4>Entering and Leaving the Editor</H4>
<div class="section">
<a id="f_ed"></a>
<div class=definition>
<code>ed</code> <code>&amp;optional</code> <i>x</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ed"></a>
<p>
This a standard Common Lisp function.  If x is supplied and is a
string or pathname, the file specified by x is visited in a hemlock
view (opening a new window if necessary, otherwise bringing an
existing window with the file to the front), and the hemlock view
object is the return value from the function.</p>
<p>If x is null, a new empty hemlock view is created and returned.</p>
<p>If x is a symbol or a setf function name, it attempts to
edit the definition of the name.  In this last case, the
function returns without waiting for the operation to complete
(for example, it might put up a non-modal dialog asking the
user to select one of multiple definitions) and hence the
return value is always NIL.
                    </p>
</div>
</div>
<a id="keyboard-input"></a>
<H4>Keyboard Input</H4>
<div class="section">
<a id="v_key-event-history"></a>
<div class=definition>
<code>*key-event-history*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_key-event-history"></a>
<p>
This is a Hemlock <a href="#ring-functions">ring buffer</a> that holds the last 60
key-events received.
                    </p>
</div>
<a id="f_last-key-event-typed"></a>
<div class=definition>
<code>last-key-event-typed</code> <span class="definition-kind">[Function]</span><a id="description_in_f_last-key-event-typed"></a>
<p>
This function returns the last key-event the user typed to invoke the current command.
                    </p>
</div>
<a id="f_last-char-typed"></a>
<div class=definition>
<code>last-char-typed</code> <span class="definition-kind">[Function]</span><a id="description_in_f_last-char-typed"></a>
<p>
This function returns the character corresponding to the last key event typed.
                    </p>
</div>
</div>
<a id="hemlock-streams"></a>
<H4>Hemlock Streams</H4>
<div class="section">
<p>
It is possible to create streams which output to or get input from a
buffer. This mechanism is quite powerful and permits easy interfacing
of Hemlock to Lisp.
            </p>
<p>
Note that operations on these streams operate directly on buffers,
therefore they have the same restrictions as described <a href="#buffers">here</a>
for interacting with buffers from outside of the GUI thread.
            </p>
<a id="f_make-hemlock-output-stream"></a>
<div class=definition>
<code>make-hemlock-output-stream</code> <i>mark</i> <code>&amp;optional</code> <i>buffered</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-hemlock-output-stream"></a>
<p>
This function returns a stream that inserts at mark all
output directed to it.  It works best if mark is a left-inserting mark.
Buffered controls whether the stream is buffered or not, and its valid values
are the following keywords:
                    </p>
<dl><dt>:none</dt>
<dd><p>
No buffering is done.  This is the default.
                                </p>
</dd>
<dt>:line</dt>
<dd><p>
The buffer is flushed whenever a newline is written or when it is
explicitly done with force-output.
                                </p>
</dd>
<dt>:full</dt>
<dd><p>
The stream is only brought up to date when it is explicitly
done with force-output
                                </p>
</dd>
</dl>
</div>
<a id="f_hemlock-output-stream-p"></a>
<div class=definition>
<code>hemlock-output-stream-p</code> <i>object</i> <span class="definition-kind">[Function]</span><a id="description_in_f_hemlock-output-stream-p"></a>
<p>
This function returns t if object is a hemlock-output-stream object.
                    </p>
</div>
<a id="f_make-hemlock-region-stream"></a>
<div class=definition>
<code>make-hemlock-region-stream</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-hemlock-region-stream"></a>
<p>
This function returns a stream from which the text in
region can be read.
                    </p>
</div>
<a id="f_hemlock-region-stream-p"></a>
<div class=definition>
<code>hemlock-region-stream-p</code> <i>object</i> <span class="definition-kind">[Function]</span><a id="description_in_f_hemlock-region-stream-p"></a>
<p>
This function returns t if object is a hemlock-region-stream object.
                    </p>
</div>
<a id="m_with-input-from-region"></a>
<div class=definition>
<code>with-input-from-region</code>  (<i>var</i> <i>region</i>) <i>{declaration}*</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-input-from-region"></a>
<p>
While evaluating forms, binds var to a stream which returns input from region.
                    </p>
</div>
<a id="m_with-output-to-mark"></a>
<div class=definition>
<code>with-output-to-mark</code>  (<i>var</i> <i>mark</i> <i>[buffered]</i>) <i>{declaration}*</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-output-to-mark"></a>
<p>
During the evaluation of the forms, binds var to a stream which inserts
output at the permanent mark.  Buffered has the same meaning as for
make-hemlock-output-stream.
                    </p>
</div>
<a id="m_with-pop-up-display"></a>
<div class=definition>
<code>with-pop-up-display</code>  (<i>var</i> <code>&amp;key</code> <i>height</i> <i>name</i>) <i>{declaration}*</i> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_with-pop-up-display"></a>
<p>
This macro executes forms in a context with var bound to a
stream. Hemlock collects output to this stream and tries to pop up a
display of the appropriate height containing all the output.  When
height is supplied, Hemlock creates the pop-up display immediately,
forcing output on line breaks.  This is useful for displaying information
of temporary interest.
                    </p>
</div>
</div>
<a id="interface-to-the-error-system"></a>
<H4>Interface to the Error System</H4>
<div class="section">
<p>
Hemlock commands are executed from an event handler in the initial
Cocoa thread.  They are executed within a
ccl::with-standard-abort-handling form, which means cl:abort,
ccl:abort-break, ccl:throw-cancel will abort the current command only
and exit the event handler in an orderly fashion.</p>
<p>In addition, for now, lisp errors during command execution dump a
backtrace in the system console and are otherwise handled as if by
                <CODE>handle-lisp-errors</CODE> below, which means it is not possible to debug
errors at the point of the error.  Once Clozure CL has better support
for debugging errors in the initial Cocoa thread, better Hemlock error
handling will be provided that will allow for some way to debug.
            </p>
<a id="f_editor-error"></a>
<div class=definition>
<code>editor-error</code> <code>&amp;rest</code> <i>args</i> <span class="definition-kind">[Function]</span><a id="description_in_f_editor-error"></a>
<p>
This function is called to report minor errors to the user.  These are
errors that a normal user could encounter in the course of editing,
such as a search failing or an attempt to delete past the end of the
buffer. This function simply aborts the current command.  Any args
specified are used to format an error message to be placed in the echo
area.  This function never returns.
                    </p>
</div>
<a id="m_handle-lisp-errors"></a>
<div class=definition>
<code>handle-lisp-errors</code> <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_handle-lisp-errors"></a>
<p>
Within the body of this macro any Lisp errors that occur are handled
by displaying an error message in a dialog and aborting the current
command, leaving the error text in the echo area.  This macro should
be wrapped around code which may get an error due to some action of
the user --- for example, evaluating code fragments on the behalf of
and supplied by the user.
                    </p>
</div>
</div>
<a id="definition-editing"></a>
<H4>Definition Editing</H4>
<div class="section">
<p>
Hemlock provides commands for finding the definition of a function
or variable and placing the user at the definition in a buffer. A
function is provided to allow invoking this functionality outside
of Hemlock.  Note that this function is unusual in that it is
it is safe to call outside of the command interpreter, and in fact
it can be called from any thread.
            </p>
<a id="f_edit-definition"></a>
<div class=definition>
<code>edit-definition</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_edit-definition"></a>
<p>
This function tries to find the definition of <CODE>name</CODE>, create
or activate the window containing it, and scroll the view
to show the definition.  If there are multiple definitions
available, the user is given a choice of which one to
use.  This function may return before the operation is complete.
                    </p>
</div>
</div>
<a id="event-scheduling"></a>
<H4>Event Scheduling</H4>
<div class="section">
<p>
No Event Scheduling functionality is provided at this time.
            </p>
</div>
<a id="miscellaneous_in_hemlock-s-lisp-environment"></a>
<H4>Miscellaneous</H4>
<div class="section">
<a id="f_in-lisp"></a>
<div class=definition>
<code>in-lisp</code> <i>{form}*</i> <span class="definition-kind">[Function]</span><a id="description_in_f_in-lisp"></a>
<p>
This evaluates forms inside handle-lisp-errors. It also binds
*package* to the package named by Current Package if it is
non-nil. Use this when evaluating Lisp code on behalf of the user.
                    </p>
</div>
<a id="m_do-alpha-chars"></a>
<div class=definition>
<code>do-alpha-chars</code>  (<i>var</i> <i>kind</i> <i>[result]</i>) <i>{form}*</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_do-alpha-chars"></a>
<p>
This iterates over alphabetic characters in Common Lisp binding var to
each character in order as specified under character relations in
Common Lisp the Language. Kind is one of:lower, :upper, or :both. When
the user supplies :both, lowercase characters are processed first.
                    </p>
</div>
</div>
</div>
<a id="high-level-text-primitives"></a>
<H3>High-Level Text Primitives</H3>
<div class="section">
<p>
This chapter discusses primitives that operate on higher level text
forms than characters and words. For English text, there are functions
that know about sentence and paragraph structures, and for Lisp
sources, there are functions that understand this language. This
chapter also describes mechanisms for organizing file sections into
logical pages and for formatting text forms.
        </p>
<a id="indenting-text"></a>
<H4>Indenting Text</H4>
<div class="section">
<a id="hv_indent_function"></a>
<div class=definition>
<code>indent</code> <i>function</i>  (<i>initial</i> <i>value</i> <i>tab-to-tab-stop</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_indent_function"></a>
<p>
The value of this variable determines how indentation is done, and it
is a function which is passed a mark as its argument. The function
should indent the line that the mark points to. The function may move
the mark around on the line. The mark will be :left-inserting. The
default simply inserts a tab character at the mark. A function for
Lisp mode probably moves the mark to the beginning of the line,
deletes horizontal whitespace, and computes some appropriate
indentation for Lisp code.
                    </p>
</div>
<a id="hv_indent_with_tabs"></a>
<div class=definition>
<code>indent</code> <i>with</i> <i>tabs</i>  (<i>initial</i> <i>value</i> <i>nil</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_indent_with_tabs"></a>
<p> </p>
</div>
<a id="hv_spaces_per_tab"></a>
<div class=definition>
<code>spaces</code> <i>per</i> <i>tab</i>  (<i>initial</i> <i>value</i> <i>8</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_spaces_per_tab"></a>
<p>
Indent with Tabs should be true if indenting should use tabs
whenever possible. If nil, the default, it only uses spaces.
Spaces per Tab defines the size of a tab.
                    </p>
</div>
<a id="f_indent-region"></a>
<div class=definition>
<code>indent-region</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_indent-region"></a>
<p> </p>
</div>
<a id="f_indent-region-for-commands"></a>
<div class=definition>
<code>indent-region-for-commands</code> <i>region</i> <span class="definition-kind">[Function]</span><a id="description_in_f_indent-region-for-commands"></a>
<p>
indent-region invokes the value of Indent Function on every line of
region. indent-region-for-commands uses indent-region but first saves
the region for the Undo command.
                    </p>
</div>
<a id="f_delete-horizontal-space"></a>
<div class=definition>
<code>delete-horizontal-space</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-horizontal-space"></a>
<p>
This deletes all characters on either side of mark with a Space attribute (see <a href="#system-defined-character-attributes">System Defined Character Attributes</a>) of 1.
                    </p>
</div>
</div>
<a id="lisp-text-buffers"></a>
<H4>Lisp Text Buffers</H4>
<div class="section">
<p>
Hemlock bases its Lisp primitives on parsing a block of the buffer and
annotating lines as to what kind of Lisp syntax occurs on the line or
what kind of form a mark might be in (for example, string, comment,
list, etc.). These do not work well if the block of parsed forms is
exceeded when moving marks around these forms, but the block that gets
parsed is somewhat programmable.</p>
<p>There is also a notion of a top level form which this documentation
often uses synonymously with defun, meaning a Lisp form occurring in a
source file delimited by parentheses with the opening parenthesis at
the beginning of some line. The names of the functions include this
inconsistency.
            </p>
<a id="f_pre-command-parse-check"></a>
<div class=definition>
<code>pre-command-parse-check</code> <i>mark</i> <i>for-sure</i> <span class="definition-kind">[Function]</span><a id="description_in_f_pre-command-parse-check"></a>
<p> </p>
</div>
<a id="hv_parse_start_function"></a>
<div class=definition>
<code>parse</code> <i>start</i> <i>function</i>  (<i>initial</i> <i>value</i> <i>start-of-parse-block</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_parse_start_function"></a>
<p> </p>
</div>
<a id="hv_parse_end_function"></a>
<div class=definition>
<code>parse</code> <i>end</i> <i>function</i>  (<i>initial</i> <i>value</i> <i>end-of-parse-block</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_parse_end_function"></a>
<p> </p>
</div>
<a id="hv_minimum_lines_parsed"></a>
<div class=definition>
<code>minimum</code> <i>lines</i> <i>parsed</i>  (<i>initial</i> <i>value</i> <i>50</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_minimum_lines_parsed"></a>
<p> </p>
</div>
<a id="hv_maximum_lines_parsed"></a>
<div class=definition>
<code>maximum</code> <i>lines</i> <i>parsed</i>  (<i>initial</i> <i>value</i> <i>500</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_maximum_lines_parsed"></a>
<p> </p>
</div>
<a id="hv_defun_parse_goal"></a>
<div class=definition>
<code>defun</code> <i>parse</i> <i>goal</i>  (<i>initial</i> <i>value</i> <i>2</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_defun_parse_goal"></a>
<p>
pre-command-parse-check calls Parse Start Function and Parse End
Function on mark to get two marks. It then parses all the lines
between the marks including the complete lines they point into. When
for-sure is non-nil, this parses the area regardless of any cached
information about the lines. Every command that uses the following
routines calls this before doing so.</p>
<p>The default values of the start and end variables use Minimum Lines
Parsed, Maximum Lines Parsed, and Defun Parse Goal to determine how
big a region to parse. These two functions always include at least the
minimum number of lines before and after the mark passed to them. They
try to include Defun Parse Goal number of top level forms before and
after the mark passed them, but these functions never return marks
that include more than the maximum number of lines before or after the
mark passed to them.
                    </p>
</div>
<a id="f_form-offset"></a>
<div class=definition>
<code>form-offset</code> <i>mark</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_form-offset"></a>
<p>
This tries to move mark count forms forward if positive or -count
forms backwards if negative. Mark is always moved. If there were
enough forms in the appropriate direction, this returns mark,
otherwise nil.
                    </p>
</div>
<a id="f_top-level-offset"></a>
<div class=definition>
<code>top-level-offset</code> <i>mark</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_top-level-offset"></a>
<p>
This tries to move mark count top level forms forward if positive or
-count top level forms backwards if negative. If there were enough top
level forms in the appropriate direction, this returns mark, otherwise
nil. Mark is moved only if this is successful.
                    </p>
</div>
<a id="f_mark-top-level-form"></a>
<div class=definition>
<code>mark-top-level-form</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-top-level-form"></a>
<p>
This moves mark1 and mark2 to the beginning and end, respectively, of
the current or next top level form. Mark1 is used as a reference to
start looking. The marks may be altered even if unsuccessful. If
successful, return mark2, else nil. Mark2 is left at the beginning of
the line following the top level form if possible, but if the last
line has text after the closing parenthesis, this leaves the mark
immediately after the form.
                    </p>
</div>
<a id="f_defun-region"></a>
<div class=definition>
<code>defun-region</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_defun-region"></a>
<p>
This returns a region around the current or next defun with respect to
mark. Mark is not used to form the region. If there is no appropriate
top level form, this signals an editor-error. This calls
pre-command-parse-check first.
                    </p>
</div>
<a id="f_inside-defun-p"></a>
<div class=definition>
<code>inside-defun-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_inside-defun-p"></a>
<p> </p>
</div>
<a id="f_start-defun-p"></a>
<div class=definition>
<code>start-defun-p</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_start-defun-p"></a>
<p>
These return, respectively, whether mark is inside a top level form or
at the beginning of a line immediately before a character whose Lisp
Syntax (see <a href="#system-defined-character-attributes">System Defined Character Attributes</a>) 
value is :opening-paren.
                    </p>
</div>
<a id="f_forward-up-list"></a>
<div class=definition>
<code>forward-up-list</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_forward-up-list"></a>
<p> </p>
</div>
<a id="f_backward-up-list"></a>
<div class=definition>
<code>backward-up-list</code> <i>mark</i> <span class="definition-kind">[Function]</span><a id="description_in_f_backward-up-list"></a>
<p>
Respectively, these move mark immediately past a character whose Lisp
Syntax (see <a href="#system-defined-character-attributes">System Defined Character Attributes</a>) 
value is :closing-paren or immediately before
a character whose Lisp Syntax value is :opening-paren.
                    </p>
</div>
<a id="f_valid-spot"></a>
<div class=definition>
<code>valid-spot</code> <i>mark</i> <i>forwardp</i> <span class="definition-kind">[Function]</span><a id="description_in_f_valid-spot"></a>
<p>
This returns t or nil depending on whether the character indicated by
mark is a valid spot. When forwardp is set, use the character after
mark and vice versa. Valid spots exclude commented text, inside
strings, and character quoting.
                    </p>
</div>
<a id="f_defindent"></a>
<div class=definition>
<code>defindent</code> <i>name</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_defindent"></a>
<p>
This defines the function with name to have count special
arguments. indent-for-lisp, the value of <a href="#hv_indent_function"><CODE>"Indent Function"</CODE></a>
in Lisp mode, uses this to specially indent these arguments. For
example, do has two, with-open-file has one, etc. There are many of
these defined by the system including definitions for special Hemlock
forms. Name is a simple-string, case insensitive and purely textual
(that is, not read by the Lisp reader); therefore, "with-a-mumble" is
distinct from "mumble:with-a-mumble".
                    </p>
</div>
</div>
<a id="english-text-buffers"></a>
<H4>English Text Buffers</H4>
<div class="section">
<p>
This section describes some routines that understand basic English
language forms.
            </p>
<a id="f_word-offset"></a>
<div class=definition>
<code>word-offset</code> <i>mark</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_word-offset"></a>
<p>
This moves mark count words forward (if positive) or backwards (if
negative). If mark is in the middle of a word, that counts as one. If
there were count (-count if negative) words in the appropriate
direction, this returns mark, otherwise nil. This always moves mark. A
word lies between two characters whose Word Delimiter attribute value
is 1 (see <a href="#system-defined-character-attributes">System Defined Character Attributes</a>).
                    </p>
</div>
<a id="f_sentence-offset"></a>
<div class=definition>
<code>sentence-offset</code> <i>mark</i> <i>count</i> <span class="definition-kind">[Function]</span><a id="description_in_f_sentence-offset"></a>
<p>
This moves mark count sentences forward (if positive) or backwards (if negative). If mark is in the middle of a sentence, that counts as one. If there were count (-count if negative) sentences in the appropriate direction, this returns mark, otherwise nil. This always moves mark. </p>
<p>A sentence ends with a character whose Sentence Terminator attribute
is 1 followed by two spaces, a newline, or the end of the buffer. The
terminating character is optionally followed by any number of
characters whose Sentence Closing Char attribute is 1. A sentence
begins after a previous sentence ends, at the beginning of a
paragraph, or at the beginning of the buffer.
                    </p>
</div>
<a id="f_paragraph-offset"></a>
<div class=definition>
<code>paragraph-offset</code> <i>mark</i> <i>count</i> <code>&amp;optional</code> <i>prefix</i> <span class="definition-kind">[Function]</span><a id="description_in_f_paragraph-offset"></a>
<p> </p>
</div>
<a id="hv_paragraph_delimiter_function"></a>
<div class=definition>
<code>paragraph</code> <i>delimiter</i> <i>function</i>  (<i>initial</i> <i>value</i> <i></i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_paragraph_delimiter_function"></a>
<p>
This moves mark count paragraphs forward (if positive) or backwards
(if negative). If mark is in the middle of a paragraph, that counts as
one. If there were count (-count if negative) paragraphs in the
appropriate direction, this returns mark, otherwise nil. This only
moves mark if there were enough paragraphs.</p>
<p>Paragraph Delimiter Function holds a function that takes a mark,
typically at the beginning of a line, and returns whether or not the
current line should break the paragraph. default-para-delim-function
returns t if the next character, the first on the line, has a
Paragraph Delimiter attribute value of 1. This is typically a space,
for an indented paragraph, or a newline, for a block style. Some modes
require a more complicated determinant; for example, Scribe modes adds
some characters to the set and special cases certain formatting
commands.
                    </p>
<p>
Prefix defaults to <a href="#hv_fill_prefix"><CODE>"Fill Prefix"</CODE></a>, and the right
prefix is necessary to correctly skip paragraphs. If prefix is
non-nil, and a line begins with prefix, then the scanning process
skips the prefix before invoking the Paragraph Delimiter
Function. Note, when scanning for paragraph bounds, and prefix is
non-nil, lines are potentially part of the paragraph regardless of
whether they contain the prefix; only the result of invoking the
delimiter function matters.
                    </p>
<p>
The programmer should be aware of an idiom for finding the end of the
current paragraph. Assume paragraphp is the result of moving mark one
paragraph, then the following correctly determines whether there
actually is a current paragraph:
<pre class="source-code">
(or paragraphp
  (and (last-line-p mark)
       (end-line-p mark)
       (not (blank-line-p (mark-line mark))))) 
</pre>
</p>
<p>
In this example mark is at the end of the last paragraph in the
buffer, and there is no last newline character in the
buffer. paragraph-offset would have returned nil since it could not
skip any paragraphs since mark was at the end of the current and last
paragraph. However, you still have found a current paragraph on which
to operate. mark-paragraph understands this problem.
                    </p>
</div>
<a id="f_mark-paragraph"></a>
<div class=definition>
<code>mark-paragraph</code> <i>mark1</i> <i>mark2</i> <span class="definition-kind">[Function]</span><a id="description_in_f_mark-paragraph"></a>
<p>
This marks the next or current paragraph, setting mark1 to the
beginning and mark2 to the end. This uses <a href="#hv_fill_prefix"><CODE>"Fill Prefix"</CODE></a>.
Mark1 is always on the first line of the paragraph, regardless
of whether the previous line is blank. Mark2 is typically at the
beginning of the line after the line the paragraph ends on, this
returns mark2 on success. If this cannot find a paragraph, then the
marks are left unmoved, and nil is returned.
                    </p>
</div>
</div>
<a id="logical-pages"></a>
<H4>Logical Pages</H4>
<div class="section">
<p>
Logical pages are not supported at this time.
            </p>
</div>
<a id="filling"></a>
<H4>Filling</H4>
<div class="section">
<p>
Filling is an operation on text that breaks long lines at word
boundaries before a given column and merges shorter lines together in
an attempt to make each line roughly the specified length. This is
different from justification which tries to add whitespace in awkward
places to make each line exactly the same length. Hemlock's filling
optionally inserts a specified string at the beginning of each
line. Also, it eliminates extra whitespace between lines and words,
but it knows two spaces follow sentences.
            </p>
<a id="hv_fill_column"></a>
<div class=definition>
<code>fill</code> <i>column</i>  (<i>initial</i> <i>value</i> <i>75</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_fill_column"></a>
<p> </p>
</div>
<a id="hv_fill_prefix"></a>
<div class=definition>
<code>fill</code> <i>prefix</i>  (<i>initial</i> <i>value</i> <i>nil</i>) <span class="definition-kind">[Hemlock Variable]</span><a id="description_in_hv_fill_prefix"></a>
<p>
These variables hold the default values of the prefix and column
arguments to Hemlock's filling primitives. If Fill Prefix is nil, then
there is no fill prefix.
                    </p>
</div>
<a id="f_fill-region"></a>
<div class=definition>
<code>fill-region</code> <i>region</i> <code>&amp;optional</code> <i>prefix</i> <i>column</i> <span class="definition-kind">[Function]</span><a id="description_in_f_fill-region"></a>
<p>
This deletes any blank lines in region and fills it according to
prefix and column. Prefix and column default to Fill Prefix and Fill
Column.
                    </p>
</div>
<a id="f_fill-region-by-paragraphs"></a>
<div class=definition>
<code>fill-region-by-paragraphs</code> <i>region</i> <code>&amp;optional</code> <i>prefix</i> <i>column</i> <span class="definition-kind">[Function]</span><a id="description_in_f_fill-region-by-paragraphs"></a>
<p>
This finds paragraphs within region and fills them
with fill-region. This ignores blank lines between paragraphs. Prefix
and column default to Fill Prefix and Fill Column.
                    </p>
</div>
</div>
</div>
<a id="utilities"></a>
<H3>Utilities</H3>
<div class="section">
<p>
This chapter describes a number of utilities for manipulating some
types of objects Hemlock uses to record information. String-tables are
used to store names of variables, commands, modes, and buffers. Ring
lists can be used to provide a kill ring, recent command history, or
other user-visible features.
        </p>
<a id="string-table-functions"></a>
<H4>String-table Functions</H4>
<div class="section">
<p>
String tables are similar to Common Lisp hash tables in that they
associate a value with an object. There are a few useful differences:
in a string table the key is always a case insensitive string, and
primitives are provided to facilitate keyword completion and
recognition. Any type of string may be added to a string table, but
the string table functions always return simple-string's.</p>
<p>A string entry in one of these tables may be thought of as being
separated into fields or keywords. The interface provides keyword
completion and recognition which is primarily used to implement some
Echo Area commands. These routines perform a prefix match on a
field-by-field basis allowing the ambiguous specification of earlier
fields while going on to enter later fields. While string tables may
use any string-char as a separator, the use of characters other than
space may make the Echo Area commands fail or work unexpectedly.
            </p>
<a id="f_make-string-table"></a>
<div class=definition>
<code>make-string-table</code> <span class="definition-kind">[Function]</span><a id="description_in_f_make-string-table"></a>
<p>
This function creates an empty string table that uses separator as the
character, which must be a string-char, that distinguishes
fields. Initial-contents specifies an initial set of strings and their
values in the form of a dotted a-list, for example:
<pre class="source-code">
'(("Global" . t) ("Mode" . t) ("Buffer" . t))
</pre>
</p>
</div>
<a id="f_string-table-p"></a>
<div class=definition>
<code>string-table-p</code> <i>string-table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_string-table-p"></a>
<p>
This function returns t if string-table is a string-table object,
otherwise nil.
                    </p>
</div>
<a id="f_string-table-separator"></a>
<div class=definition>
<code>string-table-separator</code> <i>string-table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_string-table-separator"></a>
<p>
This function returns the separator character given to
make-string-table.
                    </p>
</div>
<a id="f_delete-string"></a>
<div class=definition>
<code>delete-string</code> <i>string</i> <i>table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_delete-string"></a>
<p> </p>
</div>
<a id="f_clrstring"></a>
<div class=definition>
<code>clrstring</code> <i>table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_clrstring"></a>
<p>
delete-string removes any entry for string from the string-table
table, returning t if there was an entry. clrstring removes all
entries from table.
                    </p>
</div>
<a id="f_getstring"></a>
<div class=definition>
<code>getstring</code> <i>string</i> <i>table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_getstring"></a>
<p>
This function returns as multiple values, first the value
corresponding to the string if it is found and nil if it isn't, and
second t if it is found and nil if it isn't.</p>
<p>This may be set with setf to add a new entry or to store a new value
for a string. It is an error to try to insert a string with more than
one field separator character occurring contiguously.
                    </p>
</div>
<a id="f_complete-string"></a>
<div class=definition>
<code>complete-string</code> <i>string</i> <i>tables</i> <span class="definition-kind">[Function]</span><a id="description_in_f_complete-string"></a>
<p>
This function completes string as far as possible over the list of
tables, returning five values. It is an error for tables to have
different separator characters. The five return values are as follows:
                    </p>
<ul><li><p>
The maximal completion of the string or nil if there is none.
                            </p>
</ul>
<ul><li><p>
An indication of the usefulness of the returned string:
                            </p>
</ul>
<dl><dt>:none</dt>
<dd><p>
There is no completion of string.
                                </p>
</dd>
<dt>:complete</dt>
<dd><p>
The completion is a valid entry, but other valid
completions exist too. This occurs when the supplied string is an
entry as well as initial substring of another entry.
                                </p>
</dd>
<dt>:unique</dt>
<dd><p>
The completion is a valid entry and unique.
                                </p>
</dd>
<dt>:ambiguous</dt>
<dd><p>
The completion is invalid; get-string would return nil
and nil if given the returned string.
                                </p>
</dd>
</dl>
<ul><li><p>
The value of the string when the completion is :unique or
:complete, otherwise nil.
                            </p>
</ul>
<ul><li><p>
An index, or nil, into the completion returned, indicating where
the addition of a single field to string ends. The command Complete
Field uses this when the completion contains the addition to string
of more than one field.
                            </p>
</ul>
<ul><li><p>
An index to the separator following the first ambiguous field when
the completion is :ambiguous or :complete, otherwise nil.
                            </p>
</ul>
</div>
<a id="f_find-ambiguous"></a>
<div class=definition>
<code>find-ambiguous</code> <i>string</i> <i>table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_find-ambiguous"></a>
<p> </p>
</div>
<a id="f_find-containing"></a>
<div class=definition>
<code>find-containing</code> <i>string</i> <i>table</i> <span class="definition-kind">[Function]</span><a id="description_in_f_find-containing"></a>
<p>
find-ambiguous returns a list in alphabetical order of all the strings
in table matching string. This considers an entry as matching if each
field in string, taken in order, is an initial substring of the
entry's fields; entry may have fields remaining.</p>
<p>find-containing is similar, but it ignores the order of the fields in
string, returning all strings in table matching any permutation of the
fields in string.
                    </p>
</div>
<a id="m_do-strings"></a>
<div class=definition>
<code>do-strings</code>  (<i>string-var</i> <i>value-var</i> <i>table</i> <i>result</i>) <i>declaration</i> <i>tag</i> <i>statement</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_do-strings"></a>
<p>
This macro iterates over the strings in table in alphabetical
order. On each iteration, it binds string-var to an entry's string and
value-var to an entry's value.
                    </p>
</div>
</div>
<a id="ring-functions"></a>
<H4>Ring Functions</H4>
<div class="section">
<p>
There are various purposes in an editor for which a ring of values can
be used, so Hemlock provides a general ring buffer type. It is used
for maintaining a ring of  <a href="#kill-ring">killed regions</a>, a ring of
<a href="#the-current-buffer">marks</a>, or a ring of command strings which various
modes and commands maintain as a history mechanism.
            </p>
<a id="f_make-ring"></a>
<div class=definition>
<code>make-ring</code> <i>length</i> <code>&amp;optional</code> <i>delete-function</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-ring"></a>
<p>
Makes an empty ring object capable of holding up to length Lisp
objects. Delete-function is a function that each object is passed to
before it falls off the end. Length must be greater than zero.
                    </p>
</div>
<a id="f_ringp"></a>
<div class=definition>
<code>ringp</code> <i>ring</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ringp"></a>
<p>
Returns t if ring is a ring object, otherwise nil.
                    </p>
</div>
<a id="f_ring-length"></a>
<div class=definition>
<code>ring-length</code> <i>ring</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ring-length"></a>
<p>
Returns as multiple-values the number of elements which ring currently
holds and the maximum number of elements which it may hold.
                    </p>
</div>
<a id="f_ring-ref"></a>
<div class=definition>
<code>ring-ref</code> <i>ring</i> <i>index</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ring-ref"></a>
<p>
Returns the index'th item in the ring, where zero is the index of the
most recently pushed. This may be set with setf.
                    </p>
</div>
<a id="f_ring-push"></a>
<div class=definition>
<code>ring-push</code> <i>object</i> <i>ring</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ring-push"></a>
<p>
Pushes object into ring, possibly causing the oldest item to go away.
                    </p>
</div>
<a id="f_ring-pop"></a>
<div class=definition>
<code>ring-pop</code> <i>ring</i> <span class="definition-kind">[Function]</span><a id="description_in_f_ring-pop"></a>
<p>
Removes the most recently pushed object from ring and returns it. If
the ring contains no elements then an error is signalled.
                    </p>
</div>
<a id="f_rotate-ring"></a>
<div class=definition>
<code>rotate-ring</code> <i>ring</i> <i>offset</i> <span class="definition-kind">[Function]</span><a id="description_in_f_rotate-ring"></a>
<p>
With a positive offset, rotates ring forward that many times. In a
forward rotation the index of each element is reduced by one, except
the one which initially had a zero index, which is made the last
element. A negative offset rotates the ring the other way.
                    </p>
</div>
</div>
<a id="undoing-commands"></a>
<H4>Undoing commands</H4>
<div class="section">
<p>
No API to the undo facility is provided at this time.
            </p>
</div>
</div>
<a id="miscellaneous_in_hemlock-programming"></a>
<H3>Miscellaneous</H3>
<div class="section">
<p>
This chapter is somewhat of a catch-all for comments and features that
don't fit well anywhere else.
        </p>
<a id="key-events"></a>
<H4>Key-events</H4>
<div class="section">
<a id="introduction_in_key-events"></a>
<H5>Introduction</H5>
<div class="section">
<p>
The canonical representation of editor input is a key-event
structure. Users can bind commands to keys, which
are non-empty sequences of key-events. A key-event consists of
an identifying token known as a keysym and a field of bits
representing modifiers. Users define keysyms by supplying names
that reflect the legends on their keyboard's keys.
Users define modifier names similarly, but the system chooses the
bit and mask for recognizing the modifier. You can
use keysym and modifier names to textually specify key-events and
Hemlock keys in a #k syntax. The following are some examples:
<pre class="source-code">
#k"C-u"
#k"Control-u"
#k"c-m-z"
#k"control-x meta-d"
#k"a"
#k"A"
#k"Linefeed"
</pre>
</p>
<p>
This is convenient for use within code and in init files containing
bind-key calls.</p>
<p>The #k syntax is delimited by double quotes, but the system parses the
contents rather than reading it as a Common Lisp string. Within the
double quotes, spaces separate multiple key-events. A single key-event
optionally starts with modifier names terminated by hyphens. Modifier
names are alphabetic sequences of characters which the system uses
case-insensitively. Following modifiers is a keysym name, which is
case-insensitive if it consists of multiple characters, but if the
name consists of only a single character, then it is case-sensitive.</p>
<p>You can escape special characters --- hyphen, double quote, open angle
bracket, close angle bracket, and space --- with a backslash, and you
can specify a backslash by using two contiguously. You can use angle
brackets to enclose a keysym name with many special characters in
it. Between angle brackets appearing in a keysym name position, there
are only two special characters, the closing angle bracket and
backslash.
                </p>
</div>
<a id="interface"></a>
<H5>Interface</H5>
<div class="section">
<a id="f_define-keysym"></a>
<div class=definition>
<code>define-keysym</code> <i>keysym</i> <i>preferred-name</i> <code>&amp;rest</code> <i>other-names</i> <span class="definition-kind">[Function]</span><a id="description_in_f_define-keysym"></a>
<p>
This function establishes a mapping from preferred-name to keysym for
purposes of #k syntax. Other-names also map to keysym, but the system
uses preferred-name when printing key-events. The names are
case-insensitive simple-strings; however, if the string contains a
single character, then it is used case-sensitively. Redefining a
keysym or re-using names has undefined effects.</p>
<p>Keysym can be any object, but generally it is either an integer
representing the window-system code for the event, or a keyword
which allows the mapping of the keysym to its code to be defined
separately.
                        </p>
</div>
<a id="f_define-keysym-code"></a>
<div class=definition>
<code>define-keysym-code</code> <i>keysym</i> <i>code</i> <span class="definition-kind">[Function]</span><a id="description_in_f_define-keysym-code"></a>
<p>
Defines the window-system code for the key event which in Hemlock is
represented by keysym.
                        </p>
</div>
<a id="f_define-mouse-keysym"></a>
<div class=definition>
<code>define-mouse-keysym</code> <i>button</i> <i>keysym</i> <i>name</i> <i>shifted-bit</i> <i>event-key</i> <span class="definition-kind">[Function]</span><a id="description_in_f_define-mouse-keysym"></a>
<p>
This function defines keysym named name for key-events representing
mouse click events. Shifted-bit is a defined modifier name that
translate-mouse-key-event sets in the key-event it returns whenever
the shift bit is set in an incoming event.
                        </p>
</div>
<a id="f_name-keysym"></a>
<div class=definition>
<code>name-keysym</code> <i>name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_name-keysym"></a>
<p>
This function returns the keysym named name. If name is unknown, this
returns nil.
                        </p>
</div>
<a id="f_keysym-names"></a>
<div class=definition>
<code>keysym-names</code> <i>keysym</i> <span class="definition-kind">[Function]</span><a id="description_in_f_keysym-names"></a>
<p>
This function returns the list of all names for keysym. If keysym is
undefined, this returns nil.
                        </p>
</div>
<a id="f_keysym-preferred-name"></a>
<div class=definition>
<code>keysym-preferred-name</code> <i>keysym</i> <span class="definition-kind">[Function]</span><a id="description_in_f_keysym-preferred-name"></a>
<p>
This returns the preferred name for keysym, how it is typically
printed. If keysym is undefined, this returns nil.
                        </p>
</div>
<a id="f_define-key-event-modifier"></a>
<div class=definition>
<code>define-key-event-modifier</code> <i>long-name</i> <i>short-name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_define-key-event-modifier"></a>
<p>
This establishes long-name and short-name as modifier names for
purposes of specifying key-events in #k syntax. The names are
case-insensitive strings. If either name is already defined,
this signals an error.</p>
<p>The system defines the following default modifiers (first the long
name, then the short name):
                        </p>
<ul><li><p>
"Hyper", "H"
                                </p>
<li><p>
"Super", "S"
                                </p>
<li><p>
"Meta", "M"
                                </p>
<li><p>
"Control", "C"
                                </p>
<li><p>
"Shift", "Shift"
                                </p>
<li><p>
"Lock", "Lock"
                                </p>
</ul>
</div>
<a id="v_all-modifier-names"></a>
<div class=definition>
<code>*all-modifier-names*</code> <span class="definition-kind">[Variable]</span><a id="description_in_v_all-modifier-names"></a>
<p>
This variable holds all the defined modifier names.
                        </p>
</div>
<a id="f_make-key-event-bits"></a>
<div class=definition>
<code>make-key-event-bits</code> <code>&amp;rest</code> <i>modifier-names</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-key-event-bits"></a>
<p>
This function returns bits suitable for make-key-event from the
supplied modifier-names. If any name is undefined, this signals an
error.
                        </p>
</div>
<a id="f_key-event-modifier-mask"></a>
<div class=definition>
<code>key-event-modifier-mask</code> <i>modifier-name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-modifier-mask"></a>
<p>
This function returns a mask for modifier-name. This mask is suitable
for use with key-event-bits. If modifier-name is undefined, this
signals an error.
                        </p>
</div>
<a id="f_key-event-bits-modifiers"></a>
<div class=definition>
<code>key-event-bits-modifiers</code> <i>bits</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-bits-modifiers"></a>
<p>
This returns a list of key-event modifier names, one for each modifier
set in bits.
                        </p>
</div>
<a id="f_make-key-event"></a>
<div class=definition>
<code>make-key-event</code> <i>object</i> <i>bits</i> <span class="definition-kind">[Function]</span><a id="description_in_f_make-key-event"></a>
<p>
This function returns a key-event described by object with
bits. Object is one of keysym, string, or key-event. When object is a
key-event, this uses key-event-keysym. You can form bits with
make-key-event-bits or key-event-modifier-mask.
                        </p>
</div>
<a id="f_key-event-p"></a>
<div class=definition>
<code>key-event-p</code> <i>object</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-p"></a>
<p>
This function returns whether object is a key-event.
                        </p>
</div>
<a id="f_key-event-bits"></a>
<div class=definition>
<code>key-event-bits</code> <i>key-event</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-bits"></a>
<p>
This function returns the bits field of a key-event.
                        </p>
</div>
<a id="f_key-event-keysym"></a>
<div class=definition>
<code>key-event-keysym</code> <i>key-event</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-keysym"></a>
<p>
This function returns the keysym field of a key-event.
                        </p>
</div>
<a id="f_char-key-event"></a>
<div class=definition>
<code>char-key-event</code> <i>character</i> <span class="definition-kind">[Function]</span><a id="description_in_f_char-key-event"></a>
<p>
This function returns the key-event associated with character. You can
associate a key-event with a character by setf-ing this form.
                        </p>
</div>
<a id="f_key-event-char"></a>
<div class=definition>
<code>key-event-char</code> <i>key-event</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-char"></a>
<p>
This function returns the character associated with key-event. You can
associate a character with a key-event by setf'ing this form. The
system defaultly translates key-events in some implementation
dependent way for text insertion; for example, under an ASCII system,
the key-event #k"C-h", as well as #k"backspace" would map to the
Common Lisp character that causes a backspace.
                        </p>
</div>
<a id="f_key-event-bit-p"></a>
<div class=definition>
<code>key-event-bit-p</code> <i>key-event</i> <i>bit-name</i> <span class="definition-kind">[Function]</span><a id="description_in_f_key-event-bit-p"></a>
<p>
This function returns whether key-event has the bit set named by
bit-name. This signals an error if bit-name is undefined.
                        </p>
</div>
<a id="m_do-alpha-key-events"></a>
<div class=definition>
<code>do-alpha-key-events</code>  (<i>var</i> <i>kind</i> <code>&amp;optional</code> <i>result</i>) <i>form</i> <span class="definition-kind">[Macro]</span><a id="description_in_m_do-alpha-key-events"></a>
<p>
This macro evaluates each form with var bound to a key-event
representing an alphabetic character. Kind is one of :lower, :upper,
or :both, and this binds var to each key-event in order a-z A-Z.
When :both is specified, this processes lowercase letters
first.
                        </p>
</div>
<a id="f_pretty-key-string"></a>
<div class=definition>
<code>pretty-key-string</code> <i>key</i> <code>&amp;optional</code> <i>stream</i> <i>long-names-p</i> <span class="definition-kind">[Function]</span><a id="description_in_f_pretty-key-string"></a>
<p>
This returns a string representing key, a key-event or vector of key-events, in a
user-expected fashion. Long-names-p indicates whether
modifiers should be described by their long or short name.
                        </p>
</div>
</div>
</div>
</div>
</div>
<a id="questions-and-answers"></a>
<H2>Questions and Answers</H2>
<div class="section">
<ul style="list-style: none">
<li><a href="#how-can-i-do-nonblocking-aka-unbuffered-and-raw-io">
How can I do nonblocking (aka "unbuffered" and "raw") IO?</a>
<ul style="list-style: none">
</ul>
<li><a href="#i-m-using-the-graphics-demos.-why-doesn-t-the-menubar-change">
I'm using the graphics demos. Why doesn't the menubar
      change?</a>
<ul style="list-style: none">
</ul>
<li><a href="#i-m-using-slime-and-cocoa.-why-doesn-t-standard-output-seem-to-work">
I'm using Slime and Cocoa. Why doesn't *standard-output*
      seem to work? </a>
<ul style="list-style: none">
</ul>
</ul>
<a id="how-can-i-do-nonblocking-aka-unbuffered-and-raw-io"></a>
<H3>How can I do nonblocking (aka "unbuffered" and "raw") IO?</H3>
<div class="section">
<p>There's some code for manipulating TTY modes in
      "ccl:library;pty.lisp".</p>
<pre class="source-code"><p>
? (require "PTY")</p>
<p>? (ccl::disable-tty-local-modes 0 #$ICANON)
T
      </p>
</pre>
<p>will turn off "input canonicalization" on file descriptor
      0, which is at least part of what you need to do here.  This
      disables the #$ICANON mode, which tells the OS not to do any
      line-buffering or line-editing.  Of course, this only has any
      effect in situations where the OS ever does that, which means
      when stdin is a TTY or PTY.</p>
<p>If the #$ICANON mode is disabled, you can do things like:</p>
<pre class="source-code">
? (progn (read-char) (read-char))
a
#\a
      
</pre>
<p>(where the first READ-CHAR consumes the newline, which
      isn't really necessary to make the reader happy anymore.)  So,
      you can do:</p>
<pre class="source-code">
? (read-char)
#\Space
</pre>
<p>(where there's a space after the close-paren) without
      having to type a newline.</p>
</div>
<a id="i-m-using-the-graphics-demos.-why-doesn-t-the-menubar-change"></a>
<H3>I'm using the graphics demos. Why doesn't the menubar
      change?</H3>
<div class="section">
<p>When you interact with text-only Clozure CL, you're either
      in Terminal or in Emacs, running Clozure CL as a subprocess.  When
      you load Cocoa or the graphical environment, the subprocess does
      some tricky things that turn it into a full-fledged Application,
      as far as the OS is concerned.</p>
<p>      So, it gets its own icon in the dock, and its own menubar,
      and so on.  It can be confusing, because standard input and
      output will still be connected to Terminal or Emacs, so you can
      still type commands to Clozure CL from there.  To see the menubar
      you loaded, or the windows you opened, just click on the Clozure CL
      icon in the dock.</p>
</div>
<a id="i-m-using-slime-and-cocoa.-why-doesn-t-standard-output-seem-to-work"></a>
<H3>I'm using Slime and Cocoa. Why doesn't *standard-output*
      seem to work? </H3>
<div class="section">
<p>This comes up if you're using the Slime interface
      to run Clozure CL under Emacs, and you are doing Cocoa programming
      which involves printing to *standard-output*.  It seems as
      though the output goes nowhere; no error is reported, but it
      doesn't appear in the *slime-repl* buffer.</p>
<p>      For the most part, this is only relevant when you are
      trying to insert debug code into your event handlers.  The SLIME
      listener runs in a thread where the standard stream variables
      (like <CODE>*STANDARD-OUTPUT* and</CODE> and
      <CODE>*TERMINAL-IO*</CODE> are bound to the stream used to
      communicate with Emacs; the Cocoa event thread has its own
      bindings of these standard stream variables, and output to these
      streams goes to the *inferior-lisp* buffer instead.  Look for it
      there.</p>
</div>
</div>
<a id="glossary-of-terms"></a>
<div class=glossary><h1>Glossary of Terms</h1><dl><a id="application_bundle"></a>
<dt>application bundle<dd><p>A specially-structured directory that Mac OS X
		recognizes as a
		launchable <a href="#cocoa">Cocoa</a>
		application. Graphical applications on Mac OS X are
		represented as application bundles.</p>
<a id="ccl_directory"></a>
<dt>ccl directory<dd><p>The directory containing Clozure CL's source
code and interface databases.  The <CODE>ccl</CODE> logical host should refer
to this directory.</p>
<a id="cocoa"></a>
<dt>Cocoa<dd><p>The standard user-interface libraries and frameworks
		provided by Apple for development of applications on Mac OS
		X.</p>
<a id="code_point"></a>
<dt>code point<dd><p>A value in the Unicode code space; that is, a
                   non-negative integer below <CODE>char-code-limit</CODE> (#x110000).</p>
<a id="creator_code"></a>
<dt>creator code<dd><p>A four-character identifier used in Mac OS X to uniquely
		identify an application.</p>
<a id="displaced_array"></a>
<dt>displaced array<dd><p>An array with no storage of its own for elements, which
		points to the storage of another array, called its
		target. Reading or writing the elements of the displaced array
		returns or changes the contents of the target.</p>
<a id="fasl_file"></a>
<dt>fasl file<dd><p>A file containing compiled lisp code that the Lisp is
		able to quickly load and use. A "fast-load" file.</p>
<a id="heap_image"></a>
<dt>heap image<dd><p>The in-memory state of a running Lisp system, containing
		functions, data structures, variables, and so on. Also, a file
		containing archived versions of these data in a format that
		can be loaded and reconstituted by the
		Lisp <a href="#lisp_kernel">lisp kernel</a>. A
		working Clozure CL system consists of the kernel and
		a <a href="#heap_image">heap image</a>.</p>
<a id="hemlock"></a>
<dt>Hemlock<dd><p>A text editor, written in Common Lisp, similar in
		features to Emacs. Hemlock was originally developed as part of
		CMU Common Lisp. A portable version of Hemlock is built into
		the Clozure CL <a href="#ide">IDE</a>.</p>
<a id="ide"></a>
<dt>IDE<dd><p>"Integrated Development Environment". In the context of
		Clozure CL, "the IDE" refers to the experimental <a href="#cocoa">Cocoa</a>
		windowing development environment provided in source form with
		Clozure CL distributions.</p>
<a id="interfacebuilder"></a>
<dt>InterfaceBuilder<dd><p>An application supplied by Apple with their developer
		tools that can be used to interactively build user-interface
		elements for <a href="#cocoa">Cocoa</a>
		applications.</p>
<a id="lisp_kernel"></a>
<dt>lisp kernel<dd><p>The binary executable program that implements the lowest
		levels of the Lisp system. A working Clozure CL system consists of
		the kernel and
		a <a href="#heap_image">heap image</a>.</p>
<a id="listener_window"></a>
<dt>listener window<dd><p>In the <a href="#ide">IDE</a>,
		a <a href="#cocoa">Cocoa</a>
		window that contains a pseudo-terminal session that
		communicates with a Lisp <a href="#repl">REPL</a>.</p>
<a id="memory-mapped_file"></a>
<dt>memory-mapped file<dd><p>A file whose contents are accessible as a range of
		memory addresses. Some operating systems support this feature,
		in which the virtual memory subsystem arranges for a range of
		virtual memory addresses to point to the contents of an open
		file. Programs can then gain access to the file's contents by
		operating on memory addresses in that range. Access to the
		file's contents is valid only as long as the file remains
		open.</p>
<a id="nibfile"></a>
<dt>nibfile<dd><p>A data file created by
		Apple's <a href="#interfacebuilder">InterfaceBuilder</a>
		application, which contains archived Objective-C objects that
		define user-interface elements for
		a <a href="#cocoa">Cocoa</a>
		application. Under Mac OS
		X, <a href="#cocoa">Cocoa</a> applications
		typically create their user interface elements by reading
		nibfiles and unarchiving the objects in them.</p>
<a id="repl"></a>
<dt>REPL<dd><p>"Read-eval-print loop". The interactive shell provided
		by Clozure CL for interaction with Lisp.</p>
<a id="s-expression"></a>
<dt>s-expression<dd><p>The simplest, most general element of Lisp syntax. An
		s-expression may be an atom (such as a symbol, integer, or
		string), or it may be a list of s-expressions.</p>
<a id="special_variable"></a>
<dt>special variable<dd><p>A variable whose binding is in the dynamic
		environment. Special variables are essentially equivalent to
		global variables in languages other than Lisp. A special
		variable binding is visible in any lexical environment, so
		long as a lexical binding has not shadowed it.</p>
<a id="static_variable"></a>
<dt>static variable<dd><p>In Clozure CL, a variable whose value is shared across all
		threads, and which may not be dynamically rebound. Changing a
		static variable's value in one thread causes all threads to
		see the new value. Attempting to dynamically rebind the
		variable (for instance, by using <CODE>LET</CODE>, or using
		the variable name as a parameter in a <CODE>LAMBDA</CODE>
		form) signals an error.</p>
<a id="toplevel_function"></a>
<dt>toplevel function<dd><p>The function executed by Lisp automatically once its
		startup is complete. Clozure CL's default toplevel is the
		interactive <a href="#repl">read-eval-print loop</a> that you normally use to interact with
		Lisp. You can, however, replace the toplevel with a function
		of your own design, changing Clozure CL from a Lisp development
		system into some tool of your making.</p>
<a id="type-specifier"></a>
<dt>type-specifier<dd><p>An expression that denotes a type. Type specifiers may
		be symbols (such as <CODE>CONS</CODE>
		and <CODE>STRING</CODE>), or they may be more complex
		<a href="#s-expression">S-expressions</a>
		(such as (UNSIGNED-BYTE 8)).</p>
</dl></div><a id="symbol-index"></a>
<div class=index><h1>Symbol Index</h1></div><a id="ccl-exported-symbols"></a>
<H2>CCL Exported Symbols</H2>
<div class="section">
<ul style="list-style: none">
</ul>
<a id="tab_exported-symbols"></a>
<table>
<caption>Exported Symbols</caption>
<tr><td><a href="#f_.._get-signed-longlong"><CODE>%%get-signed-longlong</CODE></a>
<td>
</tr>
<tr><td><a href="#f_._address-of"><CODE>%address-of</CODE></a>
<td><a href="#f_.._get-unsigned-longlong"><CODE>%%get-unsigned-longlong</CODE></a>
</tr>
<tr><td><a href="#f_._ff-call"><CODE>%ff-call</CODE></a>
<td><CODE>%copy-float</CODE>
</tr>
<tr><td><a href="#f_._get-cstring"><CODE>%get-cstring</CODE></a>
<td><CODE>%get-byte</CODE>
</tr>
<tr><td><CODE>%get-fixnum</CODE>
<td><a href="#f_._get-double-float"><CODE>%get-double-float</CODE></a>
</tr>
<tr><td><a href="#f_._get-ptr"><CODE>%get-ptr</CODE></a>
<td><CODE>%get-long</CODE>
</tr>
<tr><td><a href="#f_._get-signed-long"><CODE>%get-signed-long</CODE></a>
<td><a href="#f_._get-signed-byte"><CODE>%get-signed-byte</CODE></a>
</tr>
<tr><td><a href="#f_._get-single-float"><CODE>%get-single-float</CODE></a>
<td><a href="#f_._get-signed-word"><CODE>%get-signed-word</CODE></a>
</tr>
<tr><td><a href="#f_._get-unsigned-long"><CODE>%get-unsigned-long</CODE></a>
<td><a href="#f_._get-unsigned-byte"><CODE>%get-unsigned-byte</CODE></a>
</tr>
<tr><td><CODE>%get-word</CODE>
<td><a href="#f_._get-unsigned-word"><CODE>%get-unsigned-word</CODE></a>
</tr>
<tr><td><a href="#m_._incf-ptr"><CODE>%incf-ptr</CODE></a>
<td><a href="#f_._inc-ptr"><CODE>%inc-ptr</CODE></a>
</tr>
<tr><td><a href="#m_._null-ptr"><CODE>%null-ptr</CODE></a>
<td><a href="#f_._int-to-ptr"><CODE>%int-to-ptr</CODE></a>
</tr>
<tr><td><CODE>%ptr-eql</CODE>
<td><a href="#f_._null-ptr-p"><CODE>%null-ptr-p</CODE></a>
</tr>
<tr><td><a href="#f_._reference-external-entry-point"><CODE>%reference-external-entry-point</CODE></a>
<td><a href="#f_._ptr-to-int"><CODE>%ptr-to-int</CODE></a>
</tr>
<tr><td><a href="#f_._setf-macptr"><CODE>%setf-macptr</CODE></a>
<td><CODE>%set-toplevel</CODE>
</tr>
<tr><td><a href="#f_._str-from-ptr"><CODE>%str-from-ptr</CODE></a>
<td><a href="#m_._stack-block"><CODE>%stack-block</CODE></a>
</tr>
<tr><td><CODE>%word-to-int</CODE>
<td><CODE>%vstack-block</CODE>
</tr>
<tr><td><a href="#f_accept-connection"><CODE>accept-connection</CODE></a>
<td><CODE>abort-break</CODE>
</tr>
<tr><td><CODE>add-auto-flush-stream</CODE>
<td><CODE>accessor-method-slot-definition</CODE>
</tr>
<tr><td><CODE>add-direct-method</CODE>
<td><CODE>add-dependent</CODE>
</tr>
<tr><td><CODE>add-feature</CODE>
<td><CODE>add-direct-subclass</CODE>
</tr>
<tr><td><a href="#m_advise"><CODE>advise</CODE></a>
<td><CODE>add-method</CODE>
</tr>
<tr><td><a href="#f_all-processes"><CODE>all-processes</CODE></a>
<td><a href="#m_advisedp"><CODE>advisedp</CODE></a>
</tr>
<tr><td><CODE>application-init-file</CODE>
<td><CODE>application-error</CODE>
</tr>
<tr><td><CODE>arglist</CODE>
<td><CODE>apply-in-frame</CODE>
</tr>
<tr><td><CODE>assq</CODE>
<td><CODE>arglist-string</CODE>
</tr>
<tr><td><CODE>base-string-p</CODE>
<td><CODE>augment-environment</CODE>
</tr>
<tr><td><CODE>bitp</CODE>
<td><CODE>bignump</CODE>
</tr>
<tr><td><CODE>caller-functions</CODE>
<td><CODE>byte-length</CODE>
</tr>
<tr><td><CODE>catch-cancel</CODE>
<td><CODE>cancel-terminate-when-unreachable</CODE>
</tr>
<tr><td><CODE>class-direct-default-initargs</CODE>
<td><CODE>class-default-initargs</CODE>
</tr>
<tr><td><CODE>class-direct-subclasses</CODE>
<td><CODE>class-direct-slots</CODE>
</tr>
<tr><td><CODE>class-finalized-p</CODE>
<td><CODE>class-direct-superclasses</CODE>
</tr>
<tr><td><CODE>class-precedence-list</CODE>
<td><CODE>class-own-wrapper</CODE>
</tr>
<tr><td><CODE>class-slots</CODE>
<td><CODE>class-prototype</CODE>
</tr>
<tr><td><CODE>clear-clos-caches</CODE>
<td><CODE>clear-all-gf-caches</CODE>
</tr>
<tr><td><CODE>clear-gf-cache</CODE>
<td><a href="#f_clear-coverage"><CODE>clear-coverage</CODE></a>
</tr>
<tr><td><CODE>clear-open-file-streams</CODE>
<td><CODE>clear-lock-acquisition-status</CODE>
</tr>
<tr><td><CODE>close-core</CODE>
<td><CODE>clear-semaphore-notification-status</CODE>
</tr>
<tr><td><CODE>collect-heap-utilization</CODE>
<td><a href="#f_close-shared-library"><CODE>close-shared-library</CODE></a>
</tr>
<tr><td><CODE>compile-ccl</CODE>
<td><a href="#f_combine-coverage"><CODE>combine-coverage</CODE></a>
</tr>
<tr><td><CODE>compiler-let</CODE>
<td><CODE>compile-user-function</CODE>
</tr>
<tr><td><CODE>compiler-macroexpand-1</CODE>
<td><CODE>compiler-macroexpand</CODE>
</tr>
<tr><td><CODE>compiler-warning-source-note</CODE>
<td><CODE>compiler-warning-function-name</CODE>
</tr>
<tr><td><CODE>compute-applicable-methods-using-classes</CODE>
<td><CODE>compute-applicable-methods</CODE>
</tr>
<tr><td><CODE>compute-default-initargs</CODE>
<td><CODE>compute-class-precedence-list</CODE>
</tr>
<tr><td><CODE>compute-effective-slot-definition</CODE>
<td><CODE>compute-effective-method</CODE>
</tr>
<tr><td><a href="#f_configure-egc"><CODE>configure-egc</CODE></a>
<td><CODE>compute-slots</CODE>
</tr>
<tr><td><CODE>copy-file</CODE>
<td><CODE>constant-symbol-p</CODE>
</tr>
<tr><td><CODE>copy-instance</CODE>
<td><CODE>copy-from-core</CODE>
</tr>
<tr><td><CODE>core-b</CODE>
<td><CODE>core-all-processes</CODE>
</tr>
<tr><td><CODE>core-cdr</CODE>
<td><CODE>core-car</CODE>
</tr>
<tr><td><CODE>core-find-class</CODE>
<td><CODE>core-consp</CODE>
</tr>
<tr><td><CODE>core-find-process-for-id</CODE>
<td><CODE>core-find-package</CODE>
</tr>
<tr><td><CODE>core-functionp</CODE>
<td><CODE>core-find-symbol</CODE>
</tr>
<tr><td><CODE>core-hash-table-count</CODE>
<td><CODE>core-gethash</CODE>
</tr>
<tr><td><CODE>core-instance-class</CODE>
<td><CODE>core-heap-utilization</CODE>
</tr>
<tr><td><CODE>core-keyword-package</CODE>
<td><CODE>core-instance-p</CODE>
</tr>
<tr><td><CODE>core-lfun-bits</CODE>
<td><CODE>core-l</CODE>
</tr>
<tr><td><CODE>core-list</CODE>
<td><CODE>core-lfun-name</CODE>
</tr>
<tr><td><CODE>core-map-symbols</CODE>
<td><CODE>core-listp</CODE>
</tr>
<tr><td><CODE>core-nullp</CODE>
<td><CODE>core-nth-immediate</CODE>
</tr>
<tr><td><CODE>core-object-typecode-type</CODE>
<td><CODE>core-object-type-key</CODE>
</tr>
<tr><td><CODE>core-package-names</CODE>
<td><CODE>core-package-name</CODE>
</tr>
<tr><td><CODE>core-print-call-history</CODE>
<td><CODE>core-print</CODE>
</tr>
<tr><td><CODE>core-q</CODE>
<td><CODE>core-process-name</CODE>
</tr>
<tr><td><CODE>core-symbol-name</CODE>
<td><CODE>core-string=</CODE>
</tr>
<tr><td><CODE>core-symbol-plist</CODE>
<td><CODE>core-symbol-package</CODE>
</tr>
<tr><td><CODE>core-symbolp</CODE>
<td><CODE>core-symbol-value</CODE>
</tr>
<tr><td><CODE>core-uvector-p</CODE>
<td><CODE>core-type-string</CODE>
</tr>
<tr><td><CODE>core-uvsize</CODE>
<td><CODE>core-uvref</CODE>
</tr>
<tr><td><CODE>core-uvtypep</CODE>
<td><CODE>core-uvtype</CODE>
</tr>
<tr><td><a href="#f_count-characters-in-octet-vector"><CODE>count-characters-in-octet-vector</CODE></a>
<td><CODE>core-w</CODE>
</tr>
<tr><td><CODE>coverage-code-forms-total</CODE>
<td><CODE>coverage-code-forms-covered</CODE>
</tr>
<tr><td><CODE>coverage-expressions-entered</CODE>
<td><CODE>coverage-expressions-covered</CODE>
</tr>
<tr><td><CODE>coverage-functions-fully-covered</CODE>
<td><CODE>coverage-expressions-total</CODE>
</tr>
<tr><td><CODE>coverage-functions-partly-covered</CODE>
<td><CODE>coverage-functions-not-entered</CODE>
</tr>
<tr><td><CODE>coverage-source-file</CODE>
<td><CODE>coverage-functions-total</CODE>
</tr>
<tr><td><CODE>coverage-unreached-branches</CODE>
<td><a href="#f_coverage-statistics"><CODE>coverage-statistics</CODE></a>
</tr>
<tr><td><CODE>create-directory</CODE>
<td><CODE>cpu-count</CODE>
</tr>
<tr><td><CODE>create-interfaces</CODE>
<td><CODE>create-file</CODE>
</tr>
<tr><td><CODE>current-directory</CODE>
<td><CODE>current-compiler-policy</CODE>
</tr>
<tr><td><CODE>current-process-allocation-quantum</CODE>
<td><CODE>current-file-compiler-policy</CODE>
</tr>
<tr><td><CODE>cwd</CODE>
<td><CODE>current-time-in-nanoseconds</CODE>
</tr>
<tr><td><CODE>declaration-information</CODE>
<td><CODE>dbg-form</CODE>
</tr>
<tr><td><a href="#m_def-foreign-type"><CODE>def-foreign-type</CODE></a>
<td><a href="#f_decode-string-from-octets"><CODE>decode-string-from-octets</CODE></a>
</tr>
<tr><td><CODE>default-allocation-quantum</CODE>
<td><CODE>def-load-pointers</CODE>
</tr>
<tr><td><CODE>defglobal</CODE>
<td><a href="#m_defcallback"><CODE>defcallback</CODE></a>
</tr>
<tr><td><CODE>define-character-encoding</CODE>
<td><CODE>define-callback</CODE>
</tr>
<tr><td><CODE>define-declaration</CODE>
<td><CODE>define-character-encoding-alias</CODE>
</tr>
<tr><td><CODE>define-setf-method</CODE>
<td><CODE>define-definition-type</CODE>
</tr>
<tr><td><CODE>defloadvar</CODE>
<td><CODE>definition-type-name</CODE>
</tr>
<tr><td><CODE>defstaticvar</CODE>
<td><a href="#m_defstatic"><CODE>defstatic</CODE></a>
</tr>
<tr><td><CODE>delq</CODE>
<td><CODE>delete-directory</CODE>
</tr>
<tr><td><a href="#f_describe-character-encodings"><CODE>describe-character-encodings</CODE></a>
<td><CODE>describe-character-encoding</CODE>
</tr>
<tr><td><CODE>directory-pathname-p</CODE>
<td><CODE>direct-slot-definition-class</CODE>
</tr>
<tr><td><CODE>displaced-array-p</CODE>
<td><CODE>directoryp</CODE>
</tr>
<tr><td><a href="#f_dotted-to-ipaddr"><CODE>dotted-to-ipaddr</CODE></a>
<td><CODE>dispose-heap-ivector</CODE>
</tr>
<tr><td><CODE>dparef</CODE>
<td><CODE>dovector</CODE>
</tr>
<tr><td><CODE>edit-definition-p</CODE>
<td><CODE>drain-termination-queue</CODE>
</tr>
<tr><td><a href="#f_egc"><CODE>egc</CODE></a>
<td><CODE>effective-slot-definition-class</CODE>
</tr>
<tr><td><a href="#f_egc-configuration"><CODE>egc-configuration</CODE></a>
<td><a href="#f_egc-active-p"><CODE>egc-active-p</CODE></a>
</tr>
<tr><td><CODE>enclose</CODE>
<td><a href="#f_egc-enabled-p"><CODE>egc-enabled-p</CODE></a>
</tr>
<tr><td><CODE>ensure-class</CODE>
<td><a href="#f_encode-string-to-octets"><CODE>encode-string-to-octets</CODE></a>
</tr>
<tr><td><CODE>ensure-generic-function-using-class</CODE>
<td><CODE>ensure-class-using-class</CODE>
</tr>
<tr><td><a href="#f_ensure-source-note-text"><CODE>ensure-source-note-text</CODE></a>
<td><CODE>ensure-simple-string</CODE>
</tr>
<tr><td><CODE>event-ticks</CODE>
<td><CODE>eql-specializer-object</CODE>
</tr>
<tr><td><a href="#m_external"><CODE>external</CODE></a>
<td><CODE>extended-char-p</CODE>
</tr>
<tr><td><CODE>external-format-character-encoding</CODE>
<td><a href="#m_external-call"><CODE>external-call</CODE></a>
</tr>
<tr><td><a href="#f_external-process-error-stream"><CODE>external-process-error-stream</CODE></a>
<td><CODE>external-format-line-termination</CODE>
</tr>
<tr><td><a href="#f_external-process-input-stream"><CODE>external-process-input-stream</CODE></a>
<td><a href="#f_external-process-id"><CODE>external-process-id</CODE></a>
</tr>
<tr><td><a href="#f_external-process-status"><CODE>external-process-status</CODE></a>
<td><a href="#f_external-process-output-stream"><CODE>external-process-output-stream</CODE></a>
</tr>
<tr><td><CODE>extract-specializer-names</CODE>
<td><CODE>extract-lambda-list</CODE>
</tr>
<tr><td><a href="#f_fasl-concatenate"><CODE>fasl-concatenate</CODE></a>
<td><CODE>false</CODE>
</tr>
<tr><td><CODE>finalize-inheritance</CODE>
<td><a href="#m_ff-call"><CODE>ff-call</CODE></a>
</tr>
<tr><td><CODE>find-method-combination</CODE>
<td><CODE>find-definition-sources</CODE>
</tr>
<tr><td><CODE>find-source-note-at-pc</CODE>
<td><CODE>find-referencers</CODE>
</tr>
<tr><td><a href="#f_foreign-symbol-address"><CODE>foreign-symbol-address</CODE></a>
<td><CODE>fixnump</CODE>
</tr>
<tr><td><CODE>frame-function</CODE>
<td><a href="#f_foreign-symbol-entry"><CODE>foreign-symbol-entry</CODE></a>
</tr>
<tr><td><CODE>frame-supplied-arguments</CODE>
<td><CODE>frame-named-variables</CODE>
</tr>
<tr><td><CODE>free-static-conses</CODE>
<td><a href="#f_free"><CODE>free</CODE></a>
</tr>
<tr><td><CODE>full-pathname</CODE>
<td><CODE>fset</CODE>
</tr>
<tr><td><CODE>function-args</CODE>
<td><CODE>funcallable-standard-instance-access</CODE>
</tr>
<tr><td><CODE>function-name</CODE>
<td><CODE>function-information</CODE>
</tr>
<tr><td><a href="#f_gc"><CODE>gc</CODE></a>
<td><a href="#f_function-source-note"><CODE>function-source-note</CODE></a>
</tr>
<tr><td><a href="#f_gc-retaining-pages"><CODE>gc-retaining-pages</CODE></a>
<td><a href="#f_gc-retain-pages"><CODE>gc-retain-pages</CODE></a>
</tr>
<tr><td><CODE>gc-verbose-p</CODE>
<td><CODE>gc-verbose</CODE>
</tr>
<tr><td><CODE>gctime</CODE>
<td><CODE>gccounts</CODE>
</tr>
<tr><td><CODE>generic-function-declarations</CODE>
<td><CODE>generic-function-argument-precedence-order</CODE>
</tr>
<tr><td><CODE>generic-function-method-class</CODE>
<td><CODE>generic-function-lambda-list</CODE>
</tr>
<tr><td><CODE>generic-function-methods</CODE>
<td><CODE>generic-function-method-combination</CODE>
</tr>
<tr><td><CODE>get-character-encoding</CODE>
<td><CODE>generic-function-name</CODE>
</tr>
<tr><td><a href="#f_get-encoded-string"><CODE>get-encoded-string</CODE></a>
<td><a href="#f_get-coverage"><CODE>get-coverage</CODE></a>
</tr>
<tr><td><a href="#f_get-fpu-mode"><CODE>get-fpu-mode</CODE></a>
<td><CODE>get-foreign-namestring</CODE>
</tr>
<tr><td><a href="#f_get-incremental-coverage"><CODE>get-incremental-coverage</CODE></a>
<td><CODE>get-gc-notification-threshold</CODE>
</tr>
<tr><td><CODE>get-setf-method</CODE>
<td><CODE>get-output-stream-vector</CODE>
</tr>
<tr><td><CODE>get-string-from-user</CODE>
<td><CODE>get-setf-method-multiple-value</CODE>
</tr>
<tr><td><a href="#f_grab-lock"><CODE>grab-lock</CODE></a>
<td><a href="#f_getenv"><CODE>getenv</CODE></a>
</tr>
<tr><td><CODE>heap-allocation-allowed-p</CODE>
<td><CODE>hash-table-weak-p</CODE>
</tr>
<tr><td><CODE>idom-heap-utilization</CODE>
<td><a href="#f_heap-utilization"><CODE>heap-utilization</CODE></a>
</tr>
<tr><td><a href="#f_incremental-coverage-source-matches"><CODE>incremental-coverage-source-matches</CODE></a>
<td><CODE>include</CODE>
</tr>
<tr><td><CODE>init-list-default</CODE>
<td><a href="#f_incremental-coverage-svn-matches"><CODE>incremental-coverage-svn-matches</CODE></a>
</tr>
<tr><td><a href="#f_ipaddr-to-dotted"><CODE>ipaddr-to-dotted</CODE></a>
<td><CODE>intern-eql-specializer</CODE>
</tr>
<tr><td><a href="#f_join-process"><CODE>join-process</CODE></a>
<td><a href="#f_ipaddr-to-hostname"><CODE>ipaddr-to-hostname</CODE></a>
</tr>
<tr><td><a href="#f_lisp-heap-gc-threshold"><CODE>lisp-heap-gc-threshold</CODE></a>
<td><CODE>let-globally</CODE>
</tr>
<tr><td><CODE>local-filename</CODE>
<td><CODE>list-character-encodings</CODE>
</tr>
<tr><td><a href="#f_local-port"><CODE>local-port</CODE></a>
<td><a href="#f_local-host"><CODE>local-host</CODE></a>
</tr>
<tr><td><CODE>lock-acquisition-status</CODE>
<td><CODE>local-socket-address</CODE>
</tr>
<tr><td><CODE>lookup-character-encoding</CODE>
<td><CODE>lock-name</CODE>
</tr>
<tr><td><a href="#f_lookup-port"><CODE>lookup-port</CODE></a>
<td><a href="#f_lookup-hostname"><CODE>lookup-hostname</CODE></a>
</tr>
<tr><td><CODE>mac-default-directory</CODE>
<td><CODE>lsh</CODE>
</tr>
<tr><td><CODE>macroexpand-all</CODE>
<td><CODE>macptrp</CODE>
</tr>
<tr><td><a href="#f_make-heap-ivector"><CODE>make-heap-ivector</CODE></a>
<td><a href="#f_make-external-format"><CODE>make-external-format</CODE></a>
</tr>
<tr><td><CODE>make-lock-acquisition</CODE>
<td><a href="#f_make-lock"><CODE>make-lock</CODE></a>
</tr>
<tr><td><a href="#f_make-process"><CODE>make-process</CODE></a>
<td><a href="#f_make-population"><CODE>make-population</CODE></a>
</tr>
<tr><td><a href="#m_make-record"><CODE>make-record</CODE></a>
<td><a href="#f_make-read-write-lock"><CODE>make-read-write-lock</CODE></a>
</tr>
<tr><td><CODE>make-semaphore-notification</CODE>
<td><a href="#f_make-semaphore"><CODE>make-semaphore</CODE></a>
</tr>
<tr><td><CODE>make-truncating-string-stream</CODE>
<td><a href="#f_make-socket"><CODE>make-socket</CODE></a>
</tr>
<tr><td><CODE>make-vector-output-stream</CODE>
<td><CODE>make-vector-input-stream</CODE>
</tr>
<tr><td><CODE>map-core-areas</CODE>
<td><CODE>map-call-frames</CODE>
</tr>
<tr><td><a href="#f_map-file-to-ivector"><CODE>map-file-to-ivector</CODE></a>
<td><CODE>map-dependents</CODE>
</tr>
<tr><td><CODE>map-heap-objects</CODE>
<td><a href="#f_map-file-to-octet-vector"><CODE>map-file-to-octet-vector</CODE></a>
</tr>
<tr><td><CODE>method-exists-p</CODE>
<td><CODE>memq</CODE>
</tr>
<tr><td><CODE>method-generic-function</CODE>
<td><CODE>method-function</CODE>
</tr>
<tr><td><CODE>method-name</CODE>
<td><CODE>method-lambda-list</CODE>
</tr>
<tr><td><CODE>method-specializers</CODE>
<td><CODE>method-qualifiers</CODE>
</tr>
<tr><td><CODE>native-to-pathname</CODE>
<td><CODE>name-of</CODE>
</tr>
<tr><td><CODE>neq</CODE>
<td><a href="#f_native-translated-namestring"><CODE>native-translated-namestring</CODE></a>
</tr>
<tr><td><CODE>nfunction</CODE>
<td><CODE>new-compiler-policy</CODE>
</tr>
<tr><td><CODE>nremove</CODE>
<td><a href="#f_note-open-file-stream"><CODE>note-open-file-stream</CODE></a>
</tr>
<tr><td><a href="#f_object-direct-size"><CODE>object-direct-size</CODE></a>
<td><CODE>nstring-studlify</CODE>
</tr>
<tr><td><a href="#f_open-file-streams"><CODE>open-file-streams</CODE></a>
<td><CODE>open-core</CODE>
</tr>
<tr><td><CODE>optimize-generic-function-dispatching</CODE>
<td><a href="#f_open-shared-library"><CODE>open-shared-library</CODE></a>
</tr>
<tr><td><CODE>paref</CODE>
<td><CODE>override-one-method-one-arg-dcode</CODE>
</tr>
<tr><td><CODE>parse-proc-maps</CODE>
<td><CODE>parse-macro</CODE>
</tr>
<tr><td><CODE>parse-unsigned-integer</CODE>
<td><CODE>parse-signed-integer</CODE>
</tr>
<tr><td><CODE>pointerp</CODE>
<td><a href="#f_pathname-encoding-name"><CODE>pathname-encoding-name</CODE></a>
</tr>
<tr><td><a href="#f_population-type"><CODE>population-type</CODE></a>
<td><a href="#f_population-contents"><CODE>population-contents</CODE></a>
</tr>
<tr><td><CODE>print-call-history</CODE>
<td><a href="#m_pref"><CODE>pref</CODE></a>
</tr>
<tr><td><a href="#f_process-abort"><CODE>process-abort</CODE></a>
<td><CODE>proc-maps-diff</CODE>
</tr>
<tr><td><a href="#f_process-allow-schedule"><CODE>process-allow-schedule</CODE></a>
<td><CODE>process-allocation-quantum</CODE>
</tr>
<tr><td><a href="#f_process-enable"><CODE>process-enable</CODE></a>
<td><CODE>process-creation-time</CODE>
</tr>
<tr><td><CODE>process-initial-form</CODE>
<td><CODE>process-exhausted-p</CODE>
</tr>
<tr><td><a href="#f_process-interrupt"><CODE>process-interrupt</CODE></a>
<td><a href="#f_process-input-wait"><CODE>process-input-wait</CODE></a>
</tr>
<tr><td><CODE>process-kill-issued</CODE>
<td><a href="#f_process-kill"><CODE>process-kill</CODE></a>
</tr>
<tr><td><a href="#f_process-output-wait"><CODE>process-output-wait</CODE></a>
<td><CODE>process-name</CODE>
</tr>
<tr><td><a href="#f_process-preset"><CODE>process-preset</CODE></a>
<td><CODE>process-plist</CODE>
</tr>
<tr><td><a href="#f_process-reset"><CODE>process-reset</CODE></a>
<td><CODE>process-priority</CODE>
</tr>
<tr><td><a href="#f_process-resume"><CODE>process-resume</CODE></a>
<td><a href="#f_process-reset-and-enable"><CODE>process-reset-and-enable</CODE></a>
</tr>
<tr><td><CODE>process-serial-number</CODE>
<td><a href="#f_process-run-function"><CODE>process-run-function</CODE></a>
</tr>
<tr><td><a href="#f_process-suspend-count"><CODE>process-suspend-count</CODE></a>
<td><a href="#f_process-suspend"><CODE>process-suspend</CODE></a>
</tr>
<tr><td><CODE>process-total-run-time</CODE>
<td><CODE>process-termination-semaphore</CODE>
</tr>
<tr><td><a href="#f_process-wait-with-timeout"><CODE>process-wait-with-timeout</CODE></a>
<td><a href="#f_process-wait"><CODE>process-wait</CODE></a>
</tr>
<tr><td><CODE>proclaimed-special-p</CODE>
<td><a href="#f_process-whostate"><CODE>process-whostate</CODE></a>
</tr>
<tr><td><CODE>pui-stream</CODE>
<td><CODE>psi-stream</CODE>
</tr>
<tr><td><CODE>ratiop</CODE>
<td><a href="#f_quit"><CODE>quit</CODE></a>
</tr>
<tr><td><CODE>reader-method-class</CODE>
<td><a href="#f_read-coverage-from-file"><CODE>read-coverage-from-file</CODE></a>
</tr>
<tr><td><a href="#f_receive-from"><CODE>receive-from</CODE></a>
<td><CODE>rebuild-ccl</CODE>
</tr>
<tr><td><a href="#f_release-lock"><CODE>release-lock</CODE></a>
<td><CODE>record-source-file</CODE>
</tr>
<tr><td><a href="#f_remote-host"><CODE>remote-host</CODE></a>
<td><CODE>remote-filename</CODE>
</tr>
<tr><td><CODE>remote-socket-address</CODE>
<td><a href="#f_remote-port"><CODE>remote-port</CODE></a>
</tr>
<tr><td><CODE>remove-character-encoding-alias</CODE>
<td><CODE>remove-auto-flush-stream</CODE>
</tr>
<tr><td><CODE>remove-direct-method</CODE>
<td><CODE>remove-dependent</CODE>
</tr>
<tr><td><CODE>remove-feature</CODE>
<td><CODE>remove-direct-subclass</CODE>
</tr>
<tr><td><a href="#f_remove-open-file-stream"><CODE>remove-open-file-stream</CODE></a>
<td><CODE>remove-method</CODE>
</tr>
<tr><td><CODE>report-compiler-warning</CODE>
<td><CODE>repl-function-name</CODE>
</tr>
<tr><td><CODE>require-type</CODE>
<td><a href="#f_report-coverage"><CODE>report-coverage</CODE></a>
</tr>
<tr><td><a href="#f_reset-coverage"><CODE>reset-coverage</CODE></a>
<td><CODE>reserved-static-conses</CODE>
</tr>
<tr><td><a href="#f_resolve-address"><CODE>resolve-address</CODE></a>
<td><a href="#f_reset-incremental-coverage"><CODE>reset-incremental-coverage</CODE></a>
</tr>
<tr><td><a href="#f_restore-coverage-from-file"><CODE>restore-coverage-from-file</CODE></a>
<td><a href="#f_restore-coverage"><CODE>restore-coverage</CODE></a>
</tr>
<tr><td><a href="#m_rletz"><CODE>rletz</CODE></a>
<td><a href="#m_rlet"><CODE>rlet</CODE></a>
</tr>
<tr><td><a href="#f_run-program"><CODE>run-program</CODE></a>
<td><CODE>rref</CODE>
</tr>
<tr><td><CODE>save-coverage</CODE>
<td><a href="#f_save-application"><CODE>save-application</CODE></a>
</tr>
<tr><td><CODE>select-item-from-list</CODE>
<td><a href="#f_save-coverage-in-file"><CODE>save-coverage-in-file</CODE></a>
</tr>
<tr><td><a href="#f_send-to"><CODE>send-to</CODE></a>
<td><CODE>semaphore-notification-status</CODE>
</tr>
<tr><td><CODE>set-current-file-compiler-policy</CODE>
<td><CODE>set-current-compiler-policy</CODE>
</tr>
<tr><td><CODE>set-event-ticks</CODE>
<td><a href="#f_set-development-environment"><CODE>set-development-environment</CODE></a>
</tr>
<tr><td><CODE>set-funcallable-instance-function</CODE>
<td><a href="#f_set-fpu-mode"><CODE>set-fpu-mode</CODE></a>
</tr>
<tr><td><a href="#f_set-lisp-heap-gc-threshold"><CODE>set-lisp-heap-gc-threshold</CODE></a>
<td><CODE>set-gc-notification-threshold</CODE>
</tr>
<tr><td><a href="#f_setenv"><CODE>setenv</CODE></a>
<td><a href="#f_set-user-environment"><CODE>set-user-environment</CODE></a>
</tr>
<tr><td><a href="#f_shutdown"><CODE>shutdown</CODE></a>
<td><CODE>setf-function-spec-name</CODE>
</tr>
<tr><td><a href="#f_signal-semaphore"><CODE>signal-semaphore</CODE></a>
<td><a href="#f_signal-external-process"><CODE>signal-external-process</CODE></a>
</tr>
<tr><td><CODE>slot-boundp-using-class</CODE>
<td><CODE>signed-integer-to-binary</CODE>
</tr>
<tr><td><CODE>slot-definition-documentation</CODE>
<td><CODE>slot-definition-allocation</CODE>
</tr>
<tr><td><CODE>slot-definition-initform</CODE>
<td><CODE>slot-definition-initargs</CODE>
</tr>
<tr><td><CODE>slot-definition-location</CODE>
<td><CODE>slot-definition-initfunction</CODE>
</tr>
<tr><td><CODE>slot-definition-readers</CODE>
<td><CODE>slot-definition-name</CODE>
</tr>
<tr><td><CODE>slot-definition-writers</CODE>
<td><CODE>slot-definition-type</CODE>
</tr>
<tr><td><CODE>slot-value-using-class</CODE>
<td><CODE>slot-makunbound-using-class</CODE>
</tr>
<tr><td><a href="#f_socket-address-host"><CODE>socket-address-host</CODE></a>
<td><a href="#f_socket-address-family"><CODE>socket-address-family</CODE></a>
</tr>
<tr><td><a href="#f_socket-address-port"><CODE>socket-address-port</CODE></a>
<td><CODE>socket-address-path</CODE>
</tr>
<tr><td><CODE>socket-creation-error-code</CODE>
<td><a href="#f_socket-connect"><CODE>socket-connect</CODE></a>
</tr>
<tr><td><CODE>socket-creation-error-situation</CODE>
<td><CODE>socket-creation-error-identifier</CODE>
</tr>
<tr><td><a href="#f_socket-error-code"><CODE>socket-error-code</CODE></a>
<td><a href="#c_socket-error"><CODE>socket-error</CODE></a>
</tr>
<tr><td><a href="#f_socket-error-situation"><CODE>socket-error-situation</CODE></a>
<td><a href="#f_socket-error-identifier"><CODE>socket-error-identifier</CODE></a>
</tr>
<tr><td><a href="#f_socket-os-fd"><CODE>socket-os-fd</CODE></a>
<td><a href="#f_socket-format"><CODE>socket-format</CODE></a>
</tr>
<tr><td><a href="#f_source-note-end-pos"><CODE>source-note-end-pos</CODE></a>
<td><a href="#f_socket-type"><CODE>socket-type</CODE></a>
</tr>
<tr><td><CODE>source-note-p</CODE>
<td><a href="#f_source-note-filename"><CODE>source-note-filename</CODE></a>
</tr>
<tr><td><a href="#f_source-note-text"><CODE>source-note-text</CODE></a>
<td><a href="#f_source-note-start-pos"><CODE>source-note-start-pos</CODE></a>
</tr>
<tr><td><CODE>special-form-p</CODE>
<td><CODE>sparef</CODE>
</tr>
<tr><td><CODE>specializer-direct-methods</CODE>
<td><CODE>specializer-direct-generic-functions</CODE>
</tr>
<tr><td><CODE>static-cons</CODE>
<td><CODE>standard-instance-access</CODE>
</tr>
<tr><td><CODE>stream-clear-input</CODE>
<td><CODE>stream-advance-to-column</CODE>
</tr>
<tr><td><CODE>stream-deadline</CODE>
<td><CODE>stream-clear-output</CODE>
</tr>
<tr><td><CODE>stream-direction</CODE>
<td><a href="#f_stream-device"><CODE>stream-device</CODE></a>
</tr>
<tr><td><CODE>stream-force-output</CODE>
<td><CODE>stream-eofp</CODE>
</tr>
<tr><td><CODE>stream-input-timeout</CODE>
<td><CODE>stream-fresh-line</CODE>
</tr>
<tr><td><CODE>stream-line-length</CODE>
<td><CODE>stream-line-column</CODE>
</tr>
<tr><td><CODE>stream-output-timeout</CODE>
<td><CODE>stream-listen</CODE>
</tr>
<tr><td><CODE>stream-read-byte</CODE>
<td><CODE>stream-peek-char</CODE>
</tr>
<tr><td><CODE>stream-read-char-no-hang</CODE>
<td><CODE>stream-read-char</CODE>
</tr>
<tr><td><CODE>stream-read-line</CODE>
<td><a href="#f_stream-read-ivector"><CODE>stream-read-ivector</CODE></a>
</tr>
<tr><td><a href="#f_stream-read-vector"><CODE>stream-read-vector</CODE></a>
<td><a href="#f_stream-read-list"><CODE>stream-read-list</CODE></a>
</tr>
<tr><td><CODE>stream-terpri</CODE>
<td><CODE>stream-start-line-p</CODE>
</tr>
<tr><td><CODE>stream-write-byte</CODE>
<td><CODE>stream-unread-char</CODE>
</tr>
<tr><td><a href="#f_stream-write-ivector"><CODE>stream-write-ivector</CODE></a>
<td><CODE>stream-write-char</CODE>
</tr>
<tr><td><CODE>stream-write-string</CODE>
<td><a href="#f_stream-write-list"><CODE>stream-write-list</CODE></a>
</tr>
<tr><td><a href="#f_string-size-in-octets"><CODE>string-size-in-octets</CODE></a>
<td><a href="#f_stream-write-vector"><CODE>stream-write-vector</CODE></a>
</tr>
<tr><td><CODE>structurep</CODE>
<td><CODE>structure-typep</CODE>
</tr>
<tr><td><CODE>target-fasl-version</CODE>
<td><CODE>symbol-value-in-process</CODE>
</tr>
<tr><td><CODE>terminate</CODE>
<td><CODE>temp-pathname</CODE>
</tr>
<tr><td><CODE>termination-function</CODE>
<td><a href="#f_terminate-when-unreachable"><CODE>terminate-when-unreachable</CODE></a>
</tr>
<tr><td><CODE>throw-cancel</CODE>
<td><CODE>test-ccl</CODE>
</tr>
<tr><td><CODE>toplevel</CODE>
<td><a href="#f_timed-wait-on-semaphore"><CODE>timed-wait-on-semaphore</CODE></a>
</tr>
<tr><td><CODE>toplevel-loop</CODE>
<td><CODE>toplevel-function</CODE>
</tr>
<tr><td><CODE>transitive-referencers</CODE>
<td><a href="#f_trace-function"><CODE>trace-function</CODE></a>
</tr>
<tr><td><a href="#f_try-lock"><CODE>try-lock</CODE></a>
<td><CODE>true</CODE>
</tr>
<tr><td><CODE>tyo</CODE>
<td><CODE>tyi</CODE>
</tr>
<tr><td><a href="#m_unadvise"><CODE>unadvise</CODE></a>
<td><CODE>type-specifier-p</CODE>
</tr>
<tr><td><a href="#f_unmap-ivector"><CODE>unmap-ivector</CODE></a>
<td><CODE>uncompile-function</CODE>
</tr>
<tr><td><a href="#f_unsetenv"><CODE>unsetenv</CODE></a>
<td><a href="#f_unmap-octet-vector"><CODE>unmap-octet-vector</CODE></a>
</tr>
<tr><td><CODE>untyi</CODE>
<td><CODE>unsigned-integer-to-binary</CODE>
</tr>
<tr><td><a href="#f_unwatch"><CODE>unwatch</CODE></a>
<td><a href="#f_unuse-interface-dir"><CODE>unuse-interface-dir</CODE></a>
</tr>
<tr><td><CODE>update-dependent</CODE>
<td><CODE>update-ccl</CODE>
</tr>
<tr><td><a href="#f_use-lisp-heap-gc-threshold"><CODE>use-lisp-heap-gc-threshold</CODE></a>
<td><a href="#f_use-interface-dir"><CODE>use-interface-dir</CODE></a>
</tr>
<tr><td><CODE>uvref</CODE>
<td><CODE>uvectorp</CODE>
</tr>
<tr><td><CODE>validate-superclass</CODE>
<td><CODE>uvsize</CODE>
</tr>
<tr><td><a href="#f_wait-for-signal"><CODE>wait-for-signal</CODE></a>
<td><CODE>variable-information</CODE>
</tr>
<tr><td><a href="#f_watch"><CODE>watch</CODE></a>
<td><a href="#f_wait-on-semaphore"><CODE>wait-on-semaphore</CODE></a>
</tr>
<tr><td><CODE>whitespacep</CODE>
<td><CODE>weak-gc-method</CODE>
</tr>
<tr><td><CODE>with-decoding-problems-as-errors</CODE>
<td><a href="#m_with-cstrs"><CODE>with-cstrs</CODE></a>
</tr>
<tr><td><CODE>with-encoding-problems-as-errors</CODE>
<td><a href="#m_with-encoded-cstrs"><CODE>with-encoded-cstrs</CODE></a>
</tr>
<tr><td><CODE>with-input-from-vector</CODE>
<td><a href="#m_with-filename-cstrs"><CODE>with-filename-cstrs</CODE></a>
</tr>
<tr><td><a href="#m_with-interrupts-enabled"><CODE>with-interrupts-enabled</CODE></a>
<td><CODE>with-input-timeout</CODE>
</tr>
<tr><td><a href="#m_with-macptrs"><CODE>with-macptrs</CODE></a>
<td><a href="#m_with-lock-grabbed"><CODE>with-lock-grabbed</CODE></a>
</tr>
<tr><td><CODE>with-output-timeout</CODE>
<td><a href="#m_with-open-socket"><CODE>with-open-socket</CODE></a>
</tr>
<tr><td><CODE>with-pointer-to-ivector</CODE>
<td><CODE>with-output-to-vector</CODE>
</tr>
<tr><td><CODE>with-string-vector</CODE>
<td><a href="#m_with-read-lock"><CODE>with-read-lock</CODE></a>
</tr>
<tr><td><a href="#m_with-write-lock"><CODE>with-write-lock</CODE></a>
<td><a href="#m_with-terminal-input"><CODE>with-terminal-input</CODE></a>
</tr>
<tr><td><CODE>without-duplicate-definition-warnings</CODE>
<td><a href="#m_without-compiling-code-coverage"><CODE>without-compiling-code-coverage</CODE></a>
</tr>
<tr><td><a href="#f_write-coverage-to-file"><CODE>write-coverage-to-file</CODE></a>
<td><a href="#m_without-interrupts"><CODE>without-interrupts</CODE></a>
</tr>
<tr><td><CODE>xcompile-ccl</CODE>
<td><CODE>writer-method-class</CODE>
</tr>
<tr><td><CODE>*.fasl-pathname*</CODE>
<td><CODE>xload-level-0</CODE>
</tr>
<tr><td><a href="#v_alternate-line-terminator"><CODE>*alternate-line-terminator*</CODE></a>
<td><CODE>*.lisp-pathname*</CODE>
</tr>
<tr><td><CODE>*application*</CODE>
<td><CODE>*always-eval-user-defvars*</CODE>
</tr>
<tr><td><CODE>*backtrace-format*</CODE>
<td><CODE>*autoload-lisp-package*</CODE>
</tr>
<tr><td><CODE>*backtrace-print-length*</CODE>
<td><CODE>*backtrace-on-break*</CODE>
</tr>
<tr><td><CODE>*backtrace-show-internal-frames*</CODE>
<td><CODE>*backtrace-print-level*</CODE>
</tr>
<tr><td><CODE>*break-loop-when-uninterruptable*</CODE>
<td><CODE>*break-hook*</CODE>
</tr>
<tr><td><a href="#v_break-on-warnings"><CODE>*break-on-warnings*</CODE></a>
<td><a href="#v_break-on-errors"><CODE>*break-on-errors*</CODE></a>
</tr>
<tr><td><a href="#v_command-line-argument-list"><CODE>*command-line-argument-list*</CODE></a>
<td><CODE>*check-call-next-method-with-args*</CODE>
</tr>
<tr><td><CODE>*compile-definitions*</CODE>
<td><a href="#v_compile-code-coverage"><CODE>*compile-code-coverage*</CODE></a>
</tr>
<tr><td><a href="#v_default-external-format"><CODE>*default-external-format*</CODE></a>
<td><a href="#v_current-process"><CODE>*current-process*</CODE></a>
</tr>
<tr><td><a href="#v_default-line-termination"><CODE>*default-line-termination*</CODE></a>
<td><CODE>*default-file-character-encoding*</CODE>
</tr>
<tr><td><a href="#v_disassemble-verbose"><CODE>*disassemble-verbose*</CODE></a>
<td><CODE>*default-socket-character-encoding*</CODE>
</tr>
<tr><td><CODE>*enable-automatic-termination*</CODE>
<td><CODE>*elements-per-buffer*</CODE>
</tr>
<tr><td><CODE>*error-print-length*</CODE>
<td><CODE>*error-print-circle*</CODE>
</tr>
<tr><td><CODE>*fasl-save-definitions*</CODE>
<td><CODE>*error-print-level*</CODE>
</tr>
<tr><td><CODE>*fasl-save-local-symbols*</CODE>
<td><CODE>*fasl-save-doc-strings*</CODE>
</tr>
<tr><td><CODE>*host-page-size*</CODE>
<td><CODE>*heap-image-name*</CODE>
</tr>
<tr><td><a href="#v_lisp-cleanup-functions"><CODE>*lisp-cleanup-functions*</CODE></a>
<td><CODE>*ignore-extra-close-parenthesis*</CODE>
</tr>
<tr><td><CODE>*listener-indent*</CODE>
<td><a href="#v_lisp-startup-functions"><CODE>*lisp-startup-functions*</CODE></a>
</tr>
<tr><td><CODE>*load-preserves-optimization-settings*</CODE>
<td><CODE>*listener-prompt-format*</CODE>
</tr>
<tr><td><CODE>*long-site-name*</CODE>
<td><CODE>*loading-file-source-file*</CODE>
</tr>
<tr><td><CODE>*merge-compiler-warnings*</CODE>
<td><CODE>*make-package-use-defaults*</CODE>
</tr>
<tr><td><CODE>*module-search-path*</CODE>
<td><CODE>*module-provider-functions*</CODE>
</tr>
<tr><td><CODE>*pending-gc-notification-hook*</CODE>
<td><CODE>*pathname-translations-pathname*</CODE>
</tr>
<tr><td><CODE>*print-simple-bit-vector*</CODE>
<td><CODE>*print-abbreviate-quote*</CODE>
</tr>
<tr><td><CODE>*print-string-length*</CODE>
<td><CODE>*print-simple-vector*</CODE>
</tr>
<tr><td><CODE>*quit-interrupt-hook*</CODE>
<td><CODE>*print-structure*</CODE>
</tr>
<tr><td><a href="#v_record-pc-mapping"><CODE>*record-pc-mapping*</CODE></a>
<td><a href="#v_quit-on-eof"><CODE>*quit-on-eof*</CODE></a>
</tr>
<tr><td><CODE>*report-time-function*</CODE>
<td><a href="#v_record-source-file"><CODE>*record-source-file*</CODE></a>
</tr>
<tr><td><a href="#v_restore-lisp-functions"><CODE>*restore-lisp-functions*</CODE></a>
<td><CODE>*resident-editor-hook*</CODE>
</tr>
<tr><td><CODE>*save-definitions*</CODE>
<td><CODE>*save-arglist-info*</CODE>
</tr>
<tr><td><a href="#v_save-exit-functions"><CODE>*save-exit-functions*</CODE></a>
<td><CODE>*save-doc-strings*</CODE>
</tr>
<tr><td><a href="#v_save-source-locations"><CODE>*save-source-locations*</CODE></a>
<td><CODE>*save-local-symbols*</CODE>
</tr>
<tr><td><CODE>*short-site-name*</CODE>
<td><CODE>*select-interactive-process-hook*</CODE>
</tr>
<tr><td><CODE>*signal-printing-errors*</CODE>
<td><a href="#v_show-restarts-on-break"><CODE>*show-restarts-on-break*</CODE></a>
</tr>
<tr><td><CODE>*terminal-character-encoding-name*</CODE>
<td><CODE>*svn-program*</CODE>
</tr>
<tr><td><CODE>*top-error-frame*</CODE>
<td><a href="#v_ticks-per-second"><CODE>*ticks-per-second*</CODE></a>
</tr>
<tr><td><a href="#v_trace-level"><CODE>*trace-level*</CODE></a>
<td><a href="#v_trace-bar-frequency"><CODE>*trace-bar-frequency*</CODE></a>
</tr>
<tr><td><a href="#v_trace-print-length"><CODE>*trace-print-length*</CODE></a>
<td><a href="#v_trace-max-indent"><CODE>*trace-max-indent*</CODE></a>
</tr>
<tr><td><CODE>*trust-paths-from-environment*</CODE>
<td><a href="#v_trace-print-level"><CODE>*trace-print-level*</CODE></a>
</tr>
<tr><td><CODE>*vector-output-stream-default-initial-allocation*</CODE>
<td><a href="#v_unprocessed-command-line-arguments"><CODE>*unprocessed-command-line-arguments*</CODE></a>
</tr>
<tr><td><a href="#v_warn-if-redefine-kernel"><CODE>*warn-if-redefine-kernel*</CODE></a>
<td><CODE>*warn-if-redefine*</CODE>
</tr>
<tr><td><CODE>@</CODE>
<td><a href="#v_null-ptr"><CODE>+null-ptr+</CODE></a>
</tr>
</table>
</div>
</div></body>
</html>
